<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>default.html</title>
</head>
<body>

<script>
(function () {
    'use strict';

    $.widget('slideout', {
        component: 'slideout',
        options: {
            active: 'active'
        },

        /** [create description] */
        create: function () {
            this.toggler = this.element.find(this.options.toggler);
            this.panel = this.element.find(this.options.panel);
            this.focusTrap = this.createFocusTrap(this.panel);
            this.closeBtn = $('<button>').addClass('button-close filter-content-close');
            this.panel.prepend(this.closeBtn);

            this._on(document, {
                keydown: function (e) {
                    if (e.key === 'Escape' && this.element.hasClass(this.options.active)) {
                        this.close();
                    }
                }.bind(this)
            });

            this._on(this.toggler, {
                click: this.toggle,
                keydown: function (e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.toggle();
                    }
                }.bind(this)
            });

            this._on(this.closeBtn, {
                click: this.close
            });
        },

        /** [destroy description] */
        destroy: function () {
            this.close();
            this.closeBtn.remove();
            this._super();
        },

        /** [toggle description] */
        toggle: function () {
            if (this.element.hasClass(this.options.active)) {
                this.close();
            } else {
                this.open();
            }
        },

        /** [open description] */
        open: function () {
            if (this.panel.css('visibility') !== 'hidden') {
                return;
            }

            $.breeze.scrollbar.hide();
            this.panel.one('transitionend', this.focusTrap.activate);
            this.element.addClass(this.options.active);
        },

        /** [close description] */
        close: function () {
            $.breeze.scrollbar.reset();
            this.focusTrap.deactivate();
            this.element.removeClass(this.options.active);
        }
    });

    $(document).on('breeze:load', function () {
        if ($('body').var('--swatches-over-image')) {
            $.async([
                '.products-grid .product-item-details [class^="swatch-opt-"]',
                '[data-appearance="carousel"] .product-item-details [class^="swatch-opt-"]',
            ].join(','), function (el) {
                $(el).appendTo($(el).closest('.product-item-info').find('.product-item-photo'));
            })
            $(document).on('click', 'a [class^="swatch-opt-"]', function (e) {
                e.preventDefault();
            });
        }

        $.async('.breeze-carousel .products-grid', (el) => {
            $(el).pagebuilderCarousel({
                arrows: true
            });
            $(el).parents('.hide.show-on-ready').removeClass('hide');
        });

        if ($('body').var('--header-panel-slideout')) {
            $('.panel.header')
                .clone()
                .removeClass('header panel')
                .addClass('mobile-header-panel')
                .data('breeze-temporary', true)
                .appendTo($('.navigation-wrapper'));
        }
    });
})();

// DO NOT EDIT THIS FILE - IT SHOULD REMAIN EMPTY

// DO NOT EDIT THIS FILE - IT SHOULD REMAIN EMPTY

(function (factory) {
    'use strict';

    if (typeof define === 'function' && define.amd) {
        define([
            'jquery',
            'underscore',
            'Magento_Customer/js/section-config',
            'Magento_Customer/js/customer-data'
        ], factory);
    } else {
        $.ajaxpro = $.ajaxpro || {};
        $.ajaxpro.modalManager = factory($, _, $.sections, $.customerData);
    }
}(function ($, _, sectionConfig, customerData) {
    'use strict';

    /**
    Run force global customer data reload
    require(['Magento_Customer/js/customer-data', 'Magento_Customer/js/section-config'
    ], function (customerData, sectionConfig) {
        customerData.reload(sectionConfig.getSectionNames(), true);
    });
     */
    var isGlobalCustomerDataReload = false;
    $(document).on('customer-data-reload', function (event, data) {
        if ("function" != typeof sectionConfig.getSectionNames) {
            return;
        }
        const sections = data.hasOwnProperty('sections') ? data.sections.sort() : data.sort();
        const sectionNames = sectionConfig.getSectionNames().sort();
        const expiredSectionNames = customerData.getExpiredSectionNames().sort();

        isGlobalCustomerDataReload = _.isEqual(sections, sectionNames) || (expiredSectionNames.length > 0
            && _.isEqual(_.difference(sections, sectionNames).sort(), expiredSectionNames));

    });

    return {
        elements: {},

        destroy: function () {
            this.elements = {};
        },

        /**
         * data-bind="afterRender: afterRender
         *
         * @param {String} id
         * @param {Element} element
         */
        register: function (id, element) {
            var self = this, timerId;

            timerId = setInterval(function () {
                if (!$.active) {
                    self.elements[id] = element;
                    clearInterval(timerId);
                }
            }, 100);
        },

        /**
         * Show window
         *
         * @param {String} key
         */
        show: function (key) {
            var id = 'ajaxpro-' + key,
            element;

            if (this.elements[id]) {
                element = this.elements[id];
                const dialog = element.closest('.ajaxpro-modal-dialog');
                const hasPopupMessages = dialog.hasClass('ajaxpro-popup-simple') ?
                    dialog.find('.messages .message').length > 0 : true;

                if (!dialog.hasClass('_show') && !isGlobalCustomerDataReload && hasPopupMessages) {
                    this.hide();
                    element.trigger('openModal');
                }
            }
        },

        /**
         * eval native additional js
         *
         * @param {String} key
         */
        evalJs: function (key) {
            var id = 'ajaxpro-' + key,
            self = this,
            element;

            if (self.elements[id]) {
                element = self.elements[id];

                $(element).find('script').filter(function (i, script) {
                    return !script.type;
                }).each(function (i, script) {
                    script = $(script).html();

                    if (script.indexOf('document.write(') !== -1) {
                        return console.error(
                            'document.write writes to the document stream, ' +
                            'calling document.write on a closed (loaded) ' +
                            'document automatically calls document.open, ' +
                            'which will clear the document.'
                        );
                    }

                    try {
                        return $.globalEval(script);
                    } catch (err) {
                        console.log(script);
                        console.error(err);
                    }
                });
            }
        },

        /**
         * Hide modal window
         */
        hide: function () {
            $('.block-ajaxpro').each(function (i, el) {
                $(el).trigger('closeModal');
            });
        }
    };
}));
/* global _ ko */
(function () {
    'use strict';

    $.view('ajaxpro', {
        component: 'Swissup_Ajaxpro/js/ajaxpro',

        /** [create description] */
        create: function () {
            var self = this,
                sections = [
                    'ajaxpro-cart',
                    'ajaxpro-product',
                    'ajaxpro-reinit'
                ];

            this.data = {};
            this.subscriptions = [];
            this.isLoading = ko.observable(false);

            _.each(sections, function (section) {
                var ajaxproData = $.sections.get(section);

                // ajaxproData.extend({disposableCustomerData: section});

                self.update(ajaxproData());

                self.subscriptions.push(ajaxproData.subscribe(self._subscribe, self));
            });

            return this._super();
        },

        destroy: function () {
            $.ajaxpro.modalManager.destroy();
            _.invoke(this.subscriptions, 'dispose');
            this._super();
        },

        /**
         * @return {Boolean}
         */
        isActive: function () {
            return true;
        },

        /**
         * @param {Element} element
         */
        afterRender: function (element) {
            var el;

            if (!element) {
                return;
            }

            el = $(element).closest('.block-ajaxpro');

            if (el) {
                $.ajaxpro.modalManager.register(element.id, el);
            }
        },

        /**
         * Get ajaxpro param by name.
         * @param {String} name
         * @returns {*}
         */
        bindBlock: function (name) {
            if (!_.isUndefined(name)) {
                if (!this.data.hasOwnProperty(name)) {
                    this.data[name] = ko.observable();
                }
            }

            return this.data[name]();
        },

        /**
         * Update sections content.
         *
         * @param {Object} updatedData
         */
        update: function (updatedData) {
            _.each(updatedData, function (value, key) {
                if (!this.data.hasOwnProperty(key)) {
                    this.data[key] = ko.observable();
                }
                this.data[key](value);
            }, this);
        },

        /**
         * @param {Object} updatedData
         */
        _subscribe: function (updatedData) {
            var keys = [];

            this.isLoading(false);
            this.update(updatedData);

            keys = _.keys(updatedData);

            // give some time to render js components, to decrease jumping content
            setTimeout(function () {
                _.each(keys, $.proxy($.ajaxpro.modalManager.show, $.ajaxpro.modalManager));

                $(document).trigger('contentUpdated');

                // _.each(keys, $.proxy($.ajaxpro.modalManager.evalJs, $.ajaxpro.modalManager));
            }, 50);
        }
    });
})();

(function () {
    'use strict';

    $.widget('ajaxproModal', 'modal', {
        component: 'Swissup_Ajaxpro/js/modal',

        options: {
            modalClass: 'ajaxpro-modal-dialog',
            clickableOverlay: true,
            closeTimeout: 50,
            closeCounterInterval: 10
        },

        /**
         * @return {Element} - current element.
         */
        openModal: function () {
            var result = this._super();

            this._addCloseModalIterval();

            return result;
        },

        /**
         * Add close interval for close modal
         */
        _addCloseModalIterval: function () {
            var self = this,
                _inteval,
                counter,
                text,
                replaceText,
                continueButtons = $('.modal-inner-wrap .modal-footer .ajaxpro-continue-button');

            if (continueButtons.length &&
                !!this.options.closeTimeout &&
                !!this.options.closeCounterInterval
            ) {
                this.modal.data('intervalCounter', this.options.closeTimeout);
                _inteval = this.options.closeCounterInterval;

                clearInterval(self.interval);
                self.interval = setInterval(function () {
                    counter = self.modal.data('intervalCounter');

                    if (counter <= _inteval) {
                        continueButtons.each(function (i, button) {
                            text = $(button).text();

                            if (-1 === text.indexOf('(')) {
                                text += ' (0)';
                            }
                            replaceText = counter <= 0 ? '' : '(' + counter + ')';

                            text = text.replace(/\(\d+\)/, replaceText);
                            $(button).text(text);
                        });
                    }

                    if (counter <= 0) {
                        self.closeModal();
                    }
                    counter--;
                    self.modal.data('intervalCounter', counter);
                }, 1000);
                _.each(['mousemove', 'click', 'scroll', 'keyup'], function (eventName) {
                    eventName += '.swissupajaxproidle';
                    $('body').on(eventName, _.bind(self._resetCloseinterval, self));
                });
            } else if (this.options.closeTimeout) {
                this._setCloseTimeout();
                _.each(['mousemove', 'click', 'scroll', 'keyup'], function (eventName) {
                    eventName += '.swissupajaxproidle';
                    $('body').on(eventName, _.bind(self._setCloseTimeout, self));
                });
            }
        },

        /**
         * Reset close interval
         */
        _resetCloseinterval: function () {
            this.modal.data('intervalCounter', this.options.closeTimeout);
        },

        /**
         * Set timeout for close modal
         */
        _setCloseTimeout: function () {
            var timeout = this.options.closeTimeout * 1000;

            clearTimeout(this.modal.data('closeTimeout'));
            this.modal.data('closeTimeout', setTimeout(this.closeModal, timeout));
        },

        /**
         * Close modal.
         * @return {Element} - current element.
         */
        closeModal: function () {
            var self = this;

            if (!this.options.isOpen) {
                return this.element;
            }

            this._super();

            clearInterval(self.interval);
            _.each(['mousemove', 'click', 'scroll', 'keyup'], function (eventName) {
                eventName += '.swissupajaxproidle';
                $('body').off(eventName);
            });

            return this.element;
        }
    });
})();

(function () {
    'use strict';

    var ajaxcianSelectors = [],
        customer = $.sections.get('customer');

    /**
     * @param {Object} form
     * @return {Boolean}
     */
    function canProcess(form) {
        if (form.attr('action').indexOf('/wishlist/') > -1 && !customer().fullname) {
            return false;
        }

        if (!form.target) {
            return false;
        }

        return form.target.is(ajaxcianSelectors.join(','));
    }

    $.mixin('dataPost', {
        /**
         * @param {Function} original
         * @param {Object} form
         */
        submitForm: function (original, form) {
            if (!canProcess(form)) {
                return original(form);
            }

            form.target.css('color', 'transparent').spinner(true, {
                css: {
                    width: 20,
                    height: 20
                }
            });

            $.request.post({
                form: form
            }).then(function (response) {
                var data = {};

                if (response && response.body) {
                    data = response.body;
                }

                // give some time to update related sections and then hide spinner
                setTimeout(function () {
                    form.target.css('color', '').spinner(false);
                }, 200);

                if (data && data.backUrl) {
                    if (data.backUrl.indexOf('customer/section/load/') !== -1) {
                        data.backUrl = form.attr('action');
                    }
                    window.location = data.backUrl;
                }
            });
        }
    });

    // collect all selectors supported by ajaxpro
    $.widget('ajaxcianDataPost', {
        component: 'Swissup_Ajaxpro/js/ajaxcian-data-post',

        /** [create description] */
        create: function () {
            if (this.options.__selector &&
                ajaxcianSelectors.indexOf(this.options.__selector) === -1
            ) {
                ajaxcianSelectors.push(this.options.__selector);
            }
        }
    });
})();

(function () {
    'use strict';

    $.mixin('catalogAddToCart', {
        /**
         * @param {Function} original
         * @param {Object} response
         */
        getResponseData: function (original, response) {
            // disable redirect to back url when ajaxpro is recieved (modal popup)
            // @see catalog-product-view.js
            if (response.body.ajaxpro) {
                delete response.body.backUrl;
            }

            return original(response);
        }
    });
})();

(function () {
    'use strict';

    var options = window.swissupAjaxproConfig,
        section = 'ajaxpro-product',
        AjaxproCatalogProductView;

    AjaxproCatalogProductView = {
        /**
         * @param {Number} productId
         */
        request: function (productId) {
            var parameters = {
                'sections': section,
                'update_section_id': false,
                'ajaxpro': {
                    'product_id': productId,
                    'blocks': ['product.view']
                }
            };

            parameters[options.refererParam] = options.refererValue;

            $.request.send({
                url: options.sectionLoadUrl,
                data: parameters
            }).then(function (response) {
                var sections = response.body;

                if (sections[section]) {
                    $.sections.set(section, sections[section]);
                    $.sections.reload(['cart', 'messages']);
                }
            });
        }
    };

    $(document).on('ajaxComplete', function (event, data) {
        var response = data.response,
            request = data.response.req,
            sections = $.sections.getAffectedSections(request.url);

        if (!request.method.match(/post|put/i)) {
            return;
        }

        if (!sections.length) {
            return;
        }

        response = response.body || {};

        if (response.ajaxpro && response.ajaxpro.product && response.ajaxpro.product.id) {
            AjaxproCatalogProductView.request(response.ajaxpro.product.id);
        }
    });
})();

/* global _ */
(function () {
    'use strict';

    $.validator.validators = _.extend($.validator.validators, {
        required: [
            function (value) {
                return !(value === '' || value == null || value.length === 0 || /^\s+$/.test(value));
            },
            $.__('This is a required field.')
        ],
        email: [
            function (value) {
                return $('<input type="email" required/>').val(value).get(0).checkValidity();
            },
            $.__('Please enter a valid email address (Ex: johndoe@domain.com).')
        ],
        equalTo: [
            function (value, element, settings) {
                return value === $(settings).val();
            },
            $.__('Please enter the same value again.')
        ],
        'required-entry': 'required',
        'validate-email': 'email',
        'validate-select': [
            function (value) {
                return value !== 'none' && value != null && value.length !== 0;
            },
            $.__('Please select an option.')
        ],
        'validate-not-negative-number': [
            function (value) {
                return value === '' || parseFloat(value) > 0;
            },
            $.__('Please enter a number 0 or greater in this field.')
        ]
    });
})();

(function () {
    'use strict';

    $.view('form', {
        defaults: {
            namespace: false
        },

        /** [_initialize description] */
        _initialize: function (name, options, element) {
            this.source = $.registry.get(options.provider);

            this._super(name, options, element);

            this.selector = 'input, select, textarea, [data-form-part=' + this.namespace + ']';
        },

        /** [save description] */
        save: function () {
            var provider = $.registry.get(this.options.provider);

            if (!this.validate()) {
                return;
            }

            $(this.element).find(this.selector).each(function () {
                provider.set(this.name, $(this).val());
            });

            return provider.save();
        },

        /**
         * @return {Boolean}
         */
        validate: function () {
            var validator = this.element.find('form').validator('instance');

            return !validator || validator.isValid();
        }
    });
})();

/**
 * A lightweight youtube embed. Still should feel the same to the user, just MUCH faster to initialize and paint.
 *
 * Thx to these as the inspiration
 *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html
 *   https://autoplay-youtube-player.glitch.me/
 *
 * Once built it, I also found these:
 *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (👍👍)
 *   https://github.com/Daugilas/lazyYT
 *   https://github.com/vb/lazyframe
 */

(function () {
    'use strict';

    var css = 'lite-youtube{background-color:#000;position:relative;display:block;contain:content;background-position:center center;background-size:cover;cursor:pointer;max-width:720px}lite-youtube::before{content:"";display:block;position:absolute;top:0;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==);background-position:top;background-repeat:repeat-x;height:60px;padding-bottom:50px;width:100%;transition:all .2s cubic-bezier(0,0,.2,1)}lite-youtube::after{content:"";display:block;padding-bottom:calc(100% / (16 / 9))}lite-youtube>iframe{width:100%;height:100%;position:absolute;top:0;left:0;border:0}lite-youtube>.lty-playbtn{width:68px;height:48px;position:absolute;cursor:pointer;transform:translate3d(-50%,-50%,0);top:50%;left:50%;z-index:1;background-color:transparent;background-image:url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 68 48"><path fill="%23f00" fill-opacity="0.8" d="M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55 C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19 C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z"></path><path d="M 45,24 27,14 27,34" fill="%23fff"></path></svg>\');filter:grayscale(100%);transition:filter .1s cubic-bezier(0,0,.2,1);border:none}lite-youtube .lty-playbtn:focus,lite-youtube:hover>.lty-playbtn{filter:none}lite-youtube.lyt-activated{cursor:unset}lite-youtube.lyt-activated::before,lite-youtube.lyt-activated>.lty-playbtn{opacity:0;pointer-events:none}.lyt-visually-hidden{clip:rect(0 0 0 0);clip-path:inset(50%);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px}';

    $('<style>').text(css).appendTo(document.head);
})();

class LiteYTEmbed extends HTMLElement {
    connectedCallback() {
        this.videoId = this.getAttribute('videoid');

        let playBtnEl = this.querySelector('.lty-playbtn');
        // A label for the button takes priority over a [playlabel] attribute on the custom-element
        this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play';

        /**
         * Lo, the youtube placeholder image!  (aka the thumbnail, poster image, etc)
         *
         * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md
         *
         * TODO: Do the sddefault->hqdefault fallback
         *       - When doing this, apply referrerpolicy (https://github.com/ampproject/amphtml/pull/3940)
         * TODO: Consider using webp if supported, falling back to jpg
         */
        if (!this.style.backgroundImage) {
          this.posterUrl = 'https://i.ytimg.com/vi/' + this.videoId + '/hqdefault.jpg';
          // Warm the connection for the poster image
          LiteYTEmbed.addPrefetch('preload', this.posterUrl, 'image');

          this.style.backgroundImage = `url("${this.posterUrl}")`;
        }

        // Set up play button, and its visually hidden label
        if (!playBtnEl) {
            playBtnEl = document.createElement('button');
            playBtnEl.type = 'button';
            playBtnEl.classList.add('lty-playbtn');
            this.append(playBtnEl);
        }
        if (!playBtnEl.textContent) {
            const playBtnLabelEl = document.createElement('span');
            playBtnLabelEl.className = 'lyt-visually-hidden';
            playBtnLabelEl.textContent = this.playLabel;
            playBtnEl.append(playBtnLabelEl);
        }

        // On hover (or tap), warm up the TCP connections we're (likely) about to use.
        this.addEventListener('pointerover', LiteYTEmbed.warmConnections, {once: true});

        // Once the user clicks, add the real iframe and drop our play button
        // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
        //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
        this.addEventListener('click', e => this.addIframe());
    }

    /**
     * Add a <link rel={preload | preconnect} ...> to the head
     */
    static addPrefetch(kind, url, as) {
        const linkEl = document.createElement('link');
        linkEl.rel = kind;
        linkEl.href = url;
        if (as) {
            linkEl.as = as;
        }
        document.head.append(linkEl);
    }

    /**
     * Begin pre-connecting to warm up the iframe load
     * Since the embed's network requests load within its iframe,
     *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
     * So, the best we can do is warm up a few connections to origins that are in the critical path.
     *
     * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
     * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
     */
    static warmConnections() {
        if (LiteYTEmbed.preconnected) return;

        // The iframe document and most of its subresources come right off youtube.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.youtube-nocookie.com');
        // The botguard script is fetched off from google.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.google.com');

        // Not certain if these ad related domains are in the critical path. Could verify with domain-specific throttling.
        LiteYTEmbed.addPrefetch('preconnect', 'https://googleads.g.doubleclick.net');
        LiteYTEmbed.addPrefetch('preconnect', 'https://static.doubleclick.net');

        LiteYTEmbed.preconnected = true;
    }

    addIframe() {
        const params = new URLSearchParams(this.getAttribute('params') || []);
        params.append('autoplay', '1');

        const iframeEl = document.createElement('iframe');
        iframeEl.width = 560;
        iframeEl.height = 315;
        // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
        iframeEl.title = this.playLabel;
        iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
        iframeEl.allowFullscreen = true;
        // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
        // https://stackoverflow.com/q/64959723/89484
        iframeEl.src = 'https://www.youtube-nocookie.com/embed/' + encodeURIComponent(this.videoId) + '?' + params.toString();
        this.append(iframeEl);

        this.classList.add('lyt-activated');

        // Set focus for a11y
        this.querySelector('iframe').focus();
    }
}
// Register custom element
customElements.define('lite-youtube', LiteYTEmbed);

(function () {
    'use strict';

    $.widget('dropdown', {
        component: 'dropdown',
        options: {
            parent: null,
            activeClass: 'active',
            dialog: false,
            menu: '[data-target="dropdown"]'
        },

        /** Init widget */
        create: function () {
            this.status = false;

            if (this.options.parent) {
                this.parent = $(this.options.parent);
            } else {
                this.parent = this.element.parent();
            }

            if (!this.element.is('a, button')) {
                this.element.attr('role', 'button');
                this.element.attr('tabindex', 0);
            }

            this.element.attr('data-dropdown', true);
            this.element.attr('aria-haspopup', true);
            this.parent.attr('data-trigger', true);
            this.parent.attr('data-dropdown-parent', true);

            this._on({
                keydown: function (e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.toggle();
                    }
                }.bind(this)
            });

            this._on(document, {
                keydown: function (e) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.close();
                    }
                }.bind(this)
            });

            this.close();
        },

        /** Hide expanded menu's, remove event listeneres */
        destroy: function () {
            this.close();
            this._super();
        },

        /** Open dropdown */
        open: function () {
            this._trigger('beforeOpen');

            this.status = true;

            this.element.addClass(this.options.activeClass)
                .attr('aria-expanded', true);
            this.parent.addClass(this.options.activeClass)
                .find(this.options.menu)
                .attr('aria-hidden', false)
                .contstraint();
        },

        /** Close dropdown */
        close: function () {
            if (!this.status) {
                return;
            }

            this._trigger('beforeClose');

            this.status = false;

            this.element.removeClass(this.options.activeClass)
                .attr('aria-expanded', false);
            this.parent.removeClass(this.options.activeClass)
                .find(this.options.menu)
                .attr('aria-hidden', true);
        },

        /** Toggle dropdown */
        toggle: function () {
            if (this.status) {
                this.close();
            } else {
                this.open();
            }
        }
    });

    $(document).on('click.dropdown', function (event) {
        var dialog,
            dropdown = $(event.target).closest('[data-dropdown]').dropdown('instance'),
            modalContext = $(event.target).closest('.modal-popup'),
            status = dropdown && dropdown.status;

        if (!dropdown) {
            // Do not close dropdown when click inside its content
            dialog = $(event.target)
                .closest('[data-dropdown-parent]')
                .find('[data-dropdown]')
                .dropdown('instance');

            if (dialog && dialog.options.dialog) {
                return;
            }
        }

        if (modalContext.length) {
            $.widget('dropdown').each(function (widget) {
                if (modalContext.has(widget.element.get(0)).length) {
                    widget.close();
                }
            });
        } else {
            $.widget('dropdown').invoke('close');
        }

        if (dropdown) {
            if (!status) {
                dropdown.open();
            }

            return false;
        }
    });
})();

(function () {
    'use strict';

    $.widget('dropdownDialog', {
        component: 'dropdownDialog',
        options: {
            triggerTarget: null,
            closeOnClickOutside: true,
            appendTo: 'body',
            defaultDialogClass: 'mage-dropdown-dialog',
            dialogClass: '',
            autoPosition: false,
            position: {},
            defaultButtons: [
                {
                    class: 'action close',
                    text: $.__('Close'),

                    /** Click action. */
                    click: function () {
                        $(this).dropdownDialog('close');
                    }
                }
            ]
        },

        /** Init widget */
        create: function () {
            var self = this;

            self.status = false;
            self.dialog = $('<div class="ui-dialog" role="dialog">');
            self.dialog.addClass(self.options.defaultDialogClass);
            self.dialog.addClass(self.options.dialogClass);
            self.dialog.appendTo($(self.options.appendTo));
            self.dialog.hide();

            self.addButtons();

            if (self.options.shadowHinter) {
                self.hinter = $('<div class="' + self.options.shadowHinter + '">');
                $(self.element).append(self.hinter);
            }

            $(self.element).show().prependTo(self.dialog);

            this._on(document, {
                keydown: function (e) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.close();
                    }
                }.bind(this)
            });
        },

        /** Add buttons panel */
        addButtons: function () {
            var self = this,
                pane = $('<div class="ui-dialog-buttonpane">'),
                buttonSet = $('<div class="ui-dialog-buttonset">');

            if (this.options.buttons === undefined) {
                this.options.buttons = this.options.defaultButtons;
            } else if (!this.options.buttons || !this.options.buttons.length) {
                return;
            }

            buttonSet.appendTo(pane);

            $.each(this.options.buttons, function () {
                var button = $('<button role="button" aria-disabled="false">');

                button
                    .addClass(this.class)
                    .html('<span class="ui-button-text">' + this.text + '</span>')
                    .on('click', this.click.bind(self.element))
                    .appendTo(buttonSet);
            });

            this.dialog.append(pane);
        },

        /** Change trigger in runtime. Used by MSRP in tier pricing */
        init: function () {
            var self = this;

            this.trigger = this.options.triggerTarget ? $(this.options.triggerTarget) : false;

            if (this.trigger) {
                $(this.trigger).off('click.dropdownDialog');
                $(this.trigger).on('click.dropdownDialog', function (event) {
                    event.preventDefault();
                    self.toggle();
                });
                this._on(this.trigger, {
                    keydown: function (e) {
                        if (e.key === ' ') {
                            e.preventDefault();
                            self.toggle();
                        }
                    }
                });
            }
        },

        /** Hide expanded menu's, remove event listeneres */
        destroy: function () {
            this.close();
            this._super();
        },

        /** Open dialog */
        open: function () {
            this.status = true;

            if (this.options.autoPosition && this.options.position.of) {
                this.updatePosition();
            }

            this.dialog.show();
            this.toggleClasses(true);

            this.closeHandler = this.close.bind(this);

            $(window).one('breeze:resize-x.dropdownDialog', this.closeHandler);

            this._trigger('open');
        },

        /** Close dialog */
        close: function () {
            this.status = false;

            this.dialog.hide();
            this.toggleClasses(false);

            $(window).off('breeze:resize-x.dropdownDialog', this.closeHandler);

            this._trigger('close');
        },

        /** [toggleClasses description] */
        toggleClasses: function (flag) {
            if (this.options.dialogContentClass) {
                this.element.toggleClass(this.options.dialogContentClass, flag);
            }

            if (this.options.triggerClass && this.trigger) {
                $(this.trigger).toggleClass(this.options.triggerClass, flag);
            }

            if (this.options.parentClass) {
                $(this.options.appendTo).toggleClass(this.options.parentClass, flag);
            }

            if (this.options.bodyClass) {
                $('body').toggleClass(this.options.bodyClass, flag);
            }
        },

        /** Toggle dialog */
        toggle: function () {
            if (this.status) {
                this.close();
            } else {
                this.open();
            }
        },

        /** Update dialog coords */
        updatePosition: function () {
            var target = this.options.position.of,
                targetCoords = target.offset(),
                viewportWidth = $(document.body).width(),
                offset, width, left, diff;

            this.hinter.css('left', '');
            this.dialog.css({
                    position: '',
                    left: '',
                    top: ''
                })
                .show();

            offset = this.dialog.offset();
            width = this.dialog.width();

            if (!this.status) {
                this.dialog.hide();
            }

            left = targetCoords.left;
            diff = left + width - viewportWidth;

            if (diff > 0) {
                left -= diff;

                if (this.hinter) {
                    this.hinter.css('left', this.hinter.position().left + diff);
                }
            }

            this.dialog.css({
                position: 'relative',
                left: left,
                top: targetCoords.top - offset.top + target.height()
            });
        }
    });

    $(document).on('click.dropdownDialog', function (event) {
        var dropdown = $(event.target).closest('[role="dialog"]').children().dropdownDialog('instance'),
            modalContext = $(event.target).closest('.modal-popup');

        $.widget('dropdownDialog').each(function (widget) {
            if (!widget.status || $(widget.trigger).has(event.target).length) {
                return;
            }

            if (modalContext.length &&
                !modalContext.has(widget.element.get(0)).length &&
                (!widget.trigger || !modalContext.has(widget.trigger.get(0)).length)
            ) {
                return;
            }

            if (widget.options.closeOnClickOutside && dropdown !== widget) {
                widget.close();
            }
        });
    });
})();

(function () {
    'use strict';

    $.widget('collapsible', {
        component: 'collapsible',
        options: {
            active: false,
            openedState: 'active',
            collapsible: true,
            header: '[data-role=title]',
            content: '[data-role=content]',
            trigger: '[data-role=trigger]',
            collateral: {
                element: null,
                openedState: null
            },
            ajaxUrlElement: '[data-ajax=true]',
            ajaxUrlAttribute: 'href',
            ajaxContent: false
        },

        /** Mount widget on the element */
        create: function () {
            this.header = typeof this.options.header === 'object' ?
                this.options.header : this.element.find(this.options.header).first();
            this.trigger = typeof this.options.trigger === 'object' ?
                this.options.trigger : this.header.find(this.options.trigger).first();
            this.content = typeof this.options.content === 'object' ?
                this.options.content : this.header.next(this.options.content).first();

            if (!this.trigger.length) {
                this.trigger = this.header;
            }

            this.header.attr('role', 'tab');
            this.header.removeAttr('aria-level');
            this.trigger.attr('data-trigger', true);
            this.trigger.attr('tabindex', 0);
            this.trigger.children('a').attr('tabindex', -1);
            this.element.attr('data-collapsible', true);
            this.content.attr('role', 'tabpanel');

            if (this.header.parent().attr('role') !== 'presentation') {
                this.header.parent().attr('role', 'tablist');
            }

            if (this.options.active) {
                this.open();
            } else {
                this.close();
            }

            this._on({
                'keydown [data-trigger]': function (e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.toggle();
                    }
                }.bind(this)
            });
        },

        /** [init description] */
        init: function () {
            this.disabled = false;
        },

        /** Hide expanded widgets */
        destroy: function () {
            if (!this.options.active) {
                this.close();
            }
            this._super();
        },

        /** [isActive description] */
        isActive: function () {
            return this.content.attr('aria-hidden') === 'false';
        },

        /** Disable click events */
        isEnabled: function () {
            return !this.disabled;
        },

        /** Checks if collapsible is behaved like dropdown (layered for one-column layout) */
        isDropdown: function () {
            return this.content.css('position') === 'absolute';
        },

        /** Disable click events */
        disable: function () {
            this.disabled = true;
        },

        /** Enable click events */
        enable: function () {
            this.disabled = false;
        },

        /** Open dropdown */
        open: function () {
            this._trigger('beforeOpen');

            if (this.options.ajaxContent) {
                this.loadContent();
            }

            if (this.options.openedState) {
                this.element.addClass(this.options.openedState);
            }

            if (this.options.collateral.element) {
                $(this.options.collateral.element).addClass(this.options.collateral.openedState);
            }

            this.header.attr({
                'aria-selected': true,
                'aria-expanded': true
            });
            this.content.attr({
                'aria-hidden': false
            });
            this.content.show();

            // constraint dropdown into the visible viewport
            if (this.isDropdown()) {
                this.content.contstraint();
            }

            this.element.trigger('dimensionsChanged', {
                opened: true
            });
        },

        /** Close dropdown */
        close: function () {
            if (this.options.openedState) {
                this.element.removeClass(this.options.openedState);
            }

            if (this.options.collateral.element) {
                $(this.options.collateral.element).removeClass(this.options.collateral.openedState);
            }

            this.header.attr({
                'aria-selected': false,
                'aria-expanded': false
            });
            this.content.attr({
                'aria-hidden': true
            });
            this.content.hide();

            this.element.trigger('dimensionsChanged', {
                opened: false
            });
        },

        /** Toggle dropdown */
        toggle: function () {
            if (this.element.hasClass(this.options.openedState)) {
                if (this.options.collapsible) {
                    this.close();
                }
            } else {
                this.open();
            }
        },

        /** @private */
        loadContent: function () {
            var url = this.element.find(this.options.ajaxUrlElement).attr(this.options.ajaxUrlAttribute),
                self = this;

            if (!url || this.element.data('loaded')) {
                return;
            }

            self._trigger('beforeLoad');

            if (self.options.loadingClass) {
                self.element.addClass(self.options.loadingClass);
            }
            self.content.spinner(true);
            self.content.attr('aria-busy', 'true');

            $.request.get({
                url: url,
                type: 'html',

                /** [success description] */
                success: function (data) {
                    self.element.data('loaded', true);
                    self.content.empty().append(data).trigger('contentUpdated');
                },

                /** [complete description] */
                complete: function () {
                    self.element.removeClass(self.options.loadingClass);
                    self.content.spinner(false);
                    self.content.removeAttr('aria-busy');
                    self._trigger('afterLoad');
                }
            });
        }
    });

    $(document).on('click.collapsible', function (event) {
        var instance = $(event.target).closest('[data-trigger]').closest('[data-collapsible]').collapsible('instance'),
            tmpInstance;

        if (!instance) {
            // Do not close collapsible when click inside its content
            tmpInstance = $(event.target)
                .closest('[data-collapsible]')
                .collapsible('instance');

            if (tmpInstance && tmpInstance.options.dialog) {
                return;
            }
        }

        $.widget('collapsible').each(function (widget) {
            if (widget === instance) {
                return;
            }

            if (widget.isDropdown() && widget.isEnabled()) {
                widget.close();
            }
        });

        if (!instance || !instance.isEnabled()) {
            return;
        }

        instance.toggle();

        return false;
    });
})();

(function () {
    'use strict';

    $.widget('tabs', {
        component: 'tabs',
        options: {
            active: 0,
            collapsible: false,
            collapsibleElement: '[data-role=collapsible]',
            header: '[data-role=title]',
            content: '[data-role=content]',
            trigger: '[data-role=trigger]'
        },

        /** init widget */
        create: function () {
            var self = this,
                activeIndex,
                expanded = true;

            this.collapsibles = this.element.find(this.options.collapsibleElement);
            this.headers = this.element.find(this.options.header);
            this.triggers = this.element.find(this.options.trigger);
            this.contents = this.element.find(this.options.content);

            if (this.headers.length === 0) {
                this.headers = this.collapsibles;
            }

            if (this.triggers.length === 0) {
                this.triggers = this.headers;
            }

            this.collapsibles
                .attr('role', 'presentation')
                .parent()
                .attr('role', 'tablist');

            this.triggers.attr('role', 'tab');

            activeIndex = this.findActiveTabIndex(location.hash);

            if (activeIndex > -1) {
                this.options.active = activeIndex;
            }

            this.collapsibles.each(function (index, el) {
                var isActive;

                if (_.isArray(self.options.active)) {
                    isActive = self.options.active.indexOf(index) !== -1;
                } else {
                    isActive = index === self.options.active;
                }

                if (!isActive) {
                    expanded = false;
                }

                $(el).collapsible($.extend({}, self.options, {
                    active: isActive,
                    header: self.headers.eq(index),
                    content: self.contents.eq(index),
                    trigger: self.triggers.eq(index)
                }));
            });

            if (expanded) {
                this.triggers.attr('tabIndex', -1);
                this.collapsibles.removeAttr('data-collapsible', true);
            }

            $(this.element).on('collapsible:beforeOpen', function (event, data) {
                var activeTab = self.getActiveTab(),
                    prevContent;

                if (self.collapsibles.index(data.instance.element.get(0)) === -1) {
                    return; // nested tabs
                }

                if (activeTab) {
                    prevContent = activeTab.collapsible('instance').content;
                }

                if (data.instance.options.multipleCollapsible) {
                    return;
                }

                self.prevHeight = prevContent ? $(prevContent).outerHeight() : false;
                self.collapsibles.not(data.instance.element).collapsible('close');

                if (!activeTab.isInViewport()) {
                    activeTab.get(0).scrollIntoView();
                }
            });

            $(this.element).on('collapsible:beforeLoad', function (event, data) {
                if (self.prevHeight && $(window).width() > 767) {
                    data.instance.content.css('height', self.prevHeight);
                }
            });

            $(this.element).on('collapsible:afterLoad', function (event, data) {
                data.instance.content.css('height', 'auto');
            });

            // Reviews and other third-party links
            $(document).on('click.tabs', 'a[href*="#"]', function (event) {
                var anchor = $(this).attr('href').split('#')[1],
                    element,
                    index;

                if (!anchor || self.element.has(this).length) {
                    return;
                }

                index = self.findActiveTabIndex('#' + anchor);

                if (index === -1) {
                    return;
                }

                event.preventDefault();
                self.collapsibles.eq(index).collapsible('open');
                element = self.contents.find('#' + anchor);

                if (!element.length) {
                    element = self.triggers.eq(index);
                }

                element.get(0).scrollIntoView();
            });
        },

        destroy: function () {
            $(document).off('click.tabs');
            this._super();
        },

        /** [getActiveTab description] */
        getActiveTab: function () {
            var tab;

            this.collapsibles.each(function (index, el) {
                if ($(el).collapsible('isActive')) {
                    tab = $(el);

                    return false;
                }
            });

            return tab;
        },

        /** Find active tab index */
        findActiveTabIndex: function (hash) {
            var index = -1,
                activeTrigger,
                activeContent;

            if (!hash || hash.length <= 1) {
                return index;
            }

            activeTrigger = this.triggers.has('[href*="' + hash + '"');

            if (activeTrigger.length) {
                index = this.triggers.index(activeTrigger);
            } else {
                try {
                    activeContent = this.contents.has(hash);
                } catch (e) {
                    return -1;
                }

                if (!activeContent.length) {
                    activeContent = this.contents.filter(hash);
                }

                if (activeContent.length) {
                    index = this.contents.index(activeContent);
                }
            }

            return index;
        }
    });
})();

(function () {
    'use strict';

    $.widget('accordion', 'tabs', {
        component: 'accordion',
        options: {
            collapsible: true
        }
    });
})();

/* global _ */
(function () {
    'use strict';

    $.widget('toggleAdvanced', {
        component: 'toggleAdvanced',
        options: {
            baseToggleClass: 'active',
            selectorsToggleClass: 'hidden',
            toggleContainers: null,
            newLabel: null,
            curLabel: null,
            currentLabelElement: null
        },

        /** Initialize plugin */
        create: function () {
            var self = this;

            this.options = $.extend(this.options, _.filter({
                baseToggleClass: this.element.data('base-toggle-class'),
                selectorsToggleClass: this.element.data('selectors-toggle-class'),
                toggleContainers: this.element.data('toggle-selectors')
            }, function (value) {
                return value;
            }));

            this.element.on('click', function (e) {
                e.preventDefault();
                self.toggle();
            });
        },

        /** Toggle dropdown */
        toggle: function () {
            this.element.toggleClass(this.options.baseToggleClass);

            if (this.options.toggleContainers) {
                $(this.options.toggleContainers).toggleClass(this.options.selectorsToggleClass);
            }
        }
    });
})();

/* global _ */
(function () {
    'use strict';

    $.widget('modal', {
        component: 'Magento_Ui/js/modal/modal',
        options: {
            type: 'popup',
            title: '',
            subTitle: '',
            modalClass: '',
            focus: '[data-role="closeBtn"]',
            autoOpen: false,
            clickableOverlay: true,
            popupTpl: $('#popupTpl').html(),
            slideTpl: $('#slideTpl').html(),
            customTpl: $('#customTpl').html(),
            modalVisibleClass: '_show',
            parentModalClass: '_has-modal',
            innerScrollClass: '_inner-scroll',
            responsive: false,
            innerScroll: false,
            modalTitle: '[data-role="title"]',
            modalSubTitle: '[data-role="subTitle"]',
            modalBlock: '[data-role="modal"]',
            modalCloseBtn: '[data-role="closeBtn"]',
            modalContent: '[data-role="content"]',
            modalAction: '[data-role="action"]',
            focusableScope: '[data-role="focusable-scope"]',
            focusableStart: '[data-role="focusable-start"]',
            focusableEnd: '[data-role="focusable-end"]',
            appendTo: 'body',
            wrapperClass: 'modals-wrapper',
            overlayClass: 'modals-overlay',
            responsiveClass: 'modal-slide',
            trigger: '',
            modalLeftMargin: 45,
            closeText: $.__('Close'),
            buttons: [{
                text: $.__('Ok'),
                class: '',
                attr: {},

                /**
                 * Default action on button click
                 */
                click: function (event) {
                    this.closeModal(event);
                }
            }],
            keyEventHandlers: {
                /**
                 * Escape key press handler,
                 * close modal window
                 * @param {Object} event - event
                 */
                escapeKey: function (event) {
                    if (this.options.isOpen && this.modal.has(document.activeElement).length ||
                        this.options.isOpen && this.modal[0] === document.activeElement) {
                        this.closeModal(event);
                    }
                }
            }
        },

        /**
         * Creates modal widget.
         */
        _create: function () {
            var listeners = {};

            _.bindAll(
                this,
                'keyEventSwitcher',
                'closeModal'
            );

            this.options.id = $.guid++;
            this._createWrapper();
            this._renderModal();
            this._createButtons();
            this.focusTrap = this.createFocusTrap(this.modal);

            if (this.options.trigger) {
                listeners['click ' + this.options.trigger] = this.toggleModal.bind(this);
                this._on(document, listeners);
            }

            listeners = {
                'openModal': this.openModal,
                'closeModal': this.closeModal
            };
            listeners['click ' + this.options.modalCloseBtn] =
                this.options.modalCloseBtnHandler ? this.options.modalCloseBtnHandler : this.closeModal;

            this._on(this.modal, listeners);

            if (this.options.autoOpen) {
                this.openModal();
            }
        },

        destroy: function () {
            this.modalWrapper.remove();
            $(this.options.appendTo).removeClass(this.options.parentModalClass);
            this._super();
        },

        /**
         * Returns element from modal node.
         * @return {Object} - element.
         */
        _getElem: function (elem) {
            return this.modal.find(elem);
        },

        /**
         * Gets visible modal count.
         * * @return {Number} - visible modal count.
         */
        _getVisibleCount: function () {
            var modals = this.modalWrapper.find(this.options.modalBlock);

            return modals.filter('.' + this.options.modalVisibleClass).length;
        },

        /**
         * Gets count of visible modal by slide type.
         * * @return {Number} - visible modal count.
         */
        _getVisibleSlideCount: function () {
            var elems = this.modalWrapper.find('[data-type="slide"]');

            return elems.filter('.' + this.options.modalVisibleClass).length;
        },

        /**
         * Listener key events.
         * Call handler function if it exists
         */
        keyEventSwitcher: function (event) {
            var key = event.key.toLowerCase() + 'Key';

            if (this.options.keyEventHandlers.hasOwnProperty(key)) {
                this.options.keyEventHandlers[key].apply(this, arguments);
            }
        },

        /**
         * Set title for modal.
         *
         * @param {String} title
         */
        setTitle: function (title) {
            var $title = this.modal.find(this.options.modalTitle),
                $subTitle = this.modal.find(this.options.modalSubTitle);

            $title.text(title);
            $title.append($subTitle);
        },

        /**
         * Set sub title for modal.
         *
         * @param {String} subTitle
         */
        setSubTitle: function (subTitle) {
            this.options.subTitle = subTitle;
            this.modal.find(this.options.modalSubTitle).html(subTitle);
        },

        /**
         * Toggle modal.
         * * @return {Element} - current element.
         */
        toggleModal: function () {
            if (this.options.isOpen === true) {
                this.closeModal();
            } else {
                this.openModal();
            }
        },

        /**
         * Open modal.
         * * @return {Element} - current element.
         */
        openModal: function () {
            if (this.options.isOpen) {
                return this.element;
            }

            this.options.isOpen = true;
            this._createOverlay();
            this._setActive();
            this._setKeyListener();
            this.modal.one('transitionend', this.focusTrap.activate);
            this.modal.one('transitionend', _.bind(this._trigger, this, 'opened'));
            this.modal.addClass(this.options.modalVisibleClass);

            return this.element;
        },

        /**
         * Set events listener when modal is opened.
         */
        _setKeyListener: function () {
            this.modal.on('keydown', this.keyEventSwitcher);
        },

        /**
         * Remove events listener when modal is closed.
         */
        _removeKeyListener: function () {
            this.modal.off('keydown', this.keyEventSwitcher);
        },

        /**
         * Close modal.
         * * @return {Element} - current element.
         */
        closeModal: function () {
            var that = this;

            if (!this.options.isOpen) {
                return this.element;
            }

            this._removeKeyListener();
            this.options.isOpen = false;
            this.modal.one('transitionend', function () {
                that._close();
            });
            this.modal.removeClass(this.options.modalVisibleClass);

            return this.element;
        },

        /**
         * Helper for closeModal function.
         */
        _close: function () {
            var trigger = _.bind(this._trigger, this, 'closed', this.modal);

            this.focusTrap.deactivate();
            this._destroyOverlay();
            this._unsetActive();
            _.defer(trigger, this);
        },

        /**
         * Set z-index and margin for modal and overlay.
         */
        _setActive: function () {
            var zIndex = this.modal.zIndex(),
                baseIndex = zIndex + this._getVisibleCount();

            if (this.modal.data('active')) {
                return;
            }

            this.modal.data('active', true);

            this.overlay.zIndex(++baseIndex);
            this.prevOverlayIndex = this.overlay.zIndex();
            this.modal.zIndex(this.overlay.zIndex() + 1);

            if (this._getVisibleSlideCount()) {
                this.modal.css('marginLeft', this.options.modalLeftMargin * this._getVisibleSlideCount());
            }
        },

        /**
         * Unset styles for modal and set z-index for previous modal.
         */
        _unsetActive: function () {
            this.modal.removeAttr('style');
            this.modal.data('active', false);

            if (this.overlay) {
                this.overlay.zIndex(this.prevOverlayIndex - 1);
            }
        },

        /**
         * Creates wrapper to hold all modals.
         */
        _createWrapper: function () {
            this.modalWrapper = $(this.options.appendTo).find('.' + this.options.wrapperClass);

            if (!this.modalWrapper.length) {
                this.modalWrapper = $('<div></div>')
                    .addClass(this.options.wrapperClass)
                    .appendTo(this.options.appendTo);
            }
        },

        /**
         * Compile template and append to wrapper.
         */
        _renderModal: function () {
            $(
                _.template(this.options[this.options.type + 'Tpl'])({
                    data: this.options
                })
            ).appendTo(this.modalWrapper);

            this.modalWrapper.find(this.options.focusableStart).removeAttr('tabindex');
            this.modalWrapper.find(this.options.focusableEnd).removeAttr('tabindex');
            this.modal = this.modalWrapper.find(this.options.modalBlock).last();
            this.element.appendTo(this._getElem(this.options.modalContent));

            if (this.element.is(':hidden')) {
                this.element.show();
            }
        },

        /**
         * Creates buttons pane.
         */
        _createButtons: function () {
            this.buttons = this._getElem(this.options.modalAction);
            _.each(this.options.buttons, function (btn, key) {
                var button = this.buttons[key];

                if (btn.attr) {
                    $(button).attr(btn.attr);
                }

                if (btn.class) {
                    $(button).addClass(btn.class);
                }

                if (!btn.click) {
                    btn.click = this.closeModal;
                }
                $(button).on('click', _.bind(btn.click, this));
            }, this);
        },

        /**
         * Creates overlay, append it to wrapper, set previous click event on overlay.
         */
        _createOverlay: function () {
            var outerClickHandler = this.options.outerClickHandler || this.closeModal;

            this.overlay = $('.' + this.options.overlayClass);

            if (!this.overlay.length) {
                $.breeze.scrollbar.hide();

                $(this.options.appendTo).addClass(this.options.parentModalClass);

                this.overlay = $('<div></div>')
                    .addClass(this.options.overlayClass)
                    .appendTo(this.modalWrapper);
            }

            if (this.options.clickableOverlay) {
                this.overlay.off().on('click', outerClickHandler);
            }
        },

        /**
         * Destroy overlay.
         */
        _destroyOverlay: function () {
            if (!this._getVisibleCount()) {
                $(this.options.appendTo).removeClass(this.options.parentModalClass);
                this.overlay.remove();
                $.breeze.scrollbar.reset();
                this.overlay = null;
            }
        }
    });
})();

/* global _ */
(function () {
    'use strict';

    $.widget('confirm', 'modal', {
        component: 'Magento_Ui/js/modal/confirm',
        options: {
            modalClass: 'confirm',
            title: '',
            focus: '.action-accept',
            actions: {

                /** Callback always - called on all actions. */
                always: function () {},

                /** Callback confirm. */
                confirm: function () {},

                /** Callback cancel. */
                cancel: function () {}
            },
            buttons: [{
                text: $.__('Cancel'),
                class: 'action-secondary action-dismiss',

                /** Click handler. */
                click: function (event) {
                    this.closeModal(event);
                }
            }, {
                text: $.__('OK'),
                class: 'action-primary action-accept',

                /** Click handler. */
                click: function (event) {
                    this.closeModal(event, true);
                }
            }]
        },

        /** Create widget. */
        _create: function () {
            this._super();
            this.openModal();
            this.modal.find(this.options.modalCloseBtn).off().on('click', _.bind(this.closeModal, this));
            this.element.on('confirm:closed', _.bind(this._remove, this));
        },

        /** Remove modal window. */
        _remove: function () {
            this.modal.remove();
        },

        /** Close modal window. */
        closeModal: function (event, result) {
            result = result || false;

            if (result) {
                this.options.actions.confirm(event);
            } else {
                this.options.actions.cancel(event);
            }

            this.options.actions.always(event);

            return this._super();
        }
    });

    /**
     * @param {Object} config
     * @return {Cash}
     */
    $.confirm = function (config) {
        return $('<div></div>').html(config.content).confirm(config);
    };
})();

/* global _ */
(function () {
    'use strict';

    $.widget('alert', 'confirm', {
        component: 'Magento_Ui/js/modal/alert',
        options: {
            modalClass: 'confirm',
            title: $.__('Attention'),
            actions: {

                /** Callback always - called on all actions. */
                always: function () {}
            },
            buttons: [{
                text: $.__('OK'),
                class: 'action-primary action-accept',

                /** Click handler. */
                click: function () {
                    this.closeModal(true);
                }
            }]
        },

        /** Create widget. */
        _create: function () {
            this._super();
            this.element.on('alert:closed', _.bind(this._remove, this));
        }
    });

    /**
     * @param {Object} config
     * @return {Cash}
     */
    $.alert = function (config) {
        return $('<div></div>').html(config.content).alert(config);
    };
})();

/* global _ */
(function () {
    'use strict';

    var customerData,
        storage = $.storage.ns('mage-cache-storage'),
        storageInvalidation = $.storage.ns('mage-cache-storage-section-invalidation');

    /**
     * @param {Object} settings
     */
    function invalidateCacheBySessionTimeOut(settings) {
        var date = new Date(Date.now() + parseInt(settings.cookieLifeTime, 10) * 1000);

        if (new Date(storage.get('mage-cache-timeout')) < new Date()) {
            storage.removeAll();
        }

        storage.set('mage-cache-timeout', date);
    }

    /**
     * Invalidate Cache By Close Cookie Session
     */
    function invalidateCacheByCloseCookieSession() {
        if (!$.cookies.get('mage-cache-sessid')) {
            $.cookies.set('mage-cache-sessid', true, {
                domain: false
            });
            storage.removeAll();
        }
    }

    customerData = {
        /**
         * @param {Object} settings
         */
        initialize: function (settings) {
            this.options = settings;
            invalidateCacheBySessionTimeOut(this.options);
            invalidateCacheByCloseCookieSession();
            this.create();
        },

        /** Init component */
        create: function () {
            var sectionNames;

            // store switcher
            if ($.cookies.get('section_data_clean')) {
                $.cookies.set('section_data_clean', '');

                return this.reload([], true);
            }

            // magento bugfix for deprecated/removed cookie
            if (this.options.expirableSectionNames &&
                _.isEmpty($.cookies.getJson('section_data_ids') || {})
            ) {
                return this.reload([], true);
            }

            sectionNames = this.getExpiredSectionNames();

            if (sectionNames.length > 0) {
                this.reload(sectionNames);
            }
        },

        /**
         * @return {Array}
         */
        getExpiredSectionNames: function () {
            var expiredSectionNames = storageInvalidation.keys(),
                cookieSectionTimestamps = $.cookies.getJson('section_data_ids') || {},
                sectionLifetime = this.options.expirableSectionLifetime * 60,
                currentTimestamp = Math.floor(Date.now() / 1000),
                sectionData;

            // process sections that can expire due to lifetime constraints
            _.each(this.options.expirableSectionNames, function (sectionName) {
                sectionData = storage.get(sectionName);

                if (sectionData && sectionData.data_id + sectionLifetime <= currentTimestamp) {
                    expiredSectionNames.push(sectionName);
                }
            });

            // process sections that can expire due to storage information inconsistency
            _.each(cookieSectionTimestamps, function (cookieSectionTimestamp, sectionName) {
                sectionData = storage.get(sectionName);

                if (!sectionData || sectionData.data_id != cookieSectionTimestamp) { //eslint-disable-line
                    expiredSectionNames.push(sectionName);
                }
            });

            // remove expired section names of previously installed/enable modules
            expiredSectionNames = _.intersection(expiredSectionNames, $.sections.getSectionNames());

            return _.uniq(expiredSectionNames);
        },

        /**
         * @param {Array} sections
         * @param {Boolean} forceNewSectionTimestamp
         */
        reload: function (sections, forceNewSectionTimestamp) {
            var params = {};

            if (!this.options) {
                return this.invalidate(sections);
            }

            sections = sections || [];

            if (sections.length) {
                params.sections = sections.join(',');
            }

            if (forceNewSectionTimestamp) {
                params.force_new_section_timestamp = true;
            }

            $.request.get({
                url: this.options.sectionLoadUrl,
                data: params,
                accept: 'json',

                /** Success callback */
                success: function (data) {
                    var sectionDataIds = $.cookies.getJson('section_data_ids') || {};

                    $.each(data, function (sectionName, sectionData) {
                        // No need to store messages, but data_id must be
                        // in storage otherwise it will expire.
                        if (sectionName === 'messages') {
                            sectionData = {
                                data_id: sectionData.data_id,
                                messages: []
                            };
                        }

                        sectionDataIds[sectionName] = sectionData.data_id;
                        storage.set(sectionName, sectionData);
                        storageInvalidation.remove(sectionName);
                        $.sections.set(sectionName, sectionData);
                    });

                    $(document).trigger('customer-data-reload', {
                        sections: sections,
                        response: data
                    });

                    $.cookies.setJson('section_data_ids', sectionDataIds, {
                        domain: false
                    });
                }
            });
        },

        /**
         * @param {Array} sections
         */
        invalidate: function (sections) {
            var sectionDataIds = $.cookies.getJson('section_data_ids') || {};

            sections = _.contains(sections, '*') ?
                $.sections.getSectionNames() : sections;

            $(document).trigger('customer-data-invalidate', {
                sections: sections
            });

            storage.remove(sections);

            // Invalidate section in cookie (increase version of section with 1000)
            $(sections)
                .filter(function () {
                    return !$.sections.isClientSideSection(this);
                })
                .each(function () {
                    sectionDataIds[this] += 1000;
                    storageInvalidation.set(this, true);
                });

            $.cookies.setJson('section_data_ids', sectionDataIds, {
                domain: false
            });
        }
    };

    $(document).on('customerData:reload', function (event, data) {
        customerData.reload(data.sections, data.forceNewSectionTimestamp);
    });

    $(document).on('customerData:invalidate', function (event, data) {
        customerData.invalidate(data.sections);
    });

    $(document).on('breeze:load', function () {
        customerData.initialize(window.customerDataConfig);
        window.customerDataCmp = customerData;
    });
})();

(function () {
    'use strict';

    $.view('customer', {
        component: 'Magento_Customer/js/view/customer',
        customer: $.sections.get('customer')
    });
})();

(function () {
    'use strict';

    $.widget('formKey', {
        options: {
            inputSelector: 'input[name="form_key"]'
        },

        /** Fill input with valid form key */
        _create: function () {
            $(this.options.inputSelector).val($.cookies.get('form_key'));
        }
    });

    /**
     * Generate form key string
     * @private
     */
    function generateFormKeyString() {
        var result = '',
            length = 16,
            chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

        while (length--) {
            result += chars[Math.round(Math.random() * (chars.length - 1))];
        }

        return result;
    }

    /**
     * Init form_key inputs with value
     * @private
     */
    function initFormKey() {
        var formKey = $.cookies.get('form_key');

        if (!formKey) {
            formKey = generateFormKeyString();
            $.cookies.set('form_key', formKey, {
                expires: 1
            });
        }

        $('input[name="form_key"]').val(formKey);
    }

    // $(document).on('breeze:mount:Magento_PageCache/js/form-key-provider', function () {
    //     initFormKey();
    // });

    $(document).on('breeze:load contentUpdated', function () {
        initFormKey();
    });
})();

</script>

</body>
</html>
