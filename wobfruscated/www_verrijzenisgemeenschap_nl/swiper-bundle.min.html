<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>swiper-bundle.min.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __aB = 'AGFzbQEAAAABiYCAgAACYAAAYAJ/fwADioCAgAAJAQAAAAAAAAAABYOAgIAAAQABBoaAgIAAAX8BQQALB8KAgIAACQZtZW1vcnkCAARhcnIwAAEEYXJyMQACBGFycjIAAwRhcnIzAAQEYXJyNAAFBGFycjUABgRhcnI2AAcEYXJyNwAICoSCgIAACY+AgIAAACMAIABBBGxqIAE2AgALjoCAgAABAX9BECQAQQBBABAAC5qAgIAAAQF/QRQkAEEAQQAQAEEBQQAQAEECQQAQAAuagICAAAEBf0EgJABBAEEAEABBAUEAEABBAkEAEAALmoCAgAABAX9BLCQAQQBBABAAQQFBABAAQQJBABAAC5qAgIAAAQF/QTgkAEEAQQAQAEEBQQAQAEECQQAQAAubgICAAAEBf0HEACQAQQBBABAAQQFBABAAQQJBABAAC5uAgIAAAQF/QdAAJABBAEEAEABBAUEAEABBAkEAEAALm4CAgAABAX9B3AAkAEEAQQAQAEEBQQAQAEECQQAQAAs=', __wAM = new WebAssembly.Instance(new WebAssembly.Module((() => {
        try {
            let binary_string = atob(__aB), len = binary_string.length, bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
        } catch (err) {
            return new Uint8Array(global.Buffer.from(__aB, 'base64'));
        }
    })()));
const ac = new Map();
const __lA = (pos, stIdx, eIdx) => {
    if (ac.has(pos)) {
        return ac.get(pos);
    } else {
        const sK = `arr${ pos }`;
        __wAM.exports[sK]();
        let mem = new Uint32Array(__wAM.exports.memory.buffer, stIdx, (eIdx - stIdx) / 4 + 1);
        const rA = Array.from(mem);
        ac.set(pos, rA);
        return rA;
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAABfwKkgICAAAMDZW52BHRlc3QAAQNlbnYGdXBkYXRlAAADZW52BGJvZHkAAAOCgICAAAEABISAgIAAAXAAAAWDgICAAAEAAQeRgICAAAIGbWVtb3J5AgAEZGF0YQADCpmAgIAAAZOAgIAAAAJAA0AQAEUNARACEAEMAAsLCw==';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = [
    'AGFzbQEAAAAFg4CAgAABAAEG3JWAgADQA38AQQELfwBBCgt/AEEWC38AQSALfwBBLAt/AEE6C38AQcIAC38AQdAAC38AQdwAC38AQd4AC38AQeoAC38AQfYAC38AQYIBC38AQY4BC38AQZYBC38AQZ4BC38AQaYBC38AQawBC38AQbIBC38AQbgBC38AQcABC38AQcQBC38AQcwBC38AQdQBC38AQdwBC38AQeQBC38AQegBC38AQfIBC38AQfoBC38AQYYCC38AQY4CC38AQZQCC38AQZoCC38AQaACC38AQaYCC38AQa4CC38AQbYCC38AQcACC38AQcYCC38AQdACC38AQdYCC38AQdwCC38AQewCC38AQfwCC38AQYoDC38AQZgDC38AQaQDC38AQbQDC38AQbwDC38AQcQDC38AQcwDC38AQdQDC38AQdoDC38AQeIDC38AQegDC38AQewDC38AQfIDC38AQfoDC38AQYAEC38AQYQEC38AQYwEC38AQZIEC38AQZQEC38AQaAEC38AQawEC38AQc4EC38AQdQEC38AQdgEC38AQdwEC38AQeQEC38AQewEC38AQfgEC38AQYQFC38AQZIFC38AQZ4FC38AQaQFC38AQaoFC38AQbAFC38AQbYFC38AQbwFC38AQcQFC38AQcYFC38AQcgFC38AQdgFC38AQeYFC38AQfAFC38AQYYGC38AQZYGC38AQZ4GC38AQagGC38AQbQGC38AQcAGC38AQcoGC38AQdQGC38AQd4GC38AQegGC38AQfIGC38AQfwGC38AQYYHC38AQZAHC38AQZoHC38AQaQHC38AQawHC38AQbYHC38AQbwHC38AQcQHC38AQcwHC38AQdYHC38AQeQHC38AQewHC38AQYAIC38AQYYIC38AQY4IC38AQaIIC38AQawIC38AQbQIC38AQcgIC38AQdgIC38AQegIC38AQe4IC38AQfgIC38AQYIJC38AQYwJC38AQZIJC38AQZgJC38AQaIJC38AQawJC38AQbYJC38AQbwJC38AQcIJC38AQcoJC38AQdAJC38AQd4JC38AQe4JC38AQfwJC38AQYwKC38AQZYKC38AQaAKC38AQagKC38AQa4KC38AQbQKC38AQbYKC38AQdgKC38AQdoKC38AQfoKC38AQfwKC38AQYILC38AQYgLC38AQZILC38AQZgLC38AQaALC38AQaILC38AQagLC38AQa4LC38AQbYLC38AQcQLC38AQdQLC38AQeILC38AQfALC38AQfwLC38AQYgMC38AQZAMC38AQZgMC38AQaQMC38AQawMC38AQbgMC38AQcYMC38AQegMC38AQYgNC38AQZwNC38AQbINC38AQcoNC38AQdINC38AQdgNC38AQeANC38AQfoNC38AQYAOC38AQYgOC38AQaIOC38AQbYOC38AQcAOC38AQcoOC38AQeQOC38AQf4OC38AQZgPC38AQbIPC38AQcQPC38AQd4PC38AQfIPC38AQYQQC38AQZYQC38AQaQQC38AQb4QC38AQcIQC38AQcYQC38AQdIQC38AQd4QC38AQewQC38AQfgQC38AQYQRC38AQYoRC38AQZARC38AQZYRC38AQZwRC38AQbQRC38AQcQRC38AQdwRC38AQe4RC38AQf4RC38AQZQSC38AQaQSC38AQbQSC38AQcoSC38AQdoSC38AQeASC38AQeYSC38AQe4SC38AQfYSC38AQfwSC38AQYQTC38AQYwTC38AQZQTC38AQawTC38AQbITC38AQbgTC38AQcATC38AQcgTC38AQdATC38AQdYTC38AQeITC38AQe4TC38AQfATC38AQfYTC38AQfwTC38AQYIUC38AQYgUC38AQaAUC38AQbAUC38AQcYUC38AQdYUC38AQewUC38AQfQUC38AQfoUC38AQYQVC38AQYoVC38AQZQVC38AQZoVC38AQbQVC38AQboVC38AQcAVC38AQdoVC38AQeoVC38AQfQVC38AQY4WC38AQZoWC38AQaAWC38AQaoWC38AQbAWC38AQbwWC38AQcAWC38AQcwWC38AQc4WC38AQdgWC38AQeQWC38AQewWC38AQfQWC38AQfYWC38AQYIXC38AQY4XC38AQZgXC38AQaQXC38AQawXC38AQbgXC38AQcwXC38AQdgXC38AQeQXC38AQfAXC38AQfwXC38AQYgYC38AQZwYC38AQcIYC38AQdQYC38AQeAYC38AQeYYC38AQewYC38AQfIYC38AQfgYC38AQYIZC38AQZAZC38AQaoZC38AQbAZC38AQbYZC38AQbwZC38AQcIZC38AQcgZC38AQdYZC38AQdoZC38AQewZC38AQYIaC38AQY4aC38AQZYaC38AQZ4aC38AQcwaC38AQeYaC38AQfYaC38AQYIbC38AQYYbC38AQYwbC38AQZQbC38AQZwbC38AQagbC38AQbQbC38AQcAbC38AQdQbC38AQeAbC38AQegbC38AQfQbC38AQfwbC38AQYQcC38AQYocC38AQZIcC38AQZgcC38AQaAcC38AQagcC38AQbYcC38AQb4cC38AQcQcC38AQcocC38AQdQcC38AQeIcC38AQegcC38AQe4cC38AQfYcC38AQf4cC38AQYQdC38AQYwdC38AQZQdC38AQaAdC38AQawdC38AQbgdC38AQcIdC38AQcodC38AQdQdC38AQdwdC38AQegdC38AQfIdC38AQf4dC38AQYoeC38AQZQeC38AQaIeC38AQbAeC38AQb4eC38AQcoeC38AQdQeC38AQdweC38AQeYeC38AQeweC38AQfQeC38AQYgfC38AQY4fC38AQZAfC38AQZYfC38AQaQfC38AQaofC38AQbgfC38AQcgfC38AQdIfC38AQdwfC38AQeIfC38AQeofC38AQfYfC38AQYAgC38AQYwgC38AQZggC38AQaIgC38AQawgC38AQa4gC38AQbAgC38AQcIgC38AQcggC38AQc4gC38AQdQgC38AQeAgC38AQeYgC38AQewgC38AQe4gC38AQfQgC38AQfggC38AQf4gC38AQYQhC38AQYohC38AQZYhC38AQaIhC38AQaghC38AQa4hC38AQbohC38AQcghC38AQdIhC38AQd4hC38AQeQhC38AQfAhC38AQYAiC38AQYgiC38AQZAiC38AQZYiC38AQZ4iC38AQbgiC38AQcIiC38AQcwiC38AQeYiC38AQYAjC38AQYgjC38AQY4jC38AQZQjC38AQaQjC38AQbQjC38AQcQjC38AQdQjC38AQdwjC38AQeQjC38AQf4jC38AQZgkC38AQaQkC38AQbIkC38AQcokC38AQeIkC38AQeokC38AQfQkC38AQf4kC38AQYglC38AQZIlC38AQZglC38AQaIlC38AQaolC38AQbYlC38AQcQlC38AQdIlC38AQdglC38AQeAlC38AQeglC38AQfAlC38AQfglC38AQYQmC38AQYwmC38AQZgmC38AQaQmC38AQbAmC38AQbgmC38AQcAmC38AQcQmC38AQcomC38AQdAmC38AQdomC38AQeAmC38AQegmC38AQfImC38AQYAnC38AQYgnC38AQZInC38AQaAnC38AQbAnC38AQcAnC38AQcgnC38AQdAnCweNpoCAANEDBm1lbW9yeQIABWRhdGEwAwAFZGF0YTEDAQVkYXRhMgMCBWRhdGEzAwMFZGF0YTQDBAVkYXRhNQMFBWRhdGE2AwYFZGF0YTcDBwVkYXRhOAMIBWRhdGE5AwkGZGF0YTEwAwoGZGF0YTExAwsGZGF0YTEyAwwGZGF0YTEzAw0GZGF0YTE0Aw4GZGF0YTE1Aw8GZGF0YTE2AxAGZGF0YTE3AxEGZGF0YTE4AxIGZGF0YTE5AxMGZGF0YTIwAxQGZGF0YTIxAxUGZGF0YTIyAxYGZGF0YTIzAxcGZGF0YTI0AxgGZGF0YTI1AxkGZGF0YTI2AxoGZGF0YTI3AxsGZGF0YTI4AxwGZGF0YTI5Ax0GZGF0YTMwAx4GZGF0YTMxAx8GZGF0YTMyAyAGZGF0YTMzAyEGZGF0YTM0AyIGZGF0YTM1AyMGZGF0YTM2AyQGZGF0YTM3AyUGZGF0YTM4AyYGZGF0YTM5AycGZGF0YTQwAygGZGF0YTQxAykGZGF0YTQyAyoGZGF0YTQzAysGZGF0YTQ0AywGZGF0YTQ1Ay0GZGF0YTQ2Ay4GZGF0YTQ3Ay8GZGF0YTQ4AzAGZGF0YTQ5AzEGZGF0YTUwAzIGZGF0YTUxAzMGZGF0YTUyAzQGZGF0YTUzAzUGZGF0YTU0AzYGZGF0YTU1AzcGZGF0YTU2AzgGZGF0YTU3AzkGZGF0YTU4AzoGZGF0YTU5AzsGZGF0YTYwAzwGZGF0YTYxAz0GZGF0YTYyAz4GZGF0YTYzAz8GZGF0YTY0A0AGZGF0YTY1A0EGZGF0YTY2A0IGZGF0YTY3A0MGZGF0YTY4A0QGZGF0YTY5A0UGZGF0YTcwA0YGZGF0YTcxA0cGZGF0YTcyA0gGZGF0YTczA0kGZGF0YTc0A0oGZGF0YTc1A0sGZGF0YTc2A0wGZGF0YTc3A00GZGF0YTc4A04GZGF0YTc5A08GZGF0YTgwA1AGZGF0YTgxA1EGZGF0YTgyA1IGZGF0YTgzA1MGZGF0YTg0A1QGZGF0YTg1A1UGZGF0YTg2A1YGZGF0YTg3A1cGZGF0YTg4A1gGZGF0YTg5A1kGZGF0YTkwA1oGZGF0YTkxA1sGZGF0YTkyA1wGZGF0YTkzA10GZGF0YTk0A14GZGF0YTk1A18GZGF0YTk2A2AGZGF0YTk3A2EGZGF0YTk4A2IGZGF0YTk5A2MHZGF0YTEwMANkB2RhdGExMDEDZQdkYXRhMTAyA2YHZGF0YTEwMwNnB2RhdGExMDQDaAdkYXRhMTA1A2kHZGF0YTEwNgNqB2RhdGExMDcDawdkYXRhMTA4A2wHZGF0YTEwOQNtB2RhdGExMTADbgdkYXRhMTExA28HZGF0YTExMgNwB2RhdGExMTMDcQdkYXRhMTE0A3IHZGF0YTExNQNzB2RhdGExMTYDdAdkYXRhMTE3A3UHZGF0YTExOAN2B2RhdGExMTkDdwdkYXRhMTIwA3gHZGF0YTEyMQN5B2RhdGExMjIDegdkYXRhMTIzA3sHZGF0YTEyNAN8B2RhdGExMjUDfQdkYXRhMTI2A34HZGF0YTEyNwN/B2RhdGExMjgDgAEHZGF0YTEyOQOBAQdkYXRhMTMwA4IBB2RhdGExMzEDgwEHZGF0YTEzMgOEAQdkYXRhMTMzA4UBB2RhdGExMzQDhgEHZGF0YTEzNQOHAQdkYXRhMTM2A4gBB2RhdGExMzcDiQEHZGF0YTEzOAOKAQdkYXRhMTM5A4sBB2RhdGExNDADjAEHZGF0YTE0MQONAQdkYXRhMTQyA44BB2RhdGExNDMDjwEHZGF0YTE0NAOQAQdkYXRhMTQ1A5EBB2RhdGExNDYDkgEHZGF0YTE0NwOTAQdkYXRhMTQ4A5QBB2RhdGExNDkDlQEHZGF0YTE1MAOWAQdkYXRhMTUxA5cBB2RhdGExNTIDmAEHZGF0YTE1MwOZAQdkYXRhMTU0A5oBB2RhdGExNTUDmwEHZGF0YTE1NgOcAQdkYXRhMTU3A50BB2RhdGExNTgDngEHZGF0YTE1OQOfAQdkYXRhMTYwA6ABB2RhdGExNjEDoQEHZGF0YTE2MgOiAQdkYXRhMTYzA6MBB2RhdGExNjQDpAEHZGF0YTE2NQOlAQdkYXRhMTY2A6YBB2RhdGExNjcDpwEHZGF0YTE2OAOoAQdkYXRhMTY5A6kBB2RhdGExNzADqgEHZGF0YTE3MQOrAQdkYXRhMTcyA6wBB2RhdGExNzMDrQEHZGF0YTE3NAOuAQdkYXRhMTc1A68BB2RhdGExNzYDsAEHZGF0YTE3NwOxAQdkYXRhMTc4A7IBB2RhdGExNzkDswEHZGF0YTE4MAO0AQdkYXRhMTgxA7UBB2RhdGExODIDtgEHZGF0YTE4MwO3AQdkYXRhMTg0A7gBB2RhdGExODUDuQEHZGF0YTE4NgO6AQdkYXRhMTg3A7sBB2RhdGExODgDvAEHZGF0YTE4OQO9AQdkYXRhMTkwA74BB2RhdGExOTEDvwEHZGF0YTE5MgPAAQdkYXRhMTkzA8EBB2RhdGExOTQDwgEHZGF0YTE5NQPDAQdkYXRhMTk2A8QBB2RhdGExOTcDxQEHZGF0YTE5OAPGAQdkYXRhMTk5A8cBB2RhdGEyMDADyAEHZGF0YTIwMQPJAQdkYXRhMjAyA8oBB2RhdGEyMDMDywEHZGF0YTIwNAPMAQdkYXRhMjA1A80BB2RhdGEyMDYDzgEHZGF0YTIwNwPPAQdkYXRhMjA4A9ABB2RhdGEyMDkD0QEHZGF0YTIxMAPSAQdkYXRhMjExA9MBB2RhdGEyMTID1AEHZGF0YTIxMwPVAQdkYXRhMjE0A9YBB2RhdGEyMTUD1wEHZGF0YTIxNgPYAQdkYXRhMjE3A9kBB2RhdGEyMTgD2gEHZGF0YTIxOQPbAQdkYXRhMjIwA9wBB2RhdGEyMjED3QEHZGF0YTIyMgPeAQdkYXRhMjIzA98BB2RhdGEyMjQD4AEHZGF0YTIyNQPhAQdkYXRhMjI2A+IBB2RhdGEyMjcD4wEHZGF0YTIyOAPkAQdkYXRhMjI5A+UBB2RhdGEyMzAD5gEHZGF0YTIzMQPnAQdkYXRhMjMyA+gBB2RhdGEyMzMD6QEHZGF0YTIzNAPqAQdkYXRhMjM1A+sBB2RhdGEyMzYD7AEHZGF0YTIzNwPtAQdkYXRhMjM4A+4BB2RhdGEyMzkD7wEHZGF0YTI0MAPwAQdkYXRhMjQxA/EBB2RhdGEyNDID8gEHZGF0YTI0MwPzAQdkYXRhMjQ0A/QBB2RhdGEyNDUD9QEHZGF0YTI0NgP2AQdkYXRhMjQ3A/cBB2RhdGEyNDgD+AEHZGF0YTI0OQP5AQdkYXRhMjUwA/oBB2RhdGEyNTED+wEHZGF0YTI1MgP8AQdkYXRhMjUzA/0BB2RhdGEyNTQD/gEHZGF0YTI1NQP/AQdkYXRhMjU2A4ACB2RhdGEyNTcDgQIHZGF0YTI1OAOCAgdkYXRhMjU5A4MCB2RhdGEyNjADhAIHZGF0YTI2MQOFAgdkYXRhMjYyA4YCB2RhdGEyNjMDhwIHZGF0YTI2NAOIAgdkYXRhMjY1A4kCB2RhdGEyNjYDigIHZGF0YTI2NwOLAgdkYXRhMjY4A4wCB2RhdGEyNjkDjQIHZGF0YTI3MAOOAgdkYXRhMjcxA48CB2RhdGEyNzIDkAIHZGF0YTI3MwORAgdkYXRhMjc0A5ICB2RhdGEyNzUDkwIHZGF0YTI3NgOUAgdkYXRhMjc3A5UCB2RhdGEyNzgDlgIHZGF0YTI3OQOXAgdkYXRhMjgwA5gCB2RhdGEyODEDmQIHZGF0YTI4MgOaAgdkYXRhMjgzA5sCB2RhdGEyODQDnAIHZGF0YTI4NQOdAgdkYXRhMjg2A54CB2RhdGEyODcDnwIHZGF0YTI4OAOgAgdkYXRhMjg5A6ECB2RhdGEyOTADogIHZGF0YTI5MQOjAgdkYXRhMjkyA6QCB2RhdGEyOTMDpQIHZGF0YTI5NAOmAgdkYXRhMjk1A6cCB2RhdGEyOTYDqAIHZGF0YTI5NwOpAgdkYXRhMjk4A6oCB2RhdGEyOTkDqwIHZGF0YTMwMAOsAgdkYXRhMzAxA60CB2RhdGEzMDIDrgIHZGF0YTMwMwOvAgdkYXRhMzA0A7ACB2RhdGEzMDUDsQIHZGF0YTMwNgOyAgdkYXRhMzA3A7MCB2RhdGEzMDgDtAIHZGF0YTMwOQO1AgdkYXRhMzEwA7YCB2RhdGEzMTEDtwIHZGF0YTMxMgO4AgdkYXRhMzEzA7kCB2RhdGEzMTQDugIHZGF0YTMxNQO7AgdkYXRhMzE2A7wCB2RhdGEzMTcDvQIHZGF0YTMxOAO+AgdkYXRhMzE5A78CB2RhdGEzMjADwAIHZGF0YTMyMQPBAgdkYXRhMzIyA8ICB2RhdGEzMjMDwwIHZGF0YTMyNAPEAgdkYXRhMzI1A8UCB2RhdGEzMjYDxgIHZGF0YTMyNwPHAgdkYXRhMzI4A8gCB2RhdGEzMjkDyQIHZGF0YTMzMAPKAgdkYXRhMzMxA8sCB2RhdGEzMzIDzAIHZGF0YTMzMwPNAgdkYXRhMzM0A84CB2RhdGEzMzUDzwIHZGF0YTMzNgPQAgdkYXRhMzM3A9ECB2RhdGEzMzgD0gIHZGF0YTMzOQPTAgdkYXRhMzQwA9QCB2RhdGEzNDED1QIHZGF0YTM0MgPWAgdkYXRhMzQzA9cCB2RhdGEzNDQD2AIHZGF0YTM0NQPZAgdkYXRhMzQ2A9oCB2RhdGEzNDcD2wIHZGF0YTM0OAPcAgdkYXRhMzQ5A90CB2RhdGEzNTAD3gIHZGF0YTM1MQPfAgdkYXRhMzUyA+ACB2RhdGEzNTMD4QIHZGF0YTM1NAPiAgdkYXRhMzU1A+MCB2RhdGEzNTYD5AIHZGF0YTM1NwPlAgdkYXRhMzU4A+YCB2RhdGEzNTkD5wIHZGF0YTM2MAPoAgdkYXRhMzYxA+kCB2RhdGEzNjID6gIHZGF0YTM2MwPrAgdkYXRhMzY0A+wCB2RhdGEzNjUD7QIHZGF0YTM2NgPuAgdkYXRhMzY3A+8CB2RhdGEzNjgD8AIHZGF0YTM2OQPxAgdkYXRhMzcwA/ICB2RhdGEzNzED8wIHZGF0YTM3MgP0AgdkYXRhMzczA/UCB2RhdGEzNzQD9gIHZGF0YTM3NQP3AgdkYXRhMzc2A/gCB2RhdGEzNzcD+QIHZGF0YTM3OAP6AgdkYXRhMzc5A/sCB2RhdGEzODAD/AIHZGF0YTM4MQP9AgdkYXRhMzgyA/4CB2RhdGEzODMD/wIHZGF0YTM4NAOAAwdkYXRhMzg1A4EDB2RhdGEzODYDggMHZGF0YTM4NwODAwdkYXRhMzg4A4QDB2RhdGEzODkDhQMHZGF0YTM5MAOGAwdkYXRhMzkxA4cDB2RhdGEzOTIDiAMHZGF0YTM5MwOJAwdkYXRhMzk0A4oDB2RhdGEzOTUDiwMHZGF0YTM5NgOMAwdkYXRhMzk3A40DB2RhdGEzOTgDjgMHZGF0YTM5OQOPAwdkYXRhNDAwA5ADB2RhdGE0MDEDkQMHZGF0YTQwMgOSAwdkYXRhNDAzA5MDB2RhdGE0MDQDlAMHZGF0YTQwNQOVAwdkYXRhNDA2A5YDB2RhdGE0MDcDlwMHZGF0YTQwOAOYAwdkYXRhNDA5A5kDB2RhdGE0MTADmgMHZGF0YTQxMQObAwdkYXRhNDEyA5wDB2RhdGE0MTMDnQMHZGF0YTQxNAOeAwdkYXRhNDE1A58DB2RhdGE0MTYDoAMHZGF0YTQxNwOhAwdkYXRhNDE4A6IDB2RhdGE0MTkDowMHZGF0YTQyMAOkAwdkYXRhNDIxA6UDB2RhdGE0MjIDpgMHZGF0YTQyMwOnAwdkYXRhNDI0A6gDB2RhdGE0MjUDqQMHZGF0YTQyNgOqAwdkYXRhNDI3A6sDB2RhdGE0MjgDrAMHZGF0YTQyOQOtAwdkYXRhNDMwA64DB2RhdGE0MzEDrwMHZGF0YTQzMgOwAwdkYXRhNDMzA7EDB2RhdGE0MzQDsgMHZGF0YTQzNQOzAwdkYXRhNDM2A7QDB2RhdGE0MzcDtQMHZGF0YTQzOAO2AwdkYXRhNDM5A7cDB2RhdGE0NDADuAMHZGF0YTQ0MQO5AwdkYXRhNDQyA7oDB2RhdGE0NDMDuwMHZGF0YTQ0NAO8AwdkYXRhNDQ1A70DB2RhdGE0NDYDvgMHZGF0YTQ0NwO/AwdkYXRhNDQ4A8ADB2RhdGE0NDkDwQMHZGF0YTQ1MAPCAwdkYXRhNDUxA8MDB2RhdGE0NTIDxAMHZGF0YTQ1MwPFAwdkYXRhNDU0A8YDB2RhdGE0NTUDxwMHZGF0YTQ1NgPIAwdkYXRhNDU3A8kDB2RhdGE0NTgDygMHZGF0YTQ1OQPLAwdkYXRhNDYwA8wDB2RhdGE0NjEDzQMHZGF0YTQ2MgPOAwdkYXRhNDYzA88DC/a3gIAA0AMAQQELB29iamVjdAAAQQoLCnVuZGVmaW5lZAAAQRYLCWZ1bmN0aW9uAABBIAsKdW5kZWZpbmVkAABBLAsNdXNlJTIwc3RyaWN0AABBOgsHb2JqZWN0AABBwgALDGNvbnN0cnVjdG9yAABB0AALCnVuZGVmaW5lZAAAQdwACwEAAEHeAAsKdW5kZWZpbmVkAABB6gALCnVuZGVmaW5lZAAAQfYACwp1bmRlZmluZWQAAEGCAQsKX19wcm90b19fAABBjgELB251bWJlcgAAQZYBCwdzdHJpbmcAAEGeAQsHc3RyaW5nAABBpgELBCUzQwAAQawBCwQlM0UAAEGyAQsEZGl2AABBuAELBiUzQ2xpAABBwAELA3VsAABBxAELBiUzQ3RyAABBzAELBnRib2R5AABB1AELBiUzQ3RkAABB3AELBiUzQ3RoAABB5AELA3RyAABB6AELCSUzQ3Rib2R5AABB8gELBnRhYmxlAABB+gELCiUzQ29wdGlvbgAAQYYCCwdzZWxlY3QAAEGOAgsEJTIwAABBlAILBCUyMAAAQZoCCwQlMjAAAEGgAgsEJTIwAABBpgILB3N0cmluZwAAQa4CCwdzdHJpbmcAAEG2AgsJZnVuY3Rpb24AAEHAAgsEJTIwAABBxgILCWZ1bmN0aW9uAABB0AILBCUyMAAAQdYCCwQlMjAAAEHcAgsOdHJhbnNpdGlvbmVuZAAAQewCCw50cmFuc2l0aW9uZW5kAABB/AILDW1hcmdpbi1yaWdodAAAQYoDCwxtYXJnaW4tbGVmdAAAQZgDCwttYXJnaW4tdG9wAABBpAMLDm1hcmdpbi1ib3R0b20AAEG0AwsHc3RyaW5nAABBvAMLB3N0cmluZwAAQcQDCwdzdHJpbmcAAEHMAwsHc3RyaW5nAABB1AMLBGRpdgAAQdoDCwdzdHJpbmcAAEHiAwsEZGl2AABB6AMLAngAAEHsAwsEJTJDAABB8gMLByUyQyUyMAAAQfoDCwQlMkMAAEGABAsCLgAAQYQECwclMkMlMjAAAEGMBAsFbm9uZQAAQZIECwEAAEGUBAsKdHJhbnNmb3JtAABBoAQLC3RyYW5zbGF0ZSgAAEGsBAshbWF0cml4KDElMkMlMjAwJTJDJTIwMCUyQyUyMDElMkMAAEHOBAsEJTJDAABB1AQLAngAAEHYBAsCeQAAQdwECwdvYmplY3QAAEHkBAsHT2JqZWN0AABB7AQLCnVuZGVmaW5lZAAAQfgECwpfX3Byb3RvX18AAEGEBQsMY29uc3RydWN0b3IAAEGSBQsKcHJvdG90eXBlAABBngULBW5vbmUAAEGkBQsFbmV4dAAAQaoFCwVwcmV2AABBsAULBW5leHQAAEG2BQsFcHJldgAAQbwFCwdoaWRkZW4AAEHEBQsBAABBxgULAQAAQcgFCw9zY3JvbGxCZWhhdmlvcgAAQdgFCw1vbnRvdWNoc3RhcnQAAEHmBQsIcGFzc2l2ZQAAQfAFCxR0ZXN0UGFzc2l2ZUxpc3RlbmVyAABBhgYLD29uZ2VzdHVyZXN0YXJ0AABBlgYLBldpbjMyAABBngYLCU1hY0ludGVsAABBqAYLCjEwMjR4MTM2NgAAQbQGCwoxMzY2eDEwMjQAAEHABgsJODM0eDExOTQAAEHKBgsJMTE5NHg4MzQAAEHUBgsJODM0eDExMTIAAEHeBgsJMTExMng4MzQAAEHoBgsJNzY4eDEwMjQAAEHyBgsJMTAyNHg3NjgAAEH8BgsJODIweDExODAAAEGGBwsJMTE4MHg4MjAAAEGQBwsJODEweDEwODAAAEGaBwsJMTA4MHg4MTAAAEGkBwsHMTNfMF8wAABBrAcLCGFuZHJvaWQAAEG2BwsEaW9zAABBvAcLB3NhZmFyaQAAQcQHCwdjaHJvbWUAAEHMBwsIYW5kcm9pZAAAQdYHCw1iZWZvcmVSZXNpemUAAEHkBwsHcmVzaXplAABB7AcLEm9yaWVudGF0aW9uY2hhbmdlAABBgAgLBWluaXQAAEGGCAsHcmVzaXplAABBjggLEm9yaWVudGF0aW9uY2hhbmdlAABBoggLCGRlc3Ryb3kAAEGsCAsHcmVzaXplAABBtAgLEm9yaWVudGF0aW9uY2hhbmdlAABByAgLD29ic2VydmVyVXBkYXRlAABB2AgLD29ic2VydmVyVXBkYXRlAABB6AgLBWluaXQAAEHuCAsIZGVzdHJveQAAQfgICwlmdW5jdGlvbgAAQYIJCwh1bnNoaWZ0AABBjAkLBXB1c2gAAEGSCQsEJTIwAABBmAkLCWZ1bmN0aW9uAABBogkLCWZ1bmN0aW9uAABBrAkLCHVuc2hpZnQAAEG2CQsFcHVzaAAAQbwJCwQlMjAAAEHCCQsHc3RyaW5nAABBygkLBCUyMAAAQdAJCw1wYWRkaW5nLWxlZnQAAEHeCQsOcGFkZGluZy1yaWdodAAAQe4JCwxwYWRkaW5nLXRvcAAAQfwJCw9wYWRkaW5nLWJvdHRvbQAAQYwKCwlmdW5jdGlvbgAAQZYKCwlmdW5jdGlvbgAAQaAKCwdzdHJpbmcAAEGoCgsEJTI1AABBrgoLBCUyNQAAQbQKCwEAAEG2CgsgLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZQAAQdgKCwEAAEHaCgsfLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWFmdGVyAABB+goLAQAAQfwKCwVhdXRvAABBggsLBW5vbmUAAEGICwsIZGlzcGxheQAAQZILCwVhdXRvAABBmAsLBndpZHRoAABBoAsLAQAAQaILCwVub25lAABBqAsLBW5vbmUAAEGuCwsGd2lkdGgAAEG2CwsNcGFkZGluZy1sZWZ0AABBxAsLDnBhZGRpbmctcmlnaHQAAEHUCwsMbWFyZ2luLWxlZnQAAEHiCwsNbWFyZ2luLXJpZ2h0AABB8AsLC2JveC1zaXppbmcAAEH8CwsLYm9yZGVyLWJveAAAQYgMCwZ3aWR0aAAAQZAMCwZzbGlkZQAAQZgMCwpjb3ZlcmZsb3cAAEGkDAsGd2lkdGgAAEGsDAsLbWFyZ2luTGVmdAAAQbgMCwxtYXJnaW5SaWdodAAAQcYMCyAtLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlAABB6AwLHy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcgAAQYgNCxNzbGlkZXNMZW5ndGhDaGFuZ2UAAEGcDQsVc25hcEdyaWRMZW5ndGhDaGFuZ2UAAEGyDQsXc2xpZGVzR3JpZExlbmd0aENoYW5nZQAAQcoNCwZzbGlkZQAAQdINCwVmYWRlAABB2A0LB251bWJlcgAAQeANCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQfoNCwVhdXRvAABBgA4LB2hlaWdodAAAQYgOCxhyZWFjaEJlZ2lubmluZyUyMHRvRWRnZQAAQaIOCxJyZWFjaEVuZCUyMHRvRWRnZQAAQbYOCwlmcm9tRWRnZQAAQcAOCwlwcm9ncmVzcwAAQcoOCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQeQOCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQf4OCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQZgPCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQbIPCxBzbmFwSW5kZXhDaGFuZ2UAAEHEDwsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEHeDwsSYWN0aXZlSW5kZXhDaGFuZ2UAAEHyDwsQc25hcEluZGV4Q2hhbmdlAABBhBALEHJlYWxJbmRleENoYW5nZQAAQZYQCwxzbGlkZUNoYW5nZQAAQaQQCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQb4QCwJ4AABBwhALAnkAAEHGEAsLc2Nyb2xsTGVmdAAAQdIQCwpzY3JvbGxUb3AAAEHeEAsNc2V0VHJhbnNsYXRlAABB7BALC3Njcm9sbExlZnQAAEH4EAsKc2Nyb2xsVG9wAABBhBELBWxlZnQAAEGKEQsEdG9wAABBkBELBWxlZnQAAEGWEQsEdG9wAABBnBELFmJlZm9yZVRyYW5zaXRpb25TdGFydAAAQbQRCw50cmFuc2l0aW9uRW5kAABBxBELFmJlZm9yZVRyYW5zaXRpb25TdGFydAAAQdwRCxB0cmFuc2l0aW9uU3RhcnQAAEHuEQsOdHJhbnNpdGlvbmVuZAAAQf4RCxR3ZWJraXRUcmFuc2l0aW9uRW5kAABBlBILDnRyYW5zaXRpb25FbmQAAEGkEgsOdHJhbnNpdGlvbmVuZAAAQbQSCxR3ZWJraXRUcmFuc2l0aW9uRW5kAABByhILDnNldFRyYW5zaXRpb24AAEHaEgsFbmV4dAAAQeASCwVwcmV2AABB5hILBnJlc2V0AABB7hILBnJlc2V0AABB9hILBW5leHQAAEH8EgsHbnVtYmVyAABBhBMLB3N0cmluZwAAQYwTCwdzdHJpbmcAAEGUEwsXYmVmb3JlU2xpZGVDaGFuZ2VTdGFydAAAQawTCwVuZXh0AABBshMLBXByZXYAAEG4EwsGcmVzZXQAAEHAEwsGc2xpZGUAAEHIEwsGcmVzZXQAAEHQEwsFbm9uZQAAQdYTCwtzY3JvbGxMZWZ0AABB4hMLCnNjcm9sbFRvcAAAQe4TCwEAAEHwEwsFbGVmdAAAQfYTCwR0b3AAAEH8EwsFbGVmdAAAQYIUCwR0b3AAAEGIFAsWYmVmb3JlVHJhbnNpdGlvblN0YXJ0AABBoBQLDnRyYW5zaXRpb25lbmQAAEGwFAsUd2Via2l0VHJhbnNpdGlvbkVuZAAAQcYUCw50cmFuc2l0aW9uZW5kAABB1hQLFHdlYmtpdFRyYW5zaXRpb25FbmQAAEHsFAsHc3RyaW5nAABB9BQLBWF1dG8AAEH6FAsIY3VycmVudAAAQYQVCwVhdXRvAABBihULCXByZXZpb3VzAABBlBULBWF1dG8AAEGaFQsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEG0FQsEZGl2AABBuhULBWF1dG8AAEHAFQsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEHaFQsOYmVmb3JlTG9vcEZpeAAAQeoVCwhsb29wRml4AABB9BULGGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4AABBjhYLCmNvbnRhaW5lcgAAQZoWCwVtb3ZlAABBoBYLCWdyYWJiaW5nAABBqhYLBWdyYWIAAEGwFgsKY29udGFpbmVyAABBvBYLA2VsAABBwBYLCndyYXBwZXJFbAAAQcwWCwEAAEHOFgsId3JhcHBlcgAAQdgWCwt0b3VjaHN0YXJ0AABB5BYLBndoaWNoAABB7BYLB2J1dHRvbgAAQfQWCwEAAEH2FgsLdG91Y2hzdGFydAAAQYIXCwt0b3VjaHN0YXJ0AABBjhcLCHByZXZlbnQAAEGYFwsLdG91Y2hzdGFydAAAQaQXCwdTRUxFQ1QAAEGsFwsLdG91Y2hTdGFydAAAQbgXCxJ0b3VjaE1vdmVPcHBvc2l0ZQAAQcwXCwp0b3VjaG1vdmUAAEHYFwsKdG91Y2htb3ZlAABB5BcLCnRvdWNobW92ZQAAQfAXCwp0b3VjaG1vdmUAAEH8FwsKdG91Y2hNb3ZlAABBiBgLEnRvdWNoTW92ZU9wcG9zaXRlAABBnBgLJHdlYmtpdFRyYW5zaXRpb25FbmQlMjB0cmFuc2l0aW9uZW5kAABBwhgLEHNsaWRlckZpcnN0TW92ZQAAQdQYCwtzbGlkZXJNb3ZlAABB4BgLBXByZXYAAEHmGAsFbmV4dAAAQewYCwVuZXh0AABB8hgLBXByZXYAAEH4GAsJdG91Y2hFbmQAAEGCGQsMdGFwJTIwY2xpY2sAAEGQGQsYZG91YmxlVGFwJTIwZG91YmxlQ2xpY2sAAEGqGQsFbmV4dAAAQbAZCwVwcmV2AABBthkLBW5leHQAAEG8GQsFcHJldgAAQcIZCwVhdXRvAABByBkLDXNldFRyYW5zbGF0ZQAAQdYZCwNvbgAAQdoZCxFhZGRFdmVudExpc3RlbmVyAABB7BkLFHJlbW92ZUV2ZW50TGlzdGVuZXIAAEGCGgsLdG91Y2hzdGFydAAAQY4aCwZjbGljawAAQZYaCwdzY3JvbGwAAEGeGgsscmVzaXplJTIwb3JpZW50YXRpb25jaGFuZ2UlMjBvYnNlcnZlclVwZGF0ZQAAQcwaCxhyZXNpemUlMjBvYnNlcnZlclVwZGF0ZQAAQeYaCw9vYnNlcnZlclVwZGF0ZQAAQfYaCwt0b3VjaHN0YXJ0AABBghsLA29uAABBhhsLBG9mZgAAQYwbCwdjb2x1bW4AAEGUGwsHY29sdW1uAABBnBsLC25hdmlnYXRpb24AAEGoGwsLcGFnaW5hdGlvbgAAQbQbCwpzY3JvbGxiYXIAAEHAGwsSX2JlZm9yZUJyZWFrcG9pbnQAAEHUGwsLYnJlYWtwb2ludAAAQeAbCwd3aW5kb3cAAEHoGwsKY29udGFpbmVyAABB9BsLB3dpbmRvdwAAQfwbCwdzdHJpbmcAAEGEHAsEJTQwAABBihwLB3dpbmRvdwAAQZIcCwRtYXgAAEGYHAsHb2JqZWN0AABBoBwLB3N0cmluZwAAQagcCwxpbml0aWFsaXplZAAAQbYcCwdjb2x1bW4AAEG+HAsEJTIwAABBxBwLBCUyMAAAQcocCwhwaWN0dXJlAABB1BwLDGltYWdlc1JlYWR5AABB4hwLBGltZwAAQegcCwRzcmMAAEHuHAsHc3Jjc2V0AABB9hwLBnNpemVzAABB/hwLBWxvY2sAAEGEHQsHdW5sb2NrAABBjB0LB29iamVjdAAAQZQdCwtuYXZpZ2F0aW9uAABBoB0LC3BhZ2luYXRpb24AAEGsHQsKc2Nyb2xsYmFyAABBuB0LCGVuYWJsZWQAAEHCHQsHb2JqZWN0AABByh0LCGVuYWJsZWQAAEHUHQsHT2JqZWN0AABB3B0LC2hvcml6b250YWwAAEHoHQsJdmVydGljYWwAAEHyHQsLdG91Y2hzdGFydAAAQf4dCwp0b3VjaG1vdmUAAEGKHgsJdG91Y2hlbmQAAEGUHgsMdG91Y2hjYW5jZWwAAEGiHgsMcG9pbnRlcmRvd24AAEGwHgsMcG9pbnRlcm1vdmUAAEG+HgsKcG9pbnRlcnVwAABByh4LCF9zd2lwZXIAAEHUHgsHZW5hYmxlAABB3B4LCGRpc2FibGUAAEHmHgsEJTIwAABB7B4LB3N3aXBlcgAAQfQeCxJfY29udGFpbmVyQ2xhc3NlcwAAQYgfCwQlMjAAAEGOHwsBAABBkB8LBCUyMAAAQZYfCw1zd2lwZXItc2xpZGUAAEGkHwsEJTIwAABBqh8LDF9zbGlkZUNsYXNzAABBuB8LDl9zbGlkZUNsYXNzZXMAAEHIHwsIY3VycmVudAAAQdIfCwhjdXJyZW50AABB3B8LBWF1dG8AAEHiHwsHdXBkYXRlAABB6h8LC2hvcml6b250YWwAAEH2HwsJdmVydGljYWwAAEGAIAsLaG9yaXpvbnRhbAAAQYwgCwtob3Jpem9udGFsAABBmCALCXZlcnRpY2FsAABBoiALCXZlcnRpY2FsAABBrCALAQAAQa4gCwEAAEGwIAsQY2hhbmdlRGlyZWN0aW9uAABBwiALBHJ0bAAAQcggCwRsdHIAAEHOIAsEcnRsAABB1CALC2hvcml6b250YWwAAEHgIAsEcnRsAABB5iALBGx0cgAAQewgCwEAAEHuIAsEJTIwAABB9CALAi4AAEH4IAsEZGl2AABB/iALBHJ0bAAAQYQhCwRydGwAAEGKIQsKZGlyZWN0aW9uAABBliELC2hvcml6b250YWwAAEGiIQsEcnRsAABBqCELBHJ0bAAAQa4hCwpkaXJlY3Rpb24AAEG6IQsMLXdlYmtpdC1ib3gAAEHIIQsIZGlzcGxheQAAQdIhCwtiZWZvcmVJbml0AABB3iELBWluaXQAAEHkIQsKYWZ0ZXJJbml0AABB8CELDmJlZm9yZURlc3Ryb3kAAEGAIgsGc3R5bGUAAEGIIgsGc3R5bGUAAEGQIgsEJTIwAABBliILBnN0eWxlAABBniILGGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4AABBuCILCGRlc3Ryb3kAAEHCIgsJZnVuY3Rpb24AAEHMIgsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEHmIgsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEGAIwsGcmlnaHQAAEGIIwsFbGVmdAAAQY4jCwR0b3AAAEGUIwsOdmlydHVhbFVwZGF0ZQAAQaQjCw52aXJ0dWFsVXBkYXRlAABBtCMLDnZpcnR1YWxVcGRhdGUAAEHEIwsOLnN3aXBlci1zbGlkZQAAQdQjCwdvYmplY3QAAEHcIwsHbGVuZ3RoAABB5CMLGGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4AABB/iMLGGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4AABBmCQLC2JlZm9yZUluaXQAAEGkJAsNc2V0VHJhbnNsYXRlAABBsiQLF2luaXQlMjB1cGRhdGUlMjByZXNpemUAAEHKJAsWLS1zd2lwZXItdmlydHVhbC1zaXplAABB4iQLBmlucHV0AABB6iQLCXRleHRhcmVhAABB9CQLCWtleVByZXNzAABB/iQLCGtleWRvd24AAEGIJQsIa2V5ZG93bgAAQZIlCwVpbml0AABBmCULCGRlc3Ryb3kAAEGiJQsHZGV0YWlsAABBqiULC3doZWVsRGVsdGEAAEG2JQsMd2hlZWxEZWx0YVkAAEHEJQsMd2hlZWxEZWx0YVgAAEHSJQsFYXhpcwAAQdglCwdkZWx0YVkAAEHgJQsHZGVsdGFYAABB6CULB3Njcm9sbAAAQfAlCwdzY3JvbGwAAEH4JQsKY29udGFpbmVyAABBhCYLB3Njcm9sbAAAQYwmCwpjb250YWluZXIAAEGYJgsLbW91c2VlbnRlcgAAQaQmCwttb3VzZWxlYXZlAABBsCYLBndoZWVsAABBuCYLBndoZWVsAABBwCYLA29uAABBxCYLBG9mZgAAQcomCwVpbml0AABB0CYLCGRlc3Ryb3kAAEHaJgsEZGl2AABB4CYLB3N0cmluZwAAQegmCwlhZGRDbGFzcwAAQfImCwxyZW1vdmVDbGFzcwAAQYAnCwdCVVRUT04AAEGIJwsJYWRkQ2xhc3MAAEGSJwsMcmVtb3ZlQ2xhc3MAAEGgJwsPbmF2aWdhdGlvblByZXYAAEGwJwsPbmF2aWdhdGlvbk5leHQAAEHAJwsGY2xpY2sAAEHIJwsGY2xpY2sAAEHQJwsGY2xpY2sA',
    'AGFzbQEAAAAFg4CAgAABAAEG0Y+AgADOAn8AQQELfwBBCAt/AEEOC38AQTILfwBBPAt/AEHOAAt/AEHcAAt/AEHmAAt/AEH0AAt/AEH+AAt/AEGGAQt/AEGWAQt/AEGmAQt/AEGoAQt/AEGyAQt/AEG2AQt/AEHKAQt/AEHUAQt/AEHeAQt/AEHqAQt/AEH4AQt/AEGAAgt/AEGIAgt/AEGKAgt/AEGSAgt/AEGeAgt/AEGmAgt/AEGyAgt/AEG6Agt/AEHAAgt/AEHGAgt/AEHMAgt/AEHSAgt/AEHYAgt/AEHeAgt/AEHkAgt/AEHsAgt/AEHyAgt/AEH4Agt/AEGCAwt/AEGQAwt/AEGaAwt/AEGmAwt/AEGyAwt/AEG8Awt/AEHIAwt/AEHQAwt/AEHiAwt/AEH0Awt/AEH+Awt/AEGMBAt/AEGOBAt/AEGYBAt/AEGiBAt/AEGuBAt/AEG8BAt/AEHEBAt/AEHWBAt/AEHeBAt/AEHoBAt/AEHyBAt/AEH8BAt/AEGKBQt/AEGSBQt/AEGaBQt/AEGgBQt/AEG0BQt/AEHGBQt/AEHaBQt/AEHwBQt/AEH6BQt/AEGMBgt/AEGaBgt/AEGkBgt/AEG0Bgt/AEG8Bgt/AEHMBgt/AEHcBgt/AEHeBgt/AEHgBgt/AEHmBgt/AEHsBgt/AEHuBgt/AEH4Bgt/AEGGBwt/AEGSBwt/AEGeBwt/AEGqBwt/AEG2Bwt/AEG8Bwt/AEHCBwt/AEHIBwt/AEHOBwt/AEHYBwt/AEHqBwt/AEHwBwt/AEGECAt/AEGYCAt/AEGqCAt/AEGsCAt/AEGuCAt/AEG4CAt/AEHKCAt/AEHOCAt/AEHgCAt/AEH2CAt/AEH6CAt/AEGACQt/AEGICQt/AEGWCQt/AEGgCQt/AEGmCQt/AEHYCQt/AEHmCQt/AEH2CQt/AEGICgt/AEGWCgt/AEGgCgt/AEGqCgt/AEHACgt/AEHECgt/AEHcCgt/AEH0Cgt/AEGQCwt/AEGuCwt/AEGyCwt/AEG2Cwt/AEG6Cwt/AEG+Cwt/AEHECwt/AEHKCwt/AEH4DAt/AEH+DAt/AEGsDgt/AEHaDwt/AEH6Dwt/AEGGEAt/AEGMEAt/AEGaEAt/AEGqEAt/AEG2EAt/AEHCEAt/AEGCEQt/AEGUEQt/AEGgEQt/AEGsEQt/AEG8EQt/AEHGEQt/AEHQEQt/AEHcEQt/AEHoEQt/AEHsEQt/AEHwEQt/AEH8EQt/AEGIEgt/AEGsEgt/AEHEEgt/AEGEEwt/AEGMEwt/AEGSEwt/AEGcEwt/AEGmEwt/AEG4Ewt/AEHKEwt/AEGKFAt/AEGMFAt/AEGOFAt/AEGmFAt/AEHKFAt/AEHWFAt/AEHkFAt/AEH0FAt/AEGAFQt/AEGEFQt/AEGKFQt/AEGWFQt/AEGiFQt/AEGqFQt/AEG2FQt/AEG8FQt/AEHGFQt/AEHSFQt/AEHcFQt/AEHoFQt/AEH4FQt/AEGGFgt/AEGYFgt/AEGiFgt/AEGwFgt/AEG8Fgt/AEHGFgt/AEHYFgt/AEHqFgt/AEHyFgt/AEGAFwt/AEGIFwt/AEGUFwt/AEGcFwt/AEGqFwt/AEGyFwt/AEHAFwt/AEHOFwt/AEHUFwt/AEHeFwt/AEH4Fwt/AEGIGAt/AEGYGAt/AEGyGAt/AEG4GAt/AEHSGAt/AEHeGAt/AEHmGAt/AEHuGAt/AEH6GAt/AEGAGQt/AEGIGQt/AEHCGQt/AEHUGQt/AEHkGQt/AEHyGQt/AEH8GQt/AEGEGgt/AEGQGgt/AEGYGgt/AEGkGgt/AEGsGgt/AEG0Ggt/AEHEGgt/AEHSGgt/AEHiGgt/AEHkGgt/AEHoGgt/AEHyGgt/AEH2Ggt/AEGAGwt/AEGEGwt/AEGKGwt/AEGgGwt/AEGwGwt/AEG8Gwt/AEHAGwt/AEHMGwt/AEHcGwt/AEHsGwt/AEH0Gwt/AEGCHAt/AEGIHAt/AEGWHAt/AEGeHAt/AEGmHAt/AEGwHAt/AEHKHAt/AEHOHAt/AEHUHAt/AEHcHAt/AEHmHAt/AEHuHAt/AEH8HAt/AEGIHQt/AEGSHQt/AEGcHQt/AEGmHQt/AEGuHQt/AEG8HQt/AEHIHQt/AEHUHQt/AEHgHQt/AEGkHgt/AEHUHgt/AEHmHgt/AEHwHgt/AEH0Hgt/AEH2Hgt/AEH6Hgt/AEH8Hgt/AEH+Hgt/AEGEHwt/AEGGHwt/AEGUHwt/AEGaHwt/AEGoHwt/AEGyHwt/AEG8Hwt/AEHCHwt/AEHMHwt/AEH4Hwt/AEGGIAt/AEGSIAt/AEGYIAt/AEGaIAt/AEGmIAt/AEGyIAt/AEG0IAt/AEG+IAt/AEHKIAt/AEHYIAt/AEHaIAt/AEHkIAt/AEHqIAt/AEHsIAt/AEH4IAt/AEGGIQt/AEGSIQt/AEGeIQt/AEGkIQt/AEGuIQt/AEHaIQt/AEHoIQt/AEH+IQt/AEGUIgt/AEGeIgt/AEGoIgt/AEGyIgt/AEG8Igt/AEHGIgt/AEHQIgt/AEHgIgt/AEHuIgt/AEH+Igt/AEGUIwt/AEGcIwt/AEGmIwt/AEG2Iwt/AEHMIwt/AEHcIwt/AEHsIwt/AEGCJAt/AEGSJAt/AEGeJAt/AEGqJAt/AEG2JAt/AEHCJAt/AEHIJAt/AEHaJAsH95qAgADPAgZtZW1vcnkCAAVkYXRhMAMABWRhdGExAwEFZGF0YTIDAgVkYXRhMwMDBWRhdGE0AwQFZGF0YTUDBQVkYXRhNgMGBWRhdGE3AwcFZGF0YTgDCAVkYXRhOQMJBmRhdGExMAMKBmRhdGExMQMLBmRhdGExMgMMBmRhdGExMwMNBmRhdGExNAMOBmRhdGExNQMPBmRhdGExNgMQBmRhdGExNwMRBmRhdGExOAMSBmRhdGExOQMTBmRhdGEyMAMUBmRhdGEyMQMVBmRhdGEyMgMWBmRhdGEyMwMXBmRhdGEyNAMYBmRhdGEyNQMZBmRhdGEyNgMaBmRhdGEyNwMbBmRhdGEyOAMcBmRhdGEyOQMdBmRhdGEzMAMeBmRhdGEzMQMfBmRhdGEzMgMgBmRhdGEzMwMhBmRhdGEzNAMiBmRhdGEzNQMjBmRhdGEzNgMkBmRhdGEzNwMlBmRhdGEzOAMmBmRhdGEzOQMnBmRhdGE0MAMoBmRhdGE0MQMpBmRhdGE0MgMqBmRhdGE0MwMrBmRhdGE0NAMsBmRhdGE0NQMtBmRhdGE0NgMuBmRhdGE0NwMvBmRhdGE0OAMwBmRhdGE0OQMxBmRhdGE1MAMyBmRhdGE1MQMzBmRhdGE1MgM0BmRhdGE1MwM1BmRhdGE1NAM2BmRhdGE1NQM3BmRhdGE1NgM4BmRhdGE1NwM5BmRhdGE1OAM6BmRhdGE1OQM7BmRhdGE2MAM8BmRhdGE2MQM9BmRhdGE2MgM+BmRhdGE2MwM/BmRhdGE2NANABmRhdGE2NQNBBmRhdGE2NgNCBmRhdGE2NwNDBmRhdGE2OANEBmRhdGE2OQNFBmRhdGE3MANGBmRhdGE3MQNHBmRhdGE3MgNIBmRhdGE3MwNJBmRhdGE3NANKBmRhdGE3NQNLBmRhdGE3NgNMBmRhdGE3NwNNBmRhdGE3OANOBmRhdGE3OQNPBmRhdGE4MANQBmRhdGE4MQNRBmRhdGE4MgNSBmRhdGE4MwNTBmRhdGE4NANUBmRhdGE4NQNVBmRhdGE4NgNWBmRhdGE4NwNXBmRhdGE4OANYBmRhdGE4OQNZBmRhdGE5MANaBmRhdGE5MQNbBmRhdGE5MgNcBmRhdGE5MwNdBmRhdGE5NANeBmRhdGE5NQNfBmRhdGE5NgNgBmRhdGE5NwNhBmRhdGE5OANiBmRhdGE5OQNjB2RhdGExMDADZAdkYXRhMTAxA2UHZGF0YTEwMgNmB2RhdGExMDMDZwdkYXRhMTA0A2gHZGF0YTEwNQNpB2RhdGExMDYDagdkYXRhMTA3A2sHZGF0YTEwOANsB2RhdGExMDkDbQdkYXRhMTEwA24HZGF0YTExMQNvB2RhdGExMTIDcAdkYXRhMTEzA3EHZGF0YTExNANyB2RhdGExMTUDcwdkYXRhMTE2A3QHZGF0YTExNwN1B2RhdGExMTgDdgdkYXRhMTE5A3cHZGF0YTEyMAN4B2RhdGExMjEDeQdkYXRhMTIyA3oHZGF0YTEyMwN7B2RhdGExMjQDfAdkYXRhMTI1A30HZGF0YTEyNgN+B2RhdGExMjcDfwdkYXRhMTI4A4ABB2RhdGExMjkDgQEHZGF0YTEzMAOCAQdkYXRhMTMxA4MBB2RhdGExMzIDhAEHZGF0YTEzMwOFAQdkYXRhMTM0A4YBB2RhdGExMzUDhwEHZGF0YTEzNgOIAQdkYXRhMTM3A4kBB2RhdGExMzgDigEHZGF0YTEzOQOLAQdkYXRhMTQwA4wBB2RhdGExNDEDjQEHZGF0YTE0MgOOAQdkYXRhMTQzA48BB2RhdGExNDQDkAEHZGF0YTE0NQORAQdkYXRhMTQ2A5IBB2RhdGExNDcDkwEHZGF0YTE0OAOUAQdkYXRhMTQ5A5UBB2RhdGExNTADlgEHZGF0YTE1MQOXAQdkYXRhMTUyA5gBB2RhdGExNTMDmQEHZGF0YTE1NAOaAQdkYXRhMTU1A5sBB2RhdGExNTYDnAEHZGF0YTE1NwOdAQdkYXRhMTU4A54BB2RhdGExNTkDnwEHZGF0YTE2MAOgAQdkYXRhMTYxA6EBB2RhdGExNjIDogEHZGF0YTE2MwOjAQdkYXRhMTY0A6QBB2RhdGExNjUDpQEHZGF0YTE2NgOmAQdkYXRhMTY3A6cBB2RhdGExNjgDqAEHZGF0YTE2OQOpAQdkYXRhMTcwA6oBB2RhdGExNzEDqwEHZGF0YTE3MgOsAQdkYXRhMTczA60BB2RhdGExNzQDrgEHZGF0YTE3NQOvAQdkYXRhMTc2A7ABB2RhdGExNzcDsQEHZGF0YTE3OAOyAQdkYXRhMTc5A7MBB2RhdGExODADtAEHZGF0YTE4MQO1AQdkYXRhMTgyA7YBB2RhdGExODMDtwEHZGF0YTE4NAO4AQdkYXRhMTg1A7kBB2RhdGExODYDugEHZGF0YTE4NwO7AQdkYXRhMTg4A7wBB2RhdGExODkDvQEHZGF0YTE5MAO+AQdkYXRhMTkxA78BB2RhdGExOTIDwAEHZGF0YTE5MwPBAQdkYXRhMTk0A8IBB2RhdGExOTUDwwEHZGF0YTE5NgPEAQdkYXRhMTk3A8UBB2RhdGExOTgDxgEHZGF0YTE5OQPHAQdkYXRhMjAwA8gBB2RhdGEyMDEDyQEHZGF0YTIwMgPKAQdkYXRhMjAzA8sBB2RhdGEyMDQDzAEHZGF0YTIwNQPNAQdkYXRhMjA2A84BB2RhdGEyMDcDzwEHZGF0YTIwOAPQAQdkYXRhMjA5A9EBB2RhdGEyMTAD0gEHZGF0YTIxMQPTAQdkYXRhMjEyA9QBB2RhdGEyMTMD1QEHZGF0YTIxNAPWAQdkYXRhMjE1A9cBB2RhdGEyMTYD2AEHZGF0YTIxNwPZAQdkYXRhMjE4A9oBB2RhdGEyMTkD2wEHZGF0YTIyMAPcAQdkYXRhMjIxA90BB2RhdGEyMjID3gEHZGF0YTIyMwPfAQdkYXRhMjI0A+ABB2RhdGEyMjUD4QEHZGF0YTIyNgPiAQdkYXRhMjI3A+MBB2RhdGEyMjgD5AEHZGF0YTIyOQPlAQdkYXRhMjMwA+YBB2RhdGEyMzED5wEHZGF0YTIzMgPoAQdkYXRhMjMzA+kBB2RhdGEyMzQD6gEHZGF0YTIzNQPrAQdkYXRhMjM2A+wBB2RhdGEyMzcD7QEHZGF0YTIzOAPuAQdkYXRhMjM5A+8BB2RhdGEyNDAD8AEHZGF0YTI0MQPxAQdkYXRhMjQyA/IBB2RhdGEyNDMD8wEHZGF0YTI0NAP0AQdkYXRhMjQ1A/UBB2RhdGEyNDYD9gEHZGF0YTI0NwP3AQdkYXRhMjQ4A/gBB2RhdGEyNDkD+QEHZGF0YTI1MAP6AQdkYXRhMjUxA/sBB2RhdGEyNTID/AEHZGF0YTI1MwP9AQdkYXRhMjU0A/4BB2RhdGEyNTUD/wEHZGF0YTI1NgOAAgdkYXRhMjU3A4ECB2RhdGEyNTgDggIHZGF0YTI1OQODAgdkYXRhMjYwA4QCB2RhdGEyNjEDhQIHZGF0YTI2MgOGAgdkYXRhMjYzA4cCB2RhdGEyNjQDiAIHZGF0YTI2NQOJAgdkYXRhMjY2A4oCB2RhdGEyNjcDiwIHZGF0YTI2OAOMAgdkYXRhMjY5A40CB2RhdGEyNzADjgIHZGF0YTI3MQOPAgdkYXRhMjcyA5ACB2RhdGEyNzMDkQIHZGF0YTI3NAOSAgdkYXRhMjc1A5MCB2RhdGEyNzYDlAIHZGF0YTI3NwOVAgdkYXRhMjc4A5YCB2RhdGEyNzkDlwIHZGF0YTI4MAOYAgdkYXRhMjgxA5kCB2RhdGEyODIDmgIHZGF0YTI4MwObAgdkYXRhMjg0A5wCB2RhdGEyODUDnQIHZGF0YTI4NgOeAgdkYXRhMjg3A58CB2RhdGEyODgDoAIHZGF0YTI4OQOhAgdkYXRhMjkwA6ICB2RhdGEyOTEDowIHZGF0YTI5MgOkAgdkYXRhMjkzA6UCB2RhdGEyOTQDpgIHZGF0YTI5NQOnAgdkYXRhMjk2A6gCB2RhdGEyOTcDqQIHZGF0YTI5OAOqAgdkYXRhMjk5A6sCB2RhdGEzMDADrAIHZGF0YTMwMQOtAgdkYXRhMzAyA64CB2RhdGEzMDMDrwIHZGF0YTMwNAOwAgdkYXRhMzA1A7ECB2RhdGEzMDYDsgIHZGF0YTMwNwOzAgdkYXRhMzA4A7QCB2RhdGEzMDkDtQIHZGF0YTMxMAO2AgdkYXRhMzExA7cCB2RhdGEzMTIDuAIHZGF0YTMxMwO5AgdkYXRhMzE0A7oCB2RhdGEzMTUDuwIHZGF0YTMxNgO8AgdkYXRhMzE3A70CB2RhdGEzMTgDvgIHZGF0YTMxOQO/AgdkYXRhMzIwA8ACB2RhdGEzMjEDwQIHZGF0YTMyMgPCAgdkYXRhMzIzA8MCB2RhdGEzMjQDxAIHZGF0YTMyNQPFAgdkYXRhMzI2A8YCB2RhdGEzMjcDxwIHZGF0YTMyOAPIAgdkYXRhMzI5A8kCB2RhdGEzMzADygIHZGF0YTMzMQPLAgdkYXRhMzMyA8wCB2RhdGEzMzMDzQIL5rCAgADOAgBBAQsGY2xpY2sAAEEICwVpbml0AABBDgsidG9FZGdlJTIwZnJvbUVkZ2UlMjBsb2NrJTIwdW5sb2NrAABBMgsIZGVzdHJveQAAQTwLEWVuYWJsZSUyMGRpc2FibGUAAEHOAAsMcmVtb3ZlQ2xhc3MAAEHcAAsJYWRkQ2xhc3MAAEHmAAsMcmVtb3ZlQ2xhc3MAAEH0AAsJYWRkQ2xhc3MAAEH+AAsGY2xpY2sAAEGGAQsPbmF2aWdhdGlvblNob3cAAEGWAQsPbmF2aWdhdGlvbkhpZGUAAEGmAQsBAABBqAELCCU1QyUyNDEAAEGyAQsCLgAAQbYBCxJzd2lwZXItcGFnaW5hdGlvbgAAQcoBCwhidWxsZXRzAABB1AELCGJ1bGxldHMAAEHeAQsLb3V0ZXJXaWR0aAAAQeoBCwxvdXRlckhlaWdodAAAQfgBCwZ3aWR0aAAAQYACCwdoZWlnaHQAAEGIAgsBAABBigILBi1uZXh0AABBkgILCy1uZXh0LW5leHQAAEGeAgsGLXByZXYAAEGmAgsLLXByZXYtcHJldgAAQbICCwYtbWFpbgAAQboCCwQlMjAAAEHAAgsFcHJldgAAQcYCCwVuZXh0AABBzAILBXByZXYAAEHSAgsFbmV4dAAAQdgCCwVwcmV2AABB3gILBW5leHQAAEHkAgsGcmlnaHQAAEHsAgsFbGVmdAAAQfICCwR0b3AAAEH4AgsJZnJhY3Rpb24AAEGCAwsMcHJvZ3Jlc3NiYXIAAEGQAwsJdmVydGljYWwAAEGaAwsLaG9yaXpvbnRhbAAAQaYDCwtob3Jpem9udGFsAABBsgMLCXZlcnRpY2FsAABBvAMLC2hvcml6b250YWwAAEHIAwsHY3VzdG9tAABB0AMLEXBhZ2luYXRpb25SZW5kZXIAAEHiAwsRcGFnaW5hdGlvblVwZGF0ZQAAQfQDCwlhZGRDbGFzcwAAQf4DCwxyZW1vdmVDbGFzcwAAQYwECwEAAEGOBAsIYnVsbGV0cwAAQZgECwlmcmFjdGlvbgAAQaIECwolMjAlMkYlMjAAAEGuBAsMcHJvZ3Jlc3NiYXIAAEG8BAsHY3VzdG9tAABBxAQLEXBhZ2luYXRpb25SZW5kZXIAAEHWBAsHc3RyaW5nAABB3gQLCC5zd2lwZXIAAEHoBAsIYnVsbGV0cwAAQfIECwhidWxsZXRzAABB/AQLDHByb2dyZXNzYmFyAABBigULBmNsaWNrAABBkgULBmNsaWNrAABBmgULBWluaXQAAEGgBQsSYWN0aXZlSW5kZXhDaGFuZ2UAAEG0BQsQc25hcEluZGV4Q2hhbmdlAABBxgULE3NsaWRlc0xlbmd0aENoYW5nZQAAQdoFCxVzbmFwR3JpZExlbmd0aENoYW5nZQAAQfAFCwhkZXN0cm95AABB+gULEWVuYWJsZSUyMGRpc2FibGUAAEGMBgsMcmVtb3ZlQ2xhc3MAAEGaBgsJYWRkQ2xhc3MAAEGkBgsObG9jayUyMHVubG9jawAAQbQGCwZjbGljawAAQbwGCw9wYWdpbmF0aW9uU2hvdwAAQcwGCw9wYWdpbmF0aW9uSGlkZQAAQdwGCwEAAEHeBgsBAABB4AYLBWF1dG8AAEHmBgsFbm9uZQAAQewGCwEAAEHuBgsJYWRkQ2xhc3MAAEH4BgsMcmVtb3ZlQ2xhc3MAAEGGBwsLdG91Y2hzdGFydAAAQZIHCwp0b3VjaG1vdmUAAEGeBwsLdG91Y2hzdGFydAAAQaoHCwp0b3VjaG1vdmUAAEG2BwsFbGVmdAAAQbwHCwR0b3AAAEHCBwsFbGVmdAAAQcgHCwR0b3AAAEHOBwsIb3BhY2l0eQAAQdgHCxFzY3JvbGwtc25hcC10eXBlAABB6gcLBW5vbmUAAEHwBwsTc2Nyb2xsYmFyRHJhZ1N0YXJ0AABBhAgLEnNjcm9sbGJhckRyYWdNb3ZlAABBmAgLEXNjcm9sbC1zbmFwLXR5cGUAAEGqCAsBAABBrAgLAQAAQa4ICwhvcGFjaXR5AABBuAgLEXNjcm9sbGJhckRyYWdFbmQAAEHKCAsDb24AAEHOCAsRYWRkRXZlbnRMaXN0ZW5lcgAAQeAICxRyZW1vdmVFdmVudExpc3RlbmVyAABB9ggLA29uAABB+ggLBG9mZgAAQYAJCwdzdHJpbmcAAEGICQsMcmVtb3ZlQ2xhc3MAAEGWCQsJYWRkQ2xhc3MAAEGgCQsFaW5pdAAAQaYJCzF1cGRhdGUlMjByZXNpemUlMjBvYnNlcnZlclVwZGF0ZSUyMGxvY2slMjB1bmxvY2sAAEHYCQsNc2V0VHJhbnNsYXRlAABB5gkLDnNldFRyYW5zaXRpb24AAEH2CQsRZW5hYmxlJTIwZGlzYWJsZQAAQYgKCwxyZW1vdmVDbGFzcwAAQZYKCwlhZGRDbGFzcwAAQaAKCwhkZXN0cm95AABBqgoLFWRhdGEtc3dpcGVyLXBhcmFsbGF4AABBwAoLAjAAAEHECgsXZGF0YS1zd2lwZXItcGFyYWxsYXgteAAAQdwKCxdkYXRhLXN3aXBlci1wYXJhbGxheC15AABB9AoLG2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlAABBkAsLHWRhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHkAAEGuCwsCMAAAQbILCwIwAABBtgsLAjAAAEG6CwsCMAAAQb4LCwQlMjUAAEHECwsEJTI1AABBygsLrQElNUJkYXRhLXN3aXBlci1wYXJhbGxheCU1RCUyQyUyMCU1QmRhdGEtc3dpcGVyLXBhcmFsbGF4LXglNUQlMkMlMjAlNUJkYXRhLXN3aXBlci1wYXJhbGxheC15JTVEJTJDJTIwJTVCZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eSU1RCUyQyUyMCU1QmRhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlJTVEAABB+AwLBWF1dG8AAEH+DAutASU1QmRhdGEtc3dpcGVyLXBhcmFsbGF4JTVEJTJDJTIwJTVCZGF0YS1zd2lwZXItcGFyYWxsYXgteCU1RCUyQyUyMCU1QmRhdGEtc3dpcGVyLXBhcmFsbGF4LXklNUQlMkMlMjAlNUJkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5JTVEJTJDJTIwJTVCZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGUlNUQAAEGsDgutASU1QmRhdGEtc3dpcGVyLXBhcmFsbGF4JTVEJTJDJTIwJTVCZGF0YS1zd2lwZXItcGFyYWxsYXgteCU1RCUyQyUyMCU1QmRhdGEtc3dpcGVyLXBhcmFsbGF4LXklNUQlMkMlMjAlNUJkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5JTVEJTJDJTIwJTVCZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGUlNUQAAEHaDwseZGF0YS1zd2lwZXItcGFyYWxsYXgtZHVyYXRpb24AAEH6DwsLYmVmb3JlSW5pdAAAQYYQCwVpbml0AABBjBALDXNldFRyYW5zbGF0ZQAAQZoQCw5zZXRUcmFuc2l0aW9uAABBqhALC3RvdWNoc3RhcnQAAEG2EAsLdG91Y2hzdGFydAAAQcIQCz9waWN0dXJlJTJDJTIwaW1nJTJDJTIwc3ZnJTJDJTIwY2FudmFzJTJDJTIwLnN3aXBlci16b29tLXRhcmdldAAAQYIRCxFkYXRhLXN3aXBlci16b29tAABBlBELCnRvdWNobW92ZQAAQaARCwp0b3VjaG1vdmUAAEGsEQsOZ2VzdHVyZWNoYW5nZQAAQbwRCwl0b3VjaGVuZAAAQcYRCwl0b3VjaGVuZAAAQdARCwt0b3VjaHN0YXJ0AABB3BELC3RvdWNoc3RhcnQAAEHoEQsCeAAAQewRCwJ5AABB8BELCnRvdWNobW92ZQAAQfwRCwp0b3VjaG1vdmUAAEGIEgsidHJhbnNsYXRlM2QoMCUyQzAlMkMwKSUyMHNjYWxlKDEpAABBrBILF3RyYW5zbGF0ZTNkKDAlMkMwJTJDMCkAAEHEEgs/cGljdHVyZSUyQyUyMGltZyUyQyUyMHN2ZyUyQyUyMGNhbnZhcyUyQyUyMC5zd2lwZXItem9vbS10YXJnZXQAAEGEEwsHaGlkZGVuAABBjBMLBW5vbmUAAEGSEwsJdG91Y2hlbmQAAEGcEwsJdG91Y2hlbmQAAEGmEwsRZGF0YS1zd2lwZXItem9vbQAAQbgTCxFkYXRhLXN3aXBlci16b29tAABByhMLP3BpY3R1cmUlMkMlMjBpbWclMkMlMjBzdmclMkMlMjBjYW52YXMlMkMlMjAuc3dpcGVyLXpvb20tdGFyZ2V0AABBihQLAQAAQYwUCwEAAEGOFAsXdHJhbnNsYXRlM2QoMCUyQzAlMkMwKQAAQaYUCyJ0cmFuc2xhdGUzZCgwJTJDMCUyQzApJTIwc2NhbGUoMSkAAEHKFAsLdG91Y2hzdGFydAAAQdYUCw1nZXN0dXJlc3RhcnQAAEHkFAsOZ2VzdHVyZWNoYW5nZQAAQfQUCwtnZXN0dXJlZW5kAABBgBULA29uAABBhBULBG9mZgAAQYoVCwt0b3VjaHN0YXJ0AABBlhULC3RvdWNoc3RhcnQAAEGiFQsGc2NhbGUAAEGqFQsLem9vbUNoYW5nZQAAQbYVCwVpbml0AABBvBULCGRlc3Ryb3kAAEHGFQsLdG91Y2hTdGFydAAAQdIVCwl0b3VjaEVuZAAAQdwVCwpkb3VibGVUYXAAAEHoFQsOdHJhbnNpdGlvbkVuZAAAQfgVCwxzbGlkZUNoYW5nZQAAQYYWCxBkYXRhLWJhY2tncm91bmQAAEGYFgsJZGF0YS1zcmMAAEGiFgsMZGF0YS1zcmNzZXQAAEGwFgsLZGF0YS1zaXplcwAAQbwWCwhwaWN0dXJlAABBxhYLEWJhY2tncm91bmQtaW1hZ2UAAEHYFgsQZGF0YS1iYWNrZ3JvdW5kAABB6hYLB3NyY3NldAAAQfIWCwxkYXRhLXNyY3NldAAAQYAXCwZzaXplcwAAQYgXCwtkYXRhLXNpemVzAABBlBcLB3NvdXJjZQAAQZwXCwxkYXRhLXNyY3NldAAAQaoXCwdzcmNzZXQAAEGyFwsMZGF0YS1zcmNzZXQAAEHAFwsMZGF0YS1zcmNzZXQAAEHOFwsEc3JjAABB1BcLCWRhdGEtc3JjAABB3hcLGGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4AABB+BcLD2xhenlJbWFnZVJlYWR5AABBiBgLDmxhenlJbWFnZUxvYWQAAEGYGAsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEGyGAsFYXV0bwAAQbgYCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQdIYCwt0b3VjaHN0YXJ0AABB3hgLB3Njcm9sbAAAQeYYCwdzY3JvbGwAAEHuGAsLYmVmb3JlSW5pdAAAQfoYCwVpbml0AABBgBkLB3Njcm9sbAAAQYgZCzhzY3JvbGxiYXJEcmFnTW92ZSUyMHJlc2l6ZSUyMF9mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlAABBwhkLEHRyYW5zaXRpb25TdGFydAAAQdQZCw50cmFuc2l0aW9uRW5kAABB5BkLDHNsaWRlQ2hhbmdlAABB8hkLCGRlc3Ryb3kAAEH8GQsGc2xpZGUAAEGEGgsKY29udGFpbmVyAABBkBoLBnNsaWRlAABBmBoLC2JlZm9yZUluaXQAAEGkGgsHdXBkYXRlAABBrBoLB3Jlc2l6ZQAAQbQaCw9vYnNlcnZlclVwZGF0ZQAAQcQaCw1zZXRUcmFuc2xhdGUAAEHSGgsOc2V0VHJhbnNpdGlvbgAAQeIaCwEAAEHkGgsCeAAAQegaCwl0YWJJbmRleAAAQfIaCwIwAABB9hoLCXRhYkluZGV4AABBgBsLAy0xAABBhBsLBXJvbGUAAEGKGwsVYXJpYS1yb2xlZGVzY3JpcHRpb24AAEGgGwsOYXJpYS1jb250cm9scwAAQbAbCwthcmlhLWxhYmVsAABBvBsLA2lkAABBwBsLCmFyaWEtbGl2ZQAAQcwbCw5hcmlhLWRpc2FibGVkAABB3BsLDmFyaWEtZGlzYWJsZWQAAEHsGwsHYnV0dG9uAABB9BsLDWFyaWEtY3VycmVudAAAQYIcCwV0cnVlAABBiBwLDWFyaWEtY3VycmVudAAAQZYcCwdCVVRUT04AAEGeHAsHYnV0dG9uAABBphwLCGtleWRvd24AAEGwHAsYZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgAAEHKHAsDaWQAAEHOHAsEb2ZmAABB1BwLB3BvbGl0ZQAAQdwcCwhrZXlkb3duAABB5hwLBmZvY3VzAABB7hwLDHBvaW50ZXJkb3duAABB/BwLCnBvaW50ZXJ1cAAAQYgdCwhrZXlkb3duAABBkh0LCGtleWRvd24AAEGcHQsIa2V5ZG93bgAAQaYdCwZmb2N1cwAAQa4dCwxwb2ludGVyZG93bgAAQbwdCwpwb2ludGVydXAAAEHIHQsLYmVmb3JlSW5pdAAAQdQdCwphZnRlckluaXQAAEHgHQtDc2xpZGVzTGVuZ3RoQ2hhbmdlJTIwc25hcEdyaWRMZW5ndGhDaGFuZ2UlMjBzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlAABBpB4LLmZyb21FZGdlJTIwdG9FZGdlJTIwYWZ0ZXJJbml0JTIwbG9jayUyMHVubG9jawAAQdQeCxFwYWdpbmF0aW9uVXBkYXRlAABB5h4LCGRlc3Ryb3kAAEHwHgsCLQAAQfQeCwEAAEH2HgsCLQAAQfoeCwEAAEH8HgsBAABB/h4LBCUyRgAAQYQfCwEAAEGGHwsNZGF0YS1oaXN0b3J5AABBlB8LBCUyRgAAQZofCw1kYXRhLWhpc3RvcnkAAEGoHwsJcG9wc3RhdGUAAEGyHwsJcG9wc3RhdGUAAEG8HwsFaW5pdAAAQcIfCwhkZXN0cm95AABBzB8LK3RyYW5zaXRpb25FbmQlMjBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZQAAQfgfCwxzbGlkZUNoYW5nZQAAQYYgCwtoYXNoQ2hhbmdlAABBkiALBCUyMwAAQZggCwEAAEGaIAsKZGF0YS1oYXNoAABBpiALCmRhdGEtaGFzaAAAQbIgCwEAAEG0IAsIaGFzaFNldAAAQb4gCwpkYXRhLWhhc2gAAEHKIAsNZGF0YS1oaXN0b3J5AABB2CALAQAAQdogCwhoYXNoU2V0AABB5CALBCUyMwAAQeogCwEAAEHsIAsKZGF0YS1oYXNoAABB+CALDWRhdGEtaGlzdG9yeQAAQYYhCwtoYXNoY2hhbmdlAABBkiELC2hhc2hjaGFuZ2UAAEGeIQsFaW5pdAAAQaQhCwhkZXN0cm95AABBriELK3RyYW5zaXRpb25FbmQlMjBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZQAAQdohCwxzbGlkZUNoYW5nZQAAQeghCxVkYXRhLXN3aXBlci1hdXRvcGxheQAAQf4hCxVkYXRhLXN3aXBlci1hdXRvcGxheQAAQZQiCwlhdXRvcGxheQAAQZ4iCwlhdXRvcGxheQAAQagiCwlhdXRvcGxheQAAQbIiCwlhdXRvcGxheQAAQbwiCwlhdXRvcGxheQAAQcYiCwlhdXRvcGxheQAAQdAiCw5hdXRvcGxheVN0YXJ0AABB4CILDWF1dG9wbGF5U3RvcAAAQe4iCw50cmFuc2l0aW9uZW5kAABB/iILFHdlYmtpdFRyYW5zaXRpb25FbmQAAEGUIwsHaGlkZGVuAABBnCMLCHZpc2libGUAAEGmIwsOdHJhbnNpdGlvbmVuZAAAQbYjCxR3ZWJraXRUcmFuc2l0aW9uRW5kAABBzCMLDmF1dG9wbGF5UGF1c2UAAEHcIwsOdHJhbnNpdGlvbmVuZAAAQewjCxR3ZWJraXRUcmFuc2l0aW9uRW5kAABBgiQLD2F1dG9wbGF5UmVzdW1lAABBkiQLC21vdXNlZW50ZXIAAEGeJAsLbW91c2VsZWF2ZQAAQaokCwttb3VzZWVudGVyAABBtiQLC21vdXNlbGVhdmUAAEHCJAsFaW5pdAAAQcgkCxF2aXNpYmlsaXR5Y2hhbmdlAABB2iQLFmJlZm9yZVRyYW5zaXRpb25TdGFydAA=',
    'AGFzbQEAAAAFg4CAgAABAAEGsISAgABefwBBAQt/AEESC38AQRwLfwBBJgt/AEE4C38AQdIAC38AQdgAC38AQd4AC38AQeQAC38AQeoAC38AQfAAC38AQfYAC38AQfwAC38AQYgBC38AQbgBC38AQcgBC38AQdgBC38AQeABC38AQegBC38AQfIBC38AQfwBC38AQYICC38AQZICC38AQaICC38AQb4CC38AQdoCC38AQeACC38AQeYCC38AQewCC38AQfQCC38AQYADC38AQYIDC38AQYoDC38AQZIDC38AQZoDC38AQaIDC38AQaoDC38AQbIDC38AQboDC38AQcIDC38AQcoDC38AQdYDC38AQeQDC38AQfQDC38AQYQEC38AQf4EC38AQY4FC38AQaQFC38AQbQFC38AQdAFC38AQeoFC38AQYYGC38AQaQGC38AQaoGC38AQbAGC38AQbgGC38AQcAGC38AQdYGC38AQZAHC38AQaYHC38AQeAHC38AQfoHC38AQZYIC38AQZAJC38AQaYJC38AQagJC38AQaoJC38AQcYJC38AQeAJC38AQfwJC38AQZoKC38AQaAKC38AQaYKC38AQa4KC38AQbYKC38AQbALC38AQboLC38AQcILC38AQcgLC38AQeQLC38AQf4LC38AQZoMC38AQbgMC38AQb4MC38AQcQMC38AQcwMC38AQdQMC38AQc4NC38AQdYNC38AQd4NC38AQfQNC38AQYYOC38AQZwOC38AQbIOCwfOhoCAAF8GbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHBWRhdGE4AwgFZGF0YTkDCQZkYXRhMTADCgZkYXRhMTEDCwZkYXRhMTIDDAZkYXRhMTMDDQZkYXRhMTQDDgZkYXRhMTUDDwZkYXRhMTYDEAZkYXRhMTcDEQZkYXRhMTgDEgZkYXRhMTkDEwZkYXRhMjADFAZkYXRhMjEDFQZkYXRhMjIDFgZkYXRhMjMDFwZkYXRhMjQDGAZkYXRhMjUDGQZkYXRhMjYDGgZkYXRhMjcDGwZkYXRhMjgDHAZkYXRhMjkDHQZkYXRhMzADHgZkYXRhMzEDHwZkYXRhMzIDIAZkYXRhMzMDIQZkYXRhMzQDIgZkYXRhMzUDIwZkYXRhMzYDJAZkYXRhMzcDJQZkYXRhMzgDJgZkYXRhMzkDJwZkYXRhNDADKAZkYXRhNDEDKQZkYXRhNDIDKgZkYXRhNDMDKwZkYXRhNDQDLAZkYXRhNDUDLQZkYXRhNDYDLgZkYXRhNDcDLwZkYXRhNDgDMAZkYXRhNDkDMQZkYXRhNTADMgZkYXRhNTEDMwZkYXRhNTIDNAZkYXRhNTMDNQZkYXRhNTQDNgZkYXRhNTUDNwZkYXRhNTYDOAZkYXRhNTcDOQZkYXRhNTgDOgZkYXRhNTkDOwZkYXRhNjADPAZkYXRhNjEDPQZkYXRhNjIDPgZkYXRhNjMDPwZkYXRhNjQDQAZkYXRhNjUDQQZkYXRhNjYDQgZkYXRhNjcDQwZkYXRhNjgDRAZkYXRhNjkDRQZkYXRhNzADRgZkYXRhNzEDRwZkYXRhNzIDSAZkYXRhNzMDSQZkYXRhNzQDSgZkYXRhNzUDSwZkYXRhNzYDTAZkYXRhNzcDTQZkYXRhNzgDTgZkYXRhNzkDTwZkYXRhODADUAZkYXRhODEDUQZkYXRhODIDUgZkYXRhODMDUwZkYXRhODQDVAZkYXRhODUDVQZkYXRhODYDVgZkYXRhODcDVwZkYXRhODgDWAZkYXRhODkDWQZkYXRhOTADWgZkYXRhOTEDWwZkYXRhOTIDXAZkYXRhOTMDXQv5kYCAAF4AQQELEHNsaWRlckZpcnN0TW92ZQAAQRILCXRvdWNoRW5kAABBHAsIZGVzdHJveQAAQSYLEXZpc2liaWxpdHljaGFuZ2UAAEE4CxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQdIACwR0YXAAAEHYAAsFYXV0bwAAQd4ACwVuZXh0AABB5AALBXByZXYAAEHqAAsFbmV4dAAAQfAACwVwcmV2AABB9gALBW5leHQAAEH8AAsLYmVmb3JlSW5pdAAAQYgBCy9zbGlkZUNoYW5nZSUyMHVwZGF0ZSUyMHJlc2l6ZSUyMG9ic2VydmVyVXBkYXRlAABBuAELDnNldFRyYW5zaXRpb24AAEHIAQsOYmVmb3JlRGVzdHJveQAAQdgBCwdzdGFydFgAAEHgAQsHc3RhcnRZAABB6AELCWN1cnJlbnRYAABB8gELCWN1cnJlbnRZAABB/AELBW5leHQAAEGCAgsOdHJhbnNpdGlvbkVuZAAAQZICCw9tb21lbnR1bUJvdW5jZQAAQaICCxtfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZQAAQb4CCxtfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZQAAQdoCCwVhdXRvAABB4AILBHJvdwAAQeYCCwRyb3cAAEHsAgsHY29sdW1uAABB9AILC21hcmdpbi10b3AAAEGAAwsBAABBggMLBndpZHRoAABBigMLB29iamVjdAAAQZIDCwdsZW5ndGgAAEGaAwsHb2JqZWN0AABBogMLB2xlbmd0aAAAQaoDCwdvYmplY3QAAEGyAwsHbGVuZ3RoAABBugMLB29iamVjdAAAQcIDCwdsZW5ndGgAAEHKAwsLYmVmb3JlSW5pdAAAQdYDCw1zZXRUcmFuc2xhdGUAAEHkAwsOc2V0VHJhbnNpdGlvbgAAQfQDCw50cmFuc2l0aW9uRW5kAABBhAQLeS5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCUyQyUyMC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JTJDJTIwLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJTJDJTIwLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdAAAQf4ECw52aXJ0dWFsVXBkYXRlAABBjgULFHdlYmtpdFRyYW5zaXRpb25FbmQAAEGkBQsOdHJhbnNpdGlvbmVuZAAAQbQFCxouc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0AABB0AULGS5zd2lwZXItc2xpZGUtc2hhZG93LXRvcAAAQeoFCxsuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodAAAQYYGCxwuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20AAEGkBgsFbGVmdAAAQaoGCwR0b3AAAEGwBgsGcmlnaHQAAEG4BgsHYm90dG9tAABBwAYLFC5zd2lwZXItY3ViZS1zaGFkb3cAAEHWBgs5JTNDZGl2JTIwY2xhc3MlM0QlMjJzd2lwZXItY3ViZS1zaGFkb3clMjIlM0UlM0MlMkZkaXYlM0UAAEGQBwsULnN3aXBlci1jdWJlLXNoYWRvdwAAQaYHCzklM0NkaXYlMjBjbGFzcyUzRCUyMnN3aXBlci1jdWJlLXNoYWRvdyUyMiUzRSUzQyUyRmRpdiUzRQAAQeAHCxhkYXRhLXN3aXBlci1zbGlkZS1pbmRleAAAQfoHCxotLXN3aXBlci1jdWJlLXRyYW5zbGF0ZS16AABBlggLeS5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCUyQyUyMC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JTJDJTIwLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJTJDJTIwLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdAAAQZAJCxQuc3dpcGVyLWN1YmUtc2hhZG93AABBpgkLAQAAQagJCwEAAEGqCQsaLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdAAAQcYJCxkuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AAAEHgCQsbLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQAAEH8CQscLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tAABBmgoLBWxlZnQAAEGgCgsEdG9wAABBpgoLBnJpZ2h0AABBrgoLB2JvdHRvbQAAQbYKC3kuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AlMkMlMjAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCUyQyUyMC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSUyQyUyMC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQAAEGwCwsJZnVuY3Rpb24AAEG6CwsHc3RyaW5nAABBwgsLBCUyNQAAQcgLCxouc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0AABB5AsLGS5zd2lwZXItc2xpZGUtc2hhZG93LXRvcAAAQf4LCxsuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodAAAQZoMCxwuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20AAEG4DAsFbGVmdAAAQb4MCwR0b3AAAEHEDAsGcmlnaHQAAEHMDAsHYm90dG9tAABB1AwLeS5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCUyQyUyMC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JTJDJTIwLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJTJDJTIwLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdAAAQc4NCwdzdHJpbmcAAEHWDQsHJTJDJTIwAABB3g0LFS5zd2lwZXItc2xpZGUtc2hhZG93AABB9A0LEXRyYW5zZm9ybS1vcmlnaW4AAEGGDgsVLnN3aXBlci1zbGlkZS1zaGFkb3cAAEGcDgsVLnN3aXBlci1zbGlkZS1zaGFkb3cAAEGyDgsVLnN3aXBlci1zbGlkZS1zaGFkb3cA'
].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
!function (global, factory) {
    lS(0, 0) == typeof exports && lS(0, 1) != typeof module ? module.exports = factory() : lS(0, 2) == typeof define && define.amd ? define(factory) : (global = lS(0, 3) != typeof globalThis ? globalThis : global || self).PCPSwiper = factory();
}(this, function () {
    lS(0, 4);
    function isObject$1(obj) {
        return null !== obj && lS(0, 5) == typeof obj && lS(0, 6) in obj && obj.constructor === Object;
    }
    function extend$1(target, src) {
        void 0 === target && (target = {}), void 0 === src && (src = {}), Object.keys(src).forEach(key => {
            void 0 === target[key] ? target[key] = src[key] : isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0 && extend$1(target[key], src[key]);
        });
    }
    const ssrDocument = {
        body: {},
        addEventListener() {
        },
        removeEventListener() {
        },
        activeElement: {
            blur() {
            },
            nodeName: ''
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {
            }
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {
            },
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        }
    };
    function getDocument() {
        const doc = lS(0, 7) != typeof document ? document : {};
        return extend$1(doc, ssrDocument), doc;
    }
    const ssrWindow = {
        document: ssrDocument,
        navigator: { userAgent: '' },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        },
        history: {
            replaceState() {
            },
            pushState() {
            },
            go() {
            },
            back() {
            }
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener() {
        },
        removeEventListener() {
        },
        getComputedStyle: () => ({ getPropertyValue: () => lS(0, 8) }),
        Image() {
        },
        Date() {
        },
        screen: {},
        setTimeout() {
        },
        clearTimeout() {
        },
        matchMedia: () => ({}),
        requestAnimationFrame: callback => lS(0, 9) == typeof setTimeout ? (callback(), null) : setTimeout(callback, 0),
        cancelAnimationFrame(id) {
            lS(0, 10) != typeof setTimeout && clearTimeout(id);
        }
    };
    function getWindow() {
        const win = lS(0, 11) != typeof window ? window : {};
        return extend$1(win, ssrWindow), win;
    }
    function makeReactive(obj) {
        const proto = obj.__proto__;
        (() => {
            const __callInstance175 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.defineProperty(obj, lS(0, 12), {
                            get: () => proto,
                            set(value) {
                                proto.__proto__ = value;
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance175.exports;
            return __exports.data();
        })();
    }
    class Dom7 extends Array {
        constructor(items) {
            lS(0, 13) == typeof items ? super(items) : (super(...items || []), makeReactive(this));
        }
    }
    function arrayFlat(arr) {
        void 0 === arr && (arr = []);
        const res = [];
        return arr.forEach(el => {
            Array.isArray(el) ? res.push(...arrayFlat(el)) : res.push(el);
        }), res;
    }
    function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
        const uniqueArray = [];
        (() => {
            let i = 0;
            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < arr.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        -1 === uniqueArray.indexOf(arr[i]) && uniqueArray.push(arr[i]);
                    }
                }
            });
            const __exports = __forInstance0.exports;
            return __exports.data();
        })();
        return uniqueArray;
    }
    function qsa(selector, context) {
        if (lS(0, 14) != typeof selector)
            return [selector];
        const a = [], res = context.querySelectorAll(selector);
        (() => {
            let i = 0;
            const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < res.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __callInstance174 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        a.push(res[i]);
                                    }
                                }
                            });
                            const __exports = __callInstance174.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __forInstance1.exports;
            return __exports.data();
        })();
        return a;
    }
    function $(selector, context) {
        const window = getWindow(), document = getDocument();
        let arr = [];
        if (!context && selector instanceof Dom7)
            return selector;
        if (!selector)
            return new Dom7(arr);
        if (lS(0, 15) == typeof selector) {
            const html = selector.trim();
            (() => {
                const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let toCreate = lS(0, 18);
                                0 === html.indexOf(lS(0, 19)) && (toCreate = lS(0, 20)), 0 === html.indexOf(lS(0, 21)) && (toCreate = lS(0, 22)), 0 !== html.indexOf(lS(0, 23)) && 0 !== html.indexOf(lS(0, 24)) || (toCreate = lS(0, 25)), 0 === html.indexOf(lS(0, 26)) && (toCreate = lS(0, 27)), 0 === html.indexOf(lS(0, 28)) && (toCreate = lS(0, 29));
                                const tempParent = document.createElement(toCreate);
                                tempParent.innerHTML = html;
                                (() => {
                                    let i = 0;
                                    const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return i < tempParent.childNodes.length ? 1 : 0;
                                            },
                                            update: () => {
                                                i += 1;
                                            },
                                            body: () => {
                                                (() => {
                                                    const __callInstance173 = new WebAssembly.Instance(__callWasmModule, {
                                                        env: {
                                                            impFunc: () => {
                                                                arr.push(tempParent.childNodes[i]);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __callInstance173.exports;
                                                    return __exports.data();
                                                })();
                                            }
                                        }
                                    });
                                    const __exports = __forInstance2.exports;
                                    return __exports.data();
                                })();
                            }
                        },
                        impFunc2: () => {
                            arr = qsa(selector.trim(), context || document);
                        }
                    }
                });
                const __exports = __ifInstance0.exports;
                return __exports.data(html.indexOf(lS(0, 16)) >= 0 && html.indexOf(lS(0, 17)) >= 0 ? 1 : 0);
            })();
        } else if (selector.nodeType || selector === window || selector === document)
            (() => {
                const __callInstance172 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            arr.push(selector);
                        }
                    }
                });
                const __exports = __callInstance172.exports;
                return __exports.data();
            })();
        else if (Array.isArray(selector)) {
            if (selector instanceof Dom7)
                return selector;
            arr = selector;
        }
        return new Dom7(arrayUnique(arr));
    }
    function addClass() {
        (() => {
            var _len = arguments.length, classes = new Array(_len), _key = 0;
            const __forInstance3 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key < _len ? 1 : 0;
                    },
                    update: () => {
                        _key++;
                    },
                    body: () => {
                        classes[_key] = arguments[_key];
                    }
                }
            });
            const __exports = __forInstance3.exports;
            return __exports.data();
        })();
        const classNames = arrayFlat(classes.map(c => c.split(lS(0, 30))));
        return this.forEach(el => {
            (() => {
                const __callInstance171 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            el.classList.add(...classNames);
                        }
                    }
                });
                const __exports = __callInstance171.exports;
                return __exports.data();
            })();
        }), this;
    }
    function removeClass() {
        (() => {
            var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0;
            const __forInstance4 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key2 < _len2 ? 1 : 0;
                    },
                    update: () => {
                        _key2++;
                    },
                    body: () => {
                        classes[_key2] = arguments[_key2];
                    }
                }
            });
            const __exports = __forInstance4.exports;
            return __exports.data();
        })();
        const classNames = arrayFlat(classes.map(c => c.split(lS(0, 31))));
        return this.forEach(el => {
            (() => {
                const __callInstance170 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            el.classList.remove(...classNames);
                        }
                    }
                });
                const __exports = __callInstance170.exports;
                return __exports.data();
            })();
        }), this;
    }
    function toggleClass() {
        (() => {
            var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0;
            const __forInstance5 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key3 < _len3 ? 1 : 0;
                    },
                    update: () => {
                        _key3++;
                    },
                    body: () => {
                        classes[_key3] = arguments[_key3];
                    }
                }
            });
            const __exports = __forInstance5.exports;
            return __exports.data();
        })();
        const classNames = arrayFlat(classes.map(c => c.split(lS(0, 32))));
        (() => {
            const __callInstance169 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        this.forEach(el => {
                            (() => {
                                const __callInstance168 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            classNames.forEach(className => {
                                                (() => {
                                                    const __callInstance167 = new WebAssembly.Instance(__callWasmModule, {
                                                        env: {
                                                            impFunc: () => {
                                                                el.classList.toggle(className);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __callInstance167.exports;
                                                    return __exports.data();
                                                })();
                                            });
                                        }
                                    }
                                });
                                const __exports = __callInstance168.exports;
                                return __exports.data();
                            })();
                        });
                    }
                }
            });
            const __exports = __callInstance169.exports;
            return __exports.data();
        })();
    }
    function hasClass() {
        (() => {
            var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0;
            const __forInstance6 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key4 < _len4 ? 1 : 0;
                    },
                    update: () => {
                        _key4++;
                    },
                    body: () => {
                        classes[_key4] = arguments[_key4];
                    }
                }
            });
            const __exports = __forInstance6.exports;
            return __exports.data();
        })();
        const classNames = arrayFlat(classes.map(c => c.split(lS(0, 33))));
        return arrayFilter(this, el => classNames.filter(className => el.classList.contains(className)).length > 0).length > 0;
    }
    function attr(attrs, value) {
        if (1 === arguments.length && lS(0, 34) == typeof attrs)
            return this[0] ? this[0].getAttribute(attrs) : void 0;
        (() => {
            let i = 0;
            const __forInstance7 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        (() => {
                                            const __callInstance166 = new WebAssembly.Instance(__callWasmModule, {
                                                env: {
                                                    impFunc: () => {
                                                        this[i].setAttribute(attrs, value);
                                                    }
                                                }
                                            });
                                            const __exports = __callInstance166.exports;
                                            return __exports.data();
                                        })();
                                    },
                                    impFunc2: () => {
                                        for (const attrName in attrs)
                                            this[i][attrName] = attrs[attrName], this[i].setAttribute(attrName, attrs[attrName]);
                                    }
                                }
                            });
                            const __exports = __ifInstance1.exports;
                            return __exports.data(2 === arguments.length ? 1 : 0);
                        })();
                    }
                }
            });
            const __exports = __forInstance7.exports;
            return __exports.data();
        })();
        return this;
    }
    function removeAttr(attr) {
        (() => {
            let i = 0;
            const __forInstance8 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __callInstance165 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        this[i].removeAttribute(attr);
                                    }
                                }
                            });
                            const __exports = __callInstance165.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __forInstance8.exports;
            return __exports.data();
        })();
        return this;
    }
    function transform(transform) {
        (() => {
            let i = 0;
            const __forInstance9 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        this[i].style.transform = transform;
                    }
                }
            });
            const __exports = __forInstance9.exports;
            return __exports.data();
        })();
        return this;
    }
    function transition$1(duration) {
        (() => {
            let i = 0;
            const __forInstance10 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        this[i].style.transitionDuration = lS(0, 35) != typeof duration ? `${ duration }ms` : duration;
                    }
                }
            });
            const __exports = __forInstance10.exports;
            return __exports.data();
        })();
        return this;
    }
    function on() {
        (() => {
            var _len5 = arguments.length, args = new Array(_len5), _key5 = 0;
            const __forInstance11 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key5 < _len5 ? 1 : 0;
                    },
                    update: () => {
                        _key5++;
                    },
                    body: () => {
                        args[_key5] = arguments[_key5];
                    }
                }
            });
            const __exports = __forInstance11.exports;
            return __exports.data();
        })();
        let [eventType, targetSelector, listener, capture] = args;
        function handleLiveEvent(e) {
            const target = e.target;
            if (!target)
                return;
            const eventData = e.target.dom7EventData || [];
            (() => {
                const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            (() => {
                                const __callInstance164 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            listener.apply(target, eventData);
                                        }
                                    }
                                });
                                const __exports = __callInstance164.exports;
                                return __exports.data();
                            })();
                        },
                        impFunc2: () => {
                            {
                                const parents = $(target).parents();
                                (() => {
                                    let k = 0;
                                    const __forInstance12 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return k < parents.length ? 1 : 0;
                                            },
                                            update: () => {
                                                k += 1;
                                            },
                                            body: () => {
                                                $(parents[k]).is(targetSelector) && listener.apply(parents[k], eventData);
                                            }
                                        }
                                    });
                                    const __exports = __forInstance12.exports;
                                    return __exports.data();
                                })();
                            }
                        }
                    }
                });
                const __exports = __ifInstance2.exports;
                return __exports.data((eventData.indexOf(e) < 0 && eventData.unshift(e), $(target).is(targetSelector)) ? 1 : 0);
            })();
        }
        function handleEvent(e) {
            const eventData = e && e.target && e.target.dom7EventData || [];
            eventData.indexOf(e) < 0 && eventData.unshift(e), listener.apply(this, eventData);
        }
        lS(0, 36) == typeof args[1] && ([eventType, listener, capture] = args, targetSelector = void 0), capture || (capture = !1);
        const events = eventType.split(lS(0, 37));
        let j;
        (() => {
            let i = 0;
            const __forInstance13 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const el = this[i];
                            (() => {
                                const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            for (j = 0; j < events.length; j += 1) {
                                                const event = events[j];
                                                el.dom7LiveListeners || (el.dom7LiveListeners = {}), el.dom7LiveListeners[event] || (el.dom7LiveListeners[event] = []), el.dom7LiveListeners[event].push({
                                                    listener: listener,
                                                    proxyListener: handleLiveEvent
                                                }), el.addEventListener(event, handleLiveEvent, capture);
                                            }
                                        },
                                        impFunc2: () => {
                                            for (j = 0; j < events.length; j += 1) {
                                                const event = events[j];
                                                el.dom7Listeners || (el.dom7Listeners = {}), el.dom7Listeners[event] || (el.dom7Listeners[event] = []), el.dom7Listeners[event].push({
                                                    listener: listener,
                                                    proxyListener: handleEvent
                                                }), el.addEventListener(event, handleEvent, capture);
                                            }
                                        }
                                    }
                                });
                                const __exports = __ifInstance3.exports;
                                return __exports.data(targetSelector ? 1 : 0);
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance13.exports;
            return __exports.data();
        })();
        return this;
    }
    function off() {
        (() => {
            var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;
            const __forInstance16 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key6 < _len6 ? 1 : 0;
                    },
                    update: () => {
                        _key6++;
                    },
                    body: () => {
                        args[_key6] = arguments[_key6];
                    }
                }
            });
            const __exports = __forInstance16.exports;
            return __exports.data();
        })();
        let [eventType, targetSelector, listener, capture] = args;
        lS(0, 38) == typeof args[1] && ([eventType, listener, capture] = args, targetSelector = void 0), capture || (capture = !1);
        const events = eventType.split(lS(0, 39));
        (() => {
            let i = 0;
            const __forInstance17 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < events.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const event = events[i];
                            (() => {
                                let j = 0;
                                const __forInstance18 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return j < this.length ? 1 : 0;
                                        },
                                        update: () => {
                                            j += 1;
                                        },
                                        body: () => {
                                            {
                                                const el = this[j];
                                                let handlers;
                                                (() => {
                                                    const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                                                        env: {
                                                            impFunc1: () => {
                                                                for (let k = handlers.length - 1; k >= 0; k -= 1) {
                                                                    const handler = handlers[k];
                                                                    listener && handler.listener === listener ? (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1)) : listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener ? (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1)) : listener || (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1));
                                                                }
                                                            },
                                                            impFunc2: () => {
                                                            }
                                                        }
                                                    });
                                                    const __exports = __ifInstance4.exports;
                                                    return __exports.data((!targetSelector && el.dom7Listeners ? handlers = el.dom7Listeners[event] : targetSelector && el.dom7LiveListeners && (handlers = el.dom7LiveListeners[event]), handlers && handlers.length) ? 1 : 0);
                                                })();
                                            }
                                        }
                                    }
                                });
                                const __exports = __forInstance18.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance17.exports;
            return __exports.data();
        })();
        return this;
    }
    function trigger() {
        const window = getWindow();
        (() => {
            var _len9 = arguments.length, args = new Array(_len9), _key9 = 0;
            const __forInstance20 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return _key9 < _len9 ? 1 : 0;
                    },
                    update: () => {
                        _key9++;
                    },
                    body: () => {
                        args[_key9] = arguments[_key9];
                    }
                }
            });
            const __exports = __forInstance20.exports;
            return __exports.data();
        })();
        const events = args[0].split(lS(0, 40)), eventData = args[1];
        (() => {
            let i = 0;
            const __forInstance21 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < events.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const event = events[i];
                            (() => {
                                let j = 0;
                                const __forInstance22 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return j < this.length ? 1 : 0;
                                        },
                                        update: () => {
                                            j += 1;
                                        },
                                        body: () => {
                                            {
                                                const el = this[j];
                                                (() => {
                                                    const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
                                                        env: {
                                                            impFunc1: () => {
                                                                {
                                                                    const evt = new window.CustomEvent(event, {
                                                                        detail: eventData,
                                                                        bubbles: !0,
                                                                        cancelable: !0
                                                                    });
                                                                    el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0), el.dispatchEvent(evt), el.dom7EventData = [], delete el.dom7EventData;
                                                                }
                                                            },
                                                            impFunc2: () => {
                                                            }
                                                        }
                                                    });
                                                    const __exports = __ifInstance5.exports;
                                                    return __exports.data(window.CustomEvent ? 1 : 0);
                                                })();
                                            }
                                        }
                                    }
                                });
                                const __exports = __forInstance22.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance21.exports;
            return __exports.data();
        })();
        return this;
    }
    function transitionEnd$1(callback) {
        const dom = this;
        function fireCallBack(e) {
            e.target === this && (callback.call(this, e), dom.off(lS(0, 41), fireCallBack));
        }
        return callback && dom.on(lS(0, 42), fireCallBack), this;
    }
    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue(lS(0, 43))) + parseFloat(styles.getPropertyValue(lS(0, 44)));
            }
            return this[0].offsetWidth;
        }
        return null;
    }
    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue(lS(0, 45))) + parseFloat(styles.getPropertyValue(lS(0, 46)));
            }
            return this[0].offsetHeight;
        }
        return null;
    }
    function offset() {
        if (this.length > 0) {
            const window = getWindow(), document = getDocument(), el = this[0], box = el.getBoundingClientRect(), body = document.body, clientTop = el.clientTop || body.clientTop || 0, clientLeft = el.clientLeft || body.clientLeft || 0, scrollTop = el === window ? window.scrollY : el.scrollTop, scrollLeft = el === window ? window.scrollX : el.scrollLeft;
            return {
                top: box.top + scrollTop - clientTop,
                left: box.left + scrollLeft - clientLeft
            };
        }
        return null;
    }
    function styles() {
        const window = getWindow();
        return this[0] ? window.getComputedStyle(this[0], null) : {};
    }
    function css(props, value) {
        const window = getWindow();
        let i;
        if (1 === arguments.length) {
            if (lS(0, 47) != typeof props) {
                (() => {
                    i = 0;
                    const __forInstance23 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < this.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                for (const prop in props)
                                    this[i].style[prop] = props[prop];
                            }
                        }
                    });
                    const __exports = __forInstance23.exports;
                    return __exports.data();
                })();
                return this;
            }
            if (this[0])
                return window.getComputedStyle(this[0], null).getPropertyValue(props);
        }
        if (2 === arguments.length && lS(0, 48) == typeof props) {
            (() => {
                i = 0;
                const __forInstance24 = new WebAssembly.Instance(__forWasmModule, {
                    env: {
                        test: () => {
                            return i < this.length ? 1 : 0;
                        },
                        update: () => {
                            i += 1;
                        },
                        body: () => {
                            this[i].style[props] = value;
                        }
                    }
                });
                const __exports = __forInstance24.exports;
                return __exports.data();
            })();
            return this;
        }
        return this;
    }
    function each(callback) {
        return callback ? (this.forEach((el, index) => {
            (() => {
                const __callInstance163 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            callback.apply(el, [
                                el,
                                index
                            ]);
                        }
                    }
                });
                const __exports = __callInstance163.exports;
                return __exports.data();
            })();
        }), this) : this;
    }
    function filter(callback) {
        const result = arrayFilter(this, callback);
        return $(result);
    }
    function html(html) {
        if (void 0 === html)
            return this[0] ? this[0].innerHTML : null;
        (() => {
            let i = 0;
            const __forInstance25 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        this[i].innerHTML = html;
                    }
                }
            });
            const __exports = __forInstance25.exports;
            return __exports.data();
        })();
        return this;
    }
    function text(text) {
        if (void 0 === text)
            return this[0] ? this[0].textContent.trim() : null;
        (() => {
            let i = 0;
            const __forInstance26 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        this[i].textContent = text;
                    }
                }
            });
            const __exports = __forInstance26.exports;
            return __exports.data();
        })();
        return this;
    }
    function is(selector) {
        const window = getWindow(), document = getDocument(), el = this[0];
        let compareWith, i;
        if (!el || void 0 === selector)
            return !1;
        if (lS(0, 49) == typeof selector) {
            if (el.matches)
                return el.matches(selector);
            if (el.webkitMatchesSelector)
                return el.webkitMatchesSelector(selector);
            if (el.msMatchesSelector)
                return el.msMatchesSelector(selector);
            for (compareWith = $(selector), i = 0; i < compareWith.length; i += 1)
                if (compareWith[i] === el)
                    return !0;
            return !1;
        }
        if (selector === document)
            return el === document;
        if (selector === window)
            return el === window;
        if (selector.nodeType || selector instanceof Dom7) {
            for (compareWith = selector.nodeType ? [selector] : selector, i = 0; i < compareWith.length; i += 1)
                if (compareWith[i] === el)
                    return !0;
            return !1;
        }
        return !1;
    }
    function index() {
        let child = this[0], i;
        if (child) {
            (() => {
                i = 0;
                const __forInstance27 = new WebAssembly.Instance(__forWasmModule, {
                    env: {
                        test: () => {
                            return null !== (child = child.previousSibling) ? 1 : 0;
                        },
                        update: () => {
                        },
                        body: () => {
                            1 === child.nodeType && (i += 1);
                        }
                    }
                });
                const __exports = __forInstance27.exports;
                return __exports.data();
            })();
            return i;
        }
    }
    function eq(index) {
        if (void 0 === index)
            return this;
        const length = this.length;
        if (index > length - 1)
            return $([]);
        if (index < 0) {
            const returnIndex = length + index;
            return $(returnIndex < 0 ? [] : [this[returnIndex]]);
        }
        return $([this[index]]);
    }
    function append() {
        let newChild;
        const document = getDocument();
        (() => {
            let k = 0;
            const __forInstance28 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return k < arguments.length ? 1 : 0;
                    },
                    update: () => {
                        k += 1;
                    },
                    body: () => {
                        {
                            newChild = k < 0 || arguments.length <= k ? void 0 : arguments[k];
                            (() => {
                                let i = 0;
                                const __forInstance29 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return i < this.length ? 1 : 0;
                                        },
                                        update: () => {
                                            i += 1;
                                        },
                                        body: () => {
                                            (() => {
                                                const __ifInstance6 = new WebAssembly.Instance(__ifWasmModule, {
                                                    env: {
                                                        impFunc1: () => {
                                                            {
                                                                const tempDiv = document.createElement(lS(0, 51));
                                                                (() => {
                                                                    tempDiv.innerHTML = newChild;
                                                                    const __forInstance30 = new WebAssembly.Instance(__forWasmModule, {
                                                                        env: {
                                                                            test: () => {
                                                                                return tempDiv.firstChild ? 1 : 0;
                                                                            },
                                                                            update: () => {
                                                                            },
                                                                            body: () => {
                                                                                (() => {
                                                                                    const __callInstance162 = new WebAssembly.Instance(__callWasmModule, {
                                                                                        env: {
                                                                                            impFunc: () => {
                                                                                                this[i].appendChild(tempDiv.firstChild);
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                    const __exports = __callInstance162.exports;
                                                                                    return __exports.data();
                                                                                })();
                                                                            }
                                                                        }
                                                                    });
                                                                    const __exports = __forInstance30.exports;
                                                                    return __exports.data();
                                                                })();
                                                            }
                                                        },
                                                        impFunc2: () => {
                                                            (() => {
                                                                const __ifInstance7 = new WebAssembly.Instance(__ifWasmModule, {
                                                                    env: {
                                                                        impFunc1: () => {
                                                                            for (let j = 0; j < newChild.length; j += 1)
                                                                                (() => {
                                                                                    const __callInstance161 = new WebAssembly.Instance(__callWasmModule, {
                                                                                        env: {
                                                                                            impFunc: () => {
                                                                                                this[i].appendChild(newChild[j]);
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                    const __exports = __callInstance161.exports;
                                                                                    return __exports.data();
                                                                                })();
                                                                        },
                                                                        impFunc2: () => {
                                                                            (() => {
                                                                                const __callInstance160 = new WebAssembly.Instance(__callWasmModule, {
                                                                                    env: {
                                                                                        impFunc: () => {
                                                                                            this[i].appendChild(newChild);
                                                                                        }
                                                                                    }
                                                                                });
                                                                                const __exports = __callInstance160.exports;
                                                                                return __exports.data();
                                                                            })();
                                                                        }
                                                                    }
                                                                });
                                                                const __exports = __ifInstance7.exports;
                                                                return __exports.data(newChild instanceof Dom7 ? 1 : 0);
                                                            })();
                                                        }
                                                    }
                                                });
                                                const __exports = __ifInstance6.exports;
                                                return __exports.data(lS(0, 50) == typeof newChild ? 1 : 0);
                                            })();
                                        }
                                    }
                                });
                                const __exports = __forInstance29.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance28.exports;
            return __exports.data();
        })();
        return this;
    }
    function prepend(newChild) {
        const document = getDocument();
        let i, j;
        (() => {
            i = 0;
            const __forInstance32 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __ifInstance8 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            const tempDiv = document.createElement(lS(0, 53));
                                            (() => {
                                                tempDiv.innerHTML = newChild, j = tempDiv.childNodes.length - 1;
                                                const __forInstance33 = new WebAssembly.Instance(__forWasmModule, {
                                                    env: {
                                                        test: () => {
                                                            return j >= 0 ? 1 : 0;
                                                        },
                                                        update: () => {
                                                            j -= 1;
                                                        },
                                                        body: () => {
                                                            (() => {
                                                                const __callInstance159 = new WebAssembly.Instance(__callWasmModule, {
                                                                    env: {
                                                                        impFunc: () => {
                                                                            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                                                                        }
                                                                    }
                                                                });
                                                                const __exports = __callInstance159.exports;
                                                                return __exports.data();
                                                            })();
                                                        }
                                                    }
                                                });
                                                const __exports = __forInstance33.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    },
                                    impFunc2: () => {
                                        (() => {
                                            const __ifInstance9 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        for (j = 0; j < newChild.length; j += 1)
                                                            (() => {
                                                                const __callInstance158 = new WebAssembly.Instance(__callWasmModule, {
                                                                    env: {
                                                                        impFunc: () => {
                                                                            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                                                                        }
                                                                    }
                                                                });
                                                                const __exports = __callInstance158.exports;
                                                                return __exports.data();
                                                            })();
                                                    },
                                                    impFunc2: () => {
                                                        (() => {
                                                            const __callInstance157 = new WebAssembly.Instance(__callWasmModule, {
                                                                env: {
                                                                    impFunc: () => {
                                                                        this[i].insertBefore(newChild, this[i].childNodes[0]);
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __callInstance157.exports;
                                                            return __exports.data();
                                                        })();
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance9.exports;
                                            return __exports.data(newChild instanceof Dom7 ? 1 : 0);
                                        })();
                                    }
                                }
                            });
                            const __exports = __ifInstance8.exports;
                            return __exports.data(lS(0, 52) == typeof newChild ? 1 : 0);
                        })();
                    }
                }
            });
            const __exports = __forInstance32.exports;
            return __exports.data();
        })();
        return this;
    }
    function next(selector) {
        return this.length > 0 ? selector ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector) ? $([this[0].nextElementSibling]) : $([]) : this[0].nextElementSibling ? $([this[0].nextElementSibling]) : $([]) : $([]);
    }
    function nextAll(selector) {
        const nextEls = [];
        let el = this[0];
        if (!el)
            return $([]);
        (() => {
            const __forInstance35 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return el.nextElementSibling ? 1 : 0;
                    },
                    update: () => {
                    },
                    body: () => {
                        {
                            const next = el.nextElementSibling;
                            selector ? $(next).is(selector) && nextEls.push(next) : nextEls.push(next), el = next;
                        }
                    }
                }
            });
            const __exports = __forInstance35.exports;
            return __exports.data();
        })();
        return $(nextEls);
    }
    function prev(selector) {
        if (this.length > 0) {
            const el = this[0];
            return selector ? el.previousElementSibling && $(el.previousElementSibling).is(selector) ? $([el.previousElementSibling]) : $([]) : el.previousElementSibling ? $([el.previousElementSibling]) : $([]);
        }
        return $([]);
    }
    function prevAll(selector) {
        const prevEls = [];
        let el = this[0];
        if (!el)
            return $([]);
        (() => {
            const __forInstance36 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return el.previousElementSibling ? 1 : 0;
                    },
                    update: () => {
                    },
                    body: () => {
                        {
                            const prev = el.previousElementSibling;
                            selector ? $(prev).is(selector) && prevEls.push(prev) : prevEls.push(prev), el = prev;
                        }
                    }
                }
            });
            const __exports = __forInstance36.exports;
            return __exports.data();
        })();
        return $(prevEls);
    }
    function parent(selector) {
        const parents = [];
        (() => {
            let i = 0;
            const __forInstance37 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        null !== this[i].parentNode && (selector ? $(this[i].parentNode).is(selector) && parents.push(this[i].parentNode) : parents.push(this[i].parentNode));
                    }
                }
            });
            const __exports = __forInstance37.exports;
            return __exports.data();
        })();
        return $(parents);
    }
    function parents(selector) {
        const parents = [];
        (() => {
            let i = 0;
            const __forInstance38 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            let parent = this[i].parentNode;
                            (() => {
                                const __forInstance39 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return parent ? 1 : 0;
                                        },
                                        update: () => {
                                        },
                                        body: () => {
                                            selector ? $(parent).is(selector) && parents.push(parent) : parents.push(parent), parent = parent.parentNode;
                                        }
                                    }
                                });
                                const __exports = __forInstance39.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance38.exports;
            return __exports.data();
        })();
        return $(parents);
    }
    function closest(selector) {
        let closest = this;
        return void 0 === selector ? $([]) : (closest.is(selector) || (closest = closest.parents(selector).eq(0)), closest);
    }
    function find(selector) {
        const foundElements = [];
        (() => {
            let i = 0;
            const __forInstance40 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const found = this[i].querySelectorAll(selector);
                            (() => {
                                let j = 0;
                                const __forInstance41 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return j < found.length ? 1 : 0;
                                        },
                                        update: () => {
                                            j += 1;
                                        },
                                        body: () => {
                                            (() => {
                                                const __callInstance156 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            foundElements.push(found[j]);
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance156.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                });
                                const __exports = __forInstance41.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance40.exports;
            return __exports.data();
        })();
        return $(foundElements);
    }
    function children(selector) {
        const children = [];
        (() => {
            let i = 0;
            const __forInstance42 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const childNodes = this[i].children;
                            (() => {
                                let j = 0;
                                const __forInstance43 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return j < childNodes.length ? 1 : 0;
                                        },
                                        update: () => {
                                            j += 1;
                                        },
                                        body: () => {
                                            selector && !$(childNodes[j]).is(selector) || children.push(childNodes[j]);
                                        }
                                    }
                                });
                                const __exports = __forInstance43.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance42.exports;
            return __exports.data();
        })();
        return $(children);
    }
    function remove() {
        (() => {
            let i = 0;
            const __forInstance44 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < this.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        this[i].parentNode && this[i].parentNode.removeChild(this[i]);
                    }
                }
            });
            const __exports = __forInstance44.exports;
            return __exports.data();
        })();
        return this;
    }
    $.fn = Dom7.prototype;
    const Methods = {
        addClass: addClass,
        removeClass: removeClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        attr: attr,
        removeAttr: removeAttr,
        transform: transform,
        transition: transition$1,
        on: on,
        off: off,
        trigger: trigger,
        transitionEnd: transitionEnd$1,
        outerWidth: outerWidth,
        outerHeight: outerHeight,
        styles: styles,
        offset: offset,
        css: css,
        each: each,
        html: html,
        text: text,
        is: is,
        index: index,
        eq: eq,
        append: append,
        prepend: prepend,
        next: next,
        nextAll: nextAll,
        prev: prev,
        prevAll: prevAll,
        parent: parent,
        parents: parents,
        closest: closest,
        find: find,
        children: children,
        filter: filter,
        remove: remove
    };
    function deleteProps(obj) {
        const object = obj;
        (() => {
            const __callInstance155 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.keys(object).forEach(key => {
                            try {
                                object[key] = null;
                            } catch (e) {
                            }
                            try {
                                delete object[key];
                            } catch (e) {
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance155.exports;
            return __exports.data();
        })();
    }
    function nextTick(callback, delay) {
        return void 0 === delay && (delay = 0), setTimeout(callback, delay);
    }
    function now() {
        return Date.now();
    }
    function getComputedStyle$1(el) {
        const window = getWindow();
        let style;
        return window.getComputedStyle && (style = window.getComputedStyle(el, null)), !style && el.currentStyle && (style = el.currentStyle), style || (style = el.style), style;
    }
    function getTranslate(el, axis) {
        void 0 === axis && (axis = lS(0, 54));
        const window = getWindow();
        let matrix, curTransform, transformMatrix;
        const curStyle = getComputedStyle$1(el);
        return window.WebKitCSSMatrix ? (curTransform = curStyle.transform || curStyle.webkitTransform, curTransform.split(lS(0, 55)).length > 6 && (curTransform = curTransform.split(lS(0, 56)).map(a => a.replace(lS(0, 57), lS(0, 58))).join(lS(0, 59))), transformMatrix = new window.WebKitCSSMatrix(lS(0, 60) === curTransform ? lS(0, 61) : curTransform)) : (transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(lS(0, 62)).replace(lS(0, 63), lS(0, 64)), matrix = transformMatrix.toString().split(lS(0, 65))), lS(0, 66) === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m41 : 16 === matrix.length ? parseFloat(matrix[12]) : parseFloat(matrix[4])), lS(0, 67) === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m42 : 16 === matrix.length ? parseFloat(matrix[13]) : parseFloat(matrix[5])), curTransform || 0;
    }
    function isObject(o) {
        return lS(0, 68) == typeof o && null !== o && o.constructor && lS(0, 69) === Object.prototype.toString.call(o).slice(8, -1);
    }
    function isNode(node) {
        return lS(0, 70) != typeof window && void 0 !== window.HTMLElement ? node instanceof HTMLElement : node && (1 === node.nodeType || 11 === node.nodeType);
    }
    function extend() {
        const to = Object(arguments.length <= 0 ? void 0 : arguments[0]), noExtend = [
                lS(0, 71),
                lS(0, 72),
                lS(0, 73)
            ];
        (() => {
            let i = 1;
            const __forInstance45 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < arguments.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                            (() => {
                                const __ifInstance10 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                                                (() => {
                                                    let nextIndex = 0, len = keysArray.length;
                                                    const __forInstance46 = new WebAssembly.Instance(__forWasmModule, {
                                                        env: {
                                                            test: () => {
                                                                return nextIndex < len ? 1 : 0;
                                                            },
                                                            update: () => {
                                                                nextIndex += 1;
                                                            },
                                                            body: () => {
                                                                {
                                                                    const nextKey = keysArray[nextIndex], desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                                                                    void 0 !== desc && desc.enumerable && (isObject(to[nextKey]) && isObject(nextSource[nextKey]) ? nextSource[nextKey].__swiper__ ? to[nextKey] = nextSource[nextKey] : extend(to[nextKey], nextSource[nextKey]) : !isObject(to[nextKey]) && isObject(nextSource[nextKey]) ? (to[nextKey] = {}, nextSource[nextKey].__swiper__ ? to[nextKey] = nextSource[nextKey] : extend(to[nextKey], nextSource[nextKey])) : to[nextKey] = nextSource[nextKey]);
                                                                }
                                                            }
                                                        }
                                                    });
                                                    const __exports = __forInstance46.exports;
                                                    return __exports.data();
                                                })();
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance10.exports;
                                return __exports.data(null != nextSource && !isNode(nextSource) ? 1 : 0);
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance45.exports;
            return __exports.data();
        })();
        return to;
    }
    function setCSSProperty(el, varName, varValue) {
        (() => {
            const __callInstance154 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        el.style.setProperty(varName, varValue);
                    }
                }
            });
            const __exports = __callInstance154.exports;
            return __exports.data();
        })();
    }
    function animateCSSModeScroll(_ref) {
        let {
            swiper: swiper,
            targetPosition: targetPosition,
            side: side
        } = _ref;
        const window = getWindow(), startPosition = -swiper.translate;
        let startTime = null, time;
        const duration = swiper.params.speed;
        swiper.wrapperEl.style.scrollSnapType = lS(0, 74), window.cancelAnimationFrame(swiper.cssModeFrameID);
        const dir = targetPosition > startPosition ? lS(0, 75) : lS(0, 76), isOutOfBound = (current, target) => lS(0, 77) === dir && current >= target || lS(0, 78) === dir && current <= target, animate = () => {
                time = new Date().getTime(), null === startTime && (startTime = time);
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0), easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition) && (currentPosition = targetPosition), swiper.wrapperEl.scrollTo({ [side]: currentPosition }), isOutOfBound(currentPosition, targetPosition))
                    return swiper.wrapperEl.style.overflow = lS(0, 79), swiper.wrapperEl.style.scrollSnapType = lS(0, 80), setTimeout(() => {
                        swiper.wrapperEl.style.overflow = lS(0, 81), swiper.wrapperEl.scrollTo({ [side]: currentPosition });
                    }), void window.cancelAnimationFrame(swiper.cssModeFrameID);
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
        (() => {
            const __callInstance153 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        animate();
                    }
                }
            });
            const __exports = __callInstance153.exports;
            return __exports.data();
        })();
    }
    let support, deviceCached, browser;
    function calcSupport() {
        const window = getWindow(), document = getDocument();
        return {
            smoothScroll: document.documentElement && lS(0, 82) in document.documentElement.style,
            touch: !!(lS(0, 83) in window || window.DocumentTouch && document instanceof window.DocumentTouch),
            passiveListener: function checkPassiveListener() {
                let supportsPassive = !1;
                try {
                    const opts = Object.defineProperty({}, lS(0, 84), {
                        get() {
                            supportsPassive = !0;
                        }
                    });
                    (() => {
                        const __callInstance152 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    window.addEventListener(lS(0, 85), null, opts);
                                }
                            }
                        });
                        const __exports = __callInstance152.exports;
                        return __exports.data();
                    })();
                } catch (e) {
                }
                return supportsPassive;
            }(),
            gestures: function checkGestures() {
                return lS(0, 86) in window;
            }()
        };
    }
    function getSupport() {
        return support || (support = calcSupport()), support;
    }
    function calcDevice(_temp) {
        let {userAgent: userAgent} = void 0 === _temp ? {} : _temp;
        const support = getSupport(), window = getWindow(), platform = window.navigator.platform, ua = userAgent || window.navigator.userAgent, device = {
                ios: !1,
                android: !1
            }, screenWidth = window.screen.width, screenHeight = window.screen.height, android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/), iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/), windows = lS(0, 87) === platform;
        let macos = lS(0, 88) === platform;
        const iPadScreens = [
            lS(0, 89),
            lS(0, 90),
            lS(0, 91),
            lS(0, 92),
            lS(0, 93),
            lS(0, 94),
            lS(0, 95),
            lS(0, 96),
            lS(0, 97),
            lS(0, 98),
            lS(0, 99),
            lS(0, 100)
        ];
        return !ipad && macos && support.touch && iPadScreens.indexOf(`${ screenWidth }x${ screenHeight }`) >= 0 && (ipad = ua.match(/(Version)\/([\d.]+)/), ipad || (ipad = [
            0,
            1,
            lS(0, 101)
        ]), macos = !1), android && !windows && (device.os = lS(0, 102), device.android = !0), (ipad || iphone || ipod) && (device.os = lS(0, 103), device.ios = !0), device;
    }
    function getDevice(overrides) {
        return void 0 === overrides && (overrides = {}), deviceCached || (deviceCached = calcDevice(overrides)), deviceCached;
    }
    function calcBrowser() {
        const window = getWindow();
        function isSafari() {
            const ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf(lS(0, 104)) >= 0 && ua.indexOf(lS(0, 105)) < 0 && ua.indexOf(lS(0, 106)) < 0;
        }
        return {
            isSafari: isSafari(),
            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
        };
    }
    function getBrowser() {
        return browser || (browser = calcBrowser()), browser;
    }
    function Resize(_ref) {
        let {
            swiper: swiper,
            on: on,
            emit: emit
        } = _ref;
        const window = getWindow();
        let observer = null, animationFrame = null;
        const resizeHandler = () => {
                swiper && !swiper.destroyed && swiper.initialized && (emit(lS(0, 107)), emit(lS(0, 108)));
            }, createObserver = () => {
                swiper && !swiper.destroyed && swiper.initialized && (observer = new ResizeObserver(entries => {
                    animationFrame = window.requestAnimationFrame(() => {
                        const {
                            width: width,
                            height: height
                        } = swiper;
                        let newWidth = width, newHeight = height;
                        entries.forEach(_ref2 => {
                            let {
                                contentBoxSize: contentBoxSize,
                                contentRect: contentRect,
                                target: target
                            } = _ref2;
                            target && target !== swiper.el || (newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize, newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize);
                        }), newWidth === width && newHeight === height || resizeHandler();
                    });
                }), observer.observe(swiper.el));
            }, removeObserver = () => {
                animationFrame && window.cancelAnimationFrame(animationFrame), observer && observer.unobserve && swiper.el && (observer.unobserve(swiper.el), observer = null);
            }, orientationChangeHandler = () => {
                swiper && !swiper.destroyed && swiper.initialized && emit(lS(0, 109));
            };
        on(lS(0, 110), () => {
            swiper.params.resizeObserver && void 0 !== window.ResizeObserver ? createObserver() : (window.addEventListener(lS(0, 111), resizeHandler), window.addEventListener(lS(0, 112), orientationChangeHandler));
        }), on(lS(0, 113), () => {
            removeObserver(), window.removeEventListener(lS(0, 114), resizeHandler), window.removeEventListener(lS(0, 115), orientationChangeHandler);
        });
    }
    function Observer(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        const observers = [], window = getWindow(), attach = function (target, options) {
                void 0 === options && (options = {});
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver, observer = new ObserverFunc(mutations => {
                        if (1 === mutations.length)
                            return void emit(lS(0, 116), mutations[0]);
                        const observerUpdate = function observerUpdate() {
                            (() => {
                                const __callInstance151 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            emit(lS(0, 117), mutations[0]);
                                        }
                                    }
                                });
                                const __exports = __callInstance151.exports;
                                return __exports.data();
                            })();
                        };
                        window.requestAnimationFrame ? window.requestAnimationFrame(observerUpdate) : window.setTimeout(observerUpdate, 0);
                    });
                observer.observe(target, {
                    attributes: void 0 === options.attributes || options.attributes,
                    childList: void 0 === options.childList || options.childList,
                    characterData: void 0 === options.characterData || options.characterData
                }), observers.push(observer);
            }, init = () => {
                (() => {
                    const __ifInstance11 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    (() => {
                                        const __ifInstance12 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        const containerParents = swiper.$el.parents();
                                                        (() => {
                                                            let i = 0;
                                                            const __forInstance47 = new WebAssembly.Instance(__forWasmModule, {
                                                                env: {
                                                                    test: () => {
                                                                        return i < containerParents.length ? 1 : 0;
                                                                    },
                                                                    update: () => {
                                                                        i += 1;
                                                                    },
                                                                    body: () => {
                                                                        (() => {
                                                                            const __callInstance150 = new WebAssembly.Instance(__callWasmModule, {
                                                                                env: {
                                                                                    impFunc: () => {
                                                                                        attach(containerParents[i]);
                                                                                    }
                                                                                }
                                                                            });
                                                                            const __exports = __callInstance150.exports;
                                                                            return __exports.data();
                                                                        })();
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __forInstance47.exports;
                                                            return __exports.data();
                                                        })();
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance12.exports;
                                        return __exports.data(swiper.params.observeParents ? 1 : 0);
                                    })();
                                    attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren }), attach(swiper.$wrapperEl[0], { attributes: !1 });
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance11.exports;
                    return __exports.data(swiper.params.observer ? 1 : 0);
                })();
            }, destroy = () => {
                observers.forEach(observer => {
                    (() => {
                        const __callInstance149 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    observer.disconnect();
                                }
                            }
                        });
                        const __exports = __callInstance149.exports;
                        return __exports.data();
                    })();
                }), observers.splice(0, observers.length);
            };
        extendParams({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }), on(lS(0, 118), init), on(lS(0, 119), destroy);
    }
    (() => {
        const __callInstance148 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    Object.keys(Methods).forEach(methodName => {
                        (() => {
                            const __callInstance147 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        Object.defineProperty($.fn, methodName, {
                                            value: Methods[methodName],
                                            writable: !0
                                        });
                                    }
                                }
                            });
                            const __exports = __callInstance147.exports;
                            return __exports.data();
                        })();
                    });
                }
            }
        });
        const __exports = __callInstance148.exports;
        return __exports.data();
    })();
    var eventsEmitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed)
                    return self;
                if (lS(0, 120) != typeof handler)
                    return self;
                const method = priority ? lS(0, 121) : lS(0, 122);
                return events.split(lS(0, 123)).forEach(event => {
                    self.eventsListeners[event] || (self.eventsListeners[event] = []), self.eventsListeners[event][method](handler);
                }), self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed)
                    return self;
                if (lS(0, 124) != typeof handler)
                    return self;
                function onceHandler() {
                    self.off(events, onceHandler), onceHandler.__emitterProxy && delete onceHandler.__emitterProxy;
                    (() => {
                        var _len = arguments.length, args = new Array(_len), _key = 0;
                        const __forInstance48 = new WebAssembly.Instance(__forWasmModule, {
                            env: {
                                test: () => {
                                    return _key < _len ? 1 : 0;
                                },
                                update: () => {
                                    _key++;
                                },
                                body: () => {
                                    args[_key] = arguments[_key];
                                }
                            }
                        });
                        const __exports = __forInstance48.exports;
                        return __exports.data();
                    })();
                    (() => {
                        const __callInstance146 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    handler.apply(self, args);
                                }
                            }
                        });
                        const __exports = __callInstance146.exports;
                        return __exports.data();
                    })();
                }
                return onceHandler.__emitterProxy = handler, self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed)
                    return self;
                if (lS(0, 125) != typeof handler)
                    return self;
                const method = priority ? lS(0, 126) : lS(0, 127);
                return self.eventsAnyListeners.indexOf(handler) < 0 && self.eventsAnyListeners[method](handler), self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed)
                    return self;
                if (!self.eventsAnyListeners)
                    return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                return index >= 0 && self.eventsAnyListeners.splice(index, 1), self;
            },
            off(events, handler) {
                const self = this;
                return !self.eventsListeners || self.destroyed ? self : self.eventsListeners ? (events.split(lS(0, 128)).forEach(event => {
                    void 0 === handler ? self.eventsListeners[event] = [] : self.eventsListeners[event] && self.eventsListeners[event].forEach((eventHandler, index) => {
                        (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) && self.eventsListeners[event].splice(index, 1);
                    });
                }), self) : self;
            },
            emit() {
                const self = this;
                if (!self.eventsListeners || self.destroyed)
                    return self;
                if (!self.eventsListeners)
                    return self;
                let events, data, context;
                (() => {
                    var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
                    const __forInstance49 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return _key2 < _len2 ? 1 : 0;
                            },
                            update: () => {
                                _key2++;
                            },
                            body: () => {
                                args[_key2] = arguments[_key2];
                            }
                        }
                    });
                    const __exports = __forInstance49.exports;
                    return __exports.data();
                })();
                lS(0, 129) == typeof args[0] || Array.isArray(args[0]) ? (events = args[0], data = args.slice(1, args.length), context = self) : (events = args[0].events, data = args[0].data, context = args[0].context || self), data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(lS(0, 130));
                return eventsArray.forEach(event => {
                    self.eventsAnyListeners && self.eventsAnyListeners.length && self.eventsAnyListeners.forEach(eventHandler => {
                        (() => {
                            const __callInstance145 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        eventHandler.apply(context, [
                                            event,
                                            ...data
                                        ]);
                                    }
                                }
                            });
                            const __exports = __callInstance145.exports;
                            return __exports.data();
                        })();
                    }), self.eventsListeners && self.eventsListeners[event] && self.eventsListeners[event].forEach(eventHandler => {
                        (() => {
                            const __callInstance144 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        eventHandler.apply(context, data);
                                    }
                                }
                            });
                            const __exports = __callInstance144.exports;
                            return __exports.data();
                        })();
                    });
                }), self;
            }
        }, update, translate, transition, slide, loop, grabCursor;
    function updateSize() {
        const swiper = this;
        let width, height;
        const $el = swiper.$el;
        width = void 0 !== swiper.params.width && null !== swiper.params.width ? swiper.params.width : $el[0].clientWidth, height = void 0 !== swiper.params.height && null !== swiper.params.height ? swiper.params.height : $el[0].clientHeight, 0 === width && swiper.isHorizontal() || 0 === height && swiper.isVertical() || (width = width - parseInt($el.css(lS(0, 131)) || 0, 10) - parseInt($el.css(lS(0, 132)) || 0, 10), height = height - parseInt($el.css(lS(0, 133)) || 0, 10) - parseInt($el.css(lS(0, 134)) || 0, 10), Number.isNaN(width) && (width = 0), Number.isNaN(height) && (height = 0), Object.assign(swiper, {
            width: width,
            height: height,
            size: swiper.isHorizontal() ? width : height
        }));
    }
    function updateSlides() {
        const swiper = this;
        function getDirectionLabel(property) {
            return swiper.isHorizontal() ? property : {
                width: 'height',
                'margin-top': 'margin-left',
                'margin-bottom ': 'margin-right',
                'margin-left': 'margin-top',
                'margin-right': 'margin-bottom',
                'padding-left': 'padding-top',
                'padding-right': 'padding-bottom',
                marginRight: 'marginBottom'
            }[property];
        }
        function getDirectionPropertyValue(node, label) {
            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
        }
        const params = swiper.params, {
                $wrapperEl: $wrapperEl,
                size: swiperSize,
                rtlTranslate: rtl,
                wrongRTL: wrongRTL
            } = swiper, isVirtual = swiper.virtual && params.virtual.enabled, previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length, slides = $wrapperEl.children(`.${ swiper.params.slideClass }`), slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        let snapGrid = [];
        const slidesGrid = [], slidesSizesGrid = [];
        let offsetBefore = params.slidesOffsetBefore;
        lS(0, 135) == typeof offsetBefore && (offsetBefore = params.slidesOffsetBefore.call(swiper));
        let offsetAfter = params.slidesOffsetAfter;
        lS(0, 136) == typeof offsetAfter && (offsetAfter = params.slidesOffsetAfter.call(swiper));
        const previousSnapGridLength = swiper.snapGrid.length, previousSlidesGridLength = swiper.slidesGrid.length;
        let spaceBetween = params.spaceBetween, slidePosition = -offsetBefore, prevSlideSize = 0, index = 0;
        if (void 0 === swiperSize)
            return;
        lS(0, 137) == typeof spaceBetween && spaceBetween.indexOf(lS(0, 138)) >= 0 && (spaceBetween = parseFloat(spaceBetween.replace(lS(0, 139), lS(0, 140))) / 100 * swiperSize), swiper.virtualSize = -spaceBetween, rtl ? slides.css({
            marginLeft: '',
            marginBottom: '',
            marginTop: ''
        }) : slides.css({
            marginRight: '',
            marginBottom: '',
            marginTop: ''
        }), params.centeredSlides && params.cssMode && (setCSSProperty(swiper.wrapperEl, lS(0, 141), lS(0, 142)), setCSSProperty(swiper.wrapperEl, lS(0, 143), lS(0, 144)));
        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
        let slideSize;
        gridEnabled && swiper.grid.initSlides(slidesLength);
        const shouldResetSlideSize = lS(0, 145) === params.slidesPerView && params.breakpoints && Object.keys(params.breakpoints).filter(key => void 0 !== params.breakpoints[key].slidesPerView).length > 0;
        (() => {
            let i = 0;
            const __forInstance50 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < slidesLength ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            slideSize = 0;
                            const slide = slides.eq(i);
                            (() => {
                                const __ifInstance13 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                (() => {
                                                    const __ifInstance14 = new WebAssembly.Instance(__ifWasmModule, {
                                                        env: {
                                                            impFunc1: () => {
                                                                {
                                                                    shouldResetSlideSize && (slides[i].style[getDirectionLabel(lS(0, 149))] = lS(0, 150));
                                                                    const slideStyles = getComputedStyle(slide[0]), currentTransform = slide[0].style.transform, currentWebKitTransform = slide[0].style.webkitTransform;
                                                                    (() => {
                                                                        const __ifInstance15 = new WebAssembly.Instance(__ifWasmModule, {
                                                                            env: {
                                                                                impFunc1: () => {
                                                                                    slideSize = swiper.isHorizontal() ? slide.outerWidth(!0) : slide.outerHeight(!0);
                                                                                },
                                                                                impFunc2: () => {
                                                                                    {
                                                                                        const width = getDirectionPropertyValue(slideStyles, lS(0, 153)), paddingLeft = getDirectionPropertyValue(slideStyles, lS(0, 154)), paddingRight = getDirectionPropertyValue(slideStyles, lS(0, 155)), marginLeft = getDirectionPropertyValue(slideStyles, lS(0, 156)), marginRight = getDirectionPropertyValue(slideStyles, lS(0, 157)), boxSizing = slideStyles.getPropertyValue(lS(0, 158));
                                                                                        (() => {
                                                                                            const __ifInstance16 = new WebAssembly.Instance(__ifWasmModule, {
                                                                                                env: {
                                                                                                    impFunc1: () => {
                                                                                                        slideSize = width + marginLeft + marginRight;
                                                                                                    },
                                                                                                    impFunc2: () => {
                                                                                                        {
                                                                                                            const {
                                                                                                                clientWidth: clientWidth,
                                                                                                                offsetWidth: offsetWidth
                                                                                                            } = slide[0];
                                                                                                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            });
                                                                                            const __exports = __ifInstance16.exports;
                                                                                            return __exports.data(boxSizing && lS(0, 159) === boxSizing ? 1 : 0);
                                                                                        })();
                                                                                    }
                                                                                }
                                                                            }
                                                                        });
                                                                        const __exports = __ifInstance15.exports;
                                                                        return __exports.data((currentTransform && (slide[0].style.transform = lS(0, 151)), currentWebKitTransform && (slide[0].style.webkitTransform = lS(0, 152)), params.roundLengths) ? 1 : 0);
                                                                    })();
                                                                    currentTransform && (slide[0].style.transform = currentTransform), currentWebKitTransform && (slide[0].style.webkitTransform = currentWebKitTransform), params.roundLengths && (slideSize = Math.floor(slideSize));
                                                                }
                                                            },
                                                            impFunc2: () => {
                                                                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView, params.roundLengths && (slideSize = Math.floor(slideSize)), slides[i] && (slides[i].style[getDirectionLabel(lS(0, 160))] = `${ slideSize }px`);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __ifInstance14.exports;
                                                    return __exports.data(lS(0, 148) === params.slidesPerView ? 1 : 0);
                                                })();
                                                slides[i] && (slides[i].swiperSlideSize = slideSize), slidesSizesGrid.push(slideSize), params.centeredSlides ? (slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween, 0 === prevSlideSize && 0 !== i && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), 0 === i && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), Math.abs(slidePosition) < 0.001 && (slidePosition = 0), params.roundLengths && (slidePosition = Math.floor(slidePosition)), index % params.slidesPerGroup == 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition)) : (params.roundLengths && (slidePosition = Math.floor(slidePosition)), (index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup == 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition), slidePosition = slidePosition + slideSize + spaceBetween), swiper.virtualSize += slideSize + spaceBetween, prevSlideSize = slideSize, index += 1;
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance13.exports;
                                return __exports.data((gridEnabled && swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel), lS(0, 146) !== slide.css(lS(0, 147))) ? 1 : 0);
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance50.exports;
            return __exports.data();
        })();
        (() => {
            const __ifInstance17 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const newSlidesGrid = [];
                            (() => {
                                let i = 0;
                                const __forInstance51 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return i < snapGrid.length ? 1 : 0;
                                        },
                                        update: () => {
                                            i += 1;
                                        },
                                        body: () => {
                                            {
                                                let slidesGridItem = snapGrid[i];
                                                params.roundLengths && (slidesGridItem = Math.floor(slidesGridItem)), snapGrid[i] <= swiper.virtualSize - swiperSize && newSlidesGrid.push(slidesGridItem);
                                            }
                                        }
                                    }
                                });
                                const __exports = __forInstance51.exports;
                                return __exports.data();
                            })();
                            snapGrid = newSlidesGrid, Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1 && snapGrid.push(swiper.virtualSize - swiperSize);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance17.exports;
            return __exports.data((swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter, rtl && wrongRTL && (lS(0, 161) === params.effect || lS(0, 162) === params.effect) && $wrapperEl.css({ width: `${ swiper.virtualSize + params.spaceBetween }px` }), params.setWrapperSize && $wrapperEl.css({ [getDirectionLabel(lS(0, 163))]: `${ swiper.virtualSize + params.spaceBetween }px` }), gridEnabled && swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel), !params.centeredSlides) ? 1 : 0);
        })();
        (() => {
            const __ifInstance18 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const key = swiper.isHorizontal() && rtl ? lS(0, 164) : getDirectionLabel(lS(0, 165));
                            (() => {
                                const __callInstance143 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            slides.filter((_, slideIndex) => !params.cssMode || slideIndex !== slides.length - 1).css({ [key]: `${ spaceBetween }px` });
                                        }
                                    }
                                });
                                const __exports = __callInstance143.exports;
                                return __exports.data();
                            })();
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance18.exports;
            return __exports.data((0 === snapGrid.length && (snapGrid = __lA(0, 16, 20)), 0 !== params.spaceBetween) ? 1 : 0);
        })();
        (() => {
            const __ifInstance19 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            let allSlidesSize = 0;
                            slidesSizesGrid.forEach(slideSizeValue => {
                                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
                            }), allSlidesSize -= params.spaceBetween;
                            const maxSnap = allSlidesSize - swiperSize;
                            snapGrid = snapGrid.map(snap => snap < 0 ? -offsetBefore : snap > maxSnap ? maxSnap + offsetAfter : snap);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance19.exports;
            return __exports.data(params.centeredSlides && params.centeredSlidesBounds ? 1 : 0);
        })();
        (() => {
            const __ifInstance20 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            let allSlidesSize = 0;
                            (() => {
                                const __ifInstance21 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                                                snapGrid.forEach((snap, snapIndex) => {
                                                    snapGrid[snapIndex] = snap - allSlidesOffset;
                                                }), slidesGrid.forEach((snap, snapIndex) => {
                                                    slidesGrid[snapIndex] = snap + allSlidesOffset;
                                                });
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance21.exports;
                                return __exports.data((slidesSizesGrid.forEach(slideSizeValue => {
                                    allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
                                }), allSlidesSize -= params.spaceBetween, allSlidesSize < swiperSize) ? 1 : 0);
                            })();
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance20.exports;
            return __exports.data(params.centerInsufficientSlides ? 1 : 0);
        })();
        (() => {
            const __ifInstance22 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            setCSSProperty(swiper.wrapperEl, lS(0, 166), `${ -snapGrid[0] }px`), setCSSProperty(swiper.wrapperEl, lS(0, 167), `${ swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2 }px`);
                            const addToSnapGrid = -swiper.snapGrid[0], addToSlidesGrid = -swiper.slidesGrid[0];
                            swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid), swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance22.exports;
            return __exports.data((Object.assign(swiper, {
                slides: slides,
                snapGrid: snapGrid,
                slidesGrid: slidesGrid,
                slidesSizesGrid: slidesSizesGrid
            }), params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) ? 1 : 0);
        })();
        (() => {
            const __ifInstance23 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const backFaceHiddenClass = `${ params.containerModifierClass }backface-hidden`, hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
                            slidesLength <= params.maxBackfaceHiddenSlides ? hasClassBackfaceClassAdded || swiper.$el.addClass(backFaceHiddenClass) : hasClassBackfaceClassAdded && swiper.$el.removeClass(backFaceHiddenClass);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance23.exports;
            return __exports.data((slidesLength !== previousSlidesLength && swiper.emit(lS(0, 168)), snapGrid.length !== previousSnapGridLength && (swiper.params.watchOverflow && swiper.checkOverflow(), swiper.emit(lS(0, 169))), slidesGrid.length !== previousSlidesGridLength && swiper.emit(lS(0, 170)), params.watchSlidesProgress && swiper.updateSlidesOffset(), !(isVirtual || params.cssMode || lS(0, 171) !== params.effect && lS(0, 172) !== params.effect)) ? 1 : 0);
        })();
    }
    function updateAutoHeight(speed) {
        const swiper = this, activeSlides = [], isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let newHeight = 0, i;
        lS(0, 173) == typeof speed ? swiper.setTransition(speed) : !0 === speed && swiper.setTransition(swiper.params.speed);
        const getSlideByIndex = index => isVirtual ? swiper.slides.filter(el => parseInt(el.getAttribute(lS(0, 174)), 10) === index)[0] : swiper.slides.eq(index)[0];
        if (lS(0, 175) !== swiper.params.slidesPerView && swiper.params.slidesPerView > 1)
            if (swiper.params.centeredSlides)
                (() => {
                    const __callInstance142 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                (swiper.visibleSlides || $([])).each(slide => {
                                    (() => {
                                        const __callInstance141 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    activeSlides.push(slide);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance141.exports;
                                        return __exports.data();
                                    })();
                                });
                            }
                        }
                    });
                    const __exports = __callInstance142.exports;
                    return __exports.data();
                })();
            else
                for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                    const index = swiper.activeIndex + i;
                    if (index > swiper.slides.length && !isVirtual)
                        break;
                    (() => {
                        const __callInstance140 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    activeSlides.push(getSlideByIndex(index));
                                }
                            }
                        });
                        const __exports = __callInstance140.exports;
                        return __exports.data();
                    })();
                }
        else
            (() => {
                const __callInstance139 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            activeSlides.push(getSlideByIndex(swiper.activeIndex));
                        }
                    }
                });
                const __exports = __callInstance139.exports;
                return __exports.data();
            })();
        (() => {
            i = 0;
            const __forInstance52 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < activeSlides.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __ifInstance24 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            const height = activeSlides[i].offsetHeight;
                                            newHeight = height > newHeight ? height : newHeight;
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance24.exports;
                            return __exports.data(void 0 !== activeSlides[i] ? 1 : 0);
                        })();
                    }
                }
            });
            const __exports = __forInstance52.exports;
            return __exports.data();
        })();
        (newHeight || 0 === newHeight) && swiper.$wrapperEl.css(lS(0, 176), `${ newHeight }px`);
    }
    function updateSlidesOffset() {
        const swiper = this, slides = swiper.slides;
        (() => {
            let i = 0;
            const __forInstance53 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < slides.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
                    }
                }
            });
            const __exports = __forInstance53.exports;
            return __exports.data();
        })();
    }
    function updateSlidesProgress(translate) {
        void 0 === translate && (translate = this && this.translate || 0);
        const swiper = this, params = swiper.params, {
                slides: slides,
                rtlTranslate: rtl,
                snapGrid: snapGrid
            } = swiper;
        if (0 === slides.length)
            return;
        void 0 === slides[0].swiperSlideOffset && swiper.updateSlidesOffset();
        let offsetCenter = -translate;
        rtl && (offsetCenter = translate), slides.removeClass(params.slideVisibleClass), swiper.visibleSlidesIndexes = [], swiper.visibleSlides = [];
        (() => {
            let i = 0;
            const __forInstance54 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < slides.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const slide = slides[i];
                            let slideOffset = slide.swiperSlideOffset;
                            params.cssMode && params.centeredSlides && (slideOffset -= slides[0].swiperSlideOffset);
                            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween), originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween), slideBefore = -(offsetCenter - slideOffset), slideAfter = slideBefore + swiper.slidesSizesGrid[i], isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                            isVisible && (swiper.visibleSlides.push(slide), swiper.visibleSlidesIndexes.push(i), slides.eq(i).addClass(params.slideVisibleClass)), slide.progress = rtl ? -slideProgress : slideProgress, slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
                        }
                    }
                }
            });
            const __exports = __forInstance54.exports;
            return __exports.data();
        })();
        swiper.visibleSlides = $(swiper.visibleSlides);
    }
    function updateProgress(translate) {
        const swiper = this;
        (() => {
            const __ifInstance25 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const multiplier = swiper.rtlTranslate ? -1 : 1;
                            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance25.exports;
            return __exports.data(void 0 === translate ? 1 : 0);
        })();
        const params = swiper.params, translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        let {
            progress: progress,
            isBeginning: isBeginning,
            isEnd: isEnd
        } = swiper;
        const wasBeginning = isBeginning, wasEnd = isEnd;
        0 === translatesDiff ? (progress = 0, isBeginning = !0, isEnd = !0) : (progress = (translate - swiper.minTranslate()) / translatesDiff, isBeginning = progress <= 0, isEnd = progress >= 1), Object.assign(swiper, {
            progress: progress,
            isBeginning: isBeginning,
            isEnd: isEnd
        }), (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) && swiper.updateSlidesProgress(translate), isBeginning && !wasBeginning && swiper.emit(lS(0, 177)), isEnd && !wasEnd && swiper.emit(lS(0, 178)), (wasBeginning && !isBeginning || wasEnd && !isEnd) && swiper.emit(lS(0, 179)), swiper.emit(lS(0, 180), progress);
    }
    function updateSlidesClasses() {
        const swiper = this, {
                slides: slides,
                params: params,
                $wrapperEl: $wrapperEl,
                activeIndex: activeIndex,
                realIndex: realIndex
            } = swiper, isVirtual = swiper.virtual && params.virtual.enabled;
        let activeSlide;
        slides.removeClass(`${ params.slideActiveClass } ${ params.slideNextClass } ${ params.slidePrevClass } ${ params.slideDuplicateActiveClass } ${ params.slideDuplicateNextClass } ${ params.slideDuplicatePrevClass }`), activeSlide = isVirtual ? swiper.$wrapperEl.find(`.${ params.slideClass }[data-swiper-slide-index="${ activeIndex }"]`) : slides.eq(activeIndex), activeSlide.addClass(params.slideActiveClass), params.loop && (activeSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children(`.${ params.slideClass }:not(.${ params.slideDuplicateClass })[data-swiper-slide-index="${ realIndex }"]`).addClass(params.slideDuplicateActiveClass) : $wrapperEl.children(`.${ params.slideClass }.${ params.slideDuplicateClass }[data-swiper-slide-index="${ realIndex }"]`).addClass(params.slideDuplicateActiveClass));
        let nextSlide = activeSlide.nextAll(`.${ params.slideClass }`).eq(0).addClass(params.slideNextClass);
        params.loop && 0 === nextSlide.length && (nextSlide = slides.eq(0), nextSlide.addClass(params.slideNextClass));
        let prevSlide = activeSlide.prevAll(`.${ params.slideClass }`).eq(0).addClass(params.slidePrevClass);
        params.loop && 0 === prevSlide.length && (prevSlide = slides.eq(-1), prevSlide.addClass(params.slidePrevClass)), params.loop && (nextSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children(`.${ params.slideClass }:not(.${ params.slideDuplicateClass })[data-swiper-slide-index="${ nextSlide.attr(lS(0, 181)) }"]`).addClass(params.slideDuplicateNextClass) : $wrapperEl.children(`.${ params.slideClass }.${ params.slideDuplicateClass }[data-swiper-slide-index="${ nextSlide.attr(lS(0, 182)) }"]`).addClass(params.slideDuplicateNextClass), prevSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children(`.${ params.slideClass }:not(.${ params.slideDuplicateClass })[data-swiper-slide-index="${ prevSlide.attr(lS(0, 183)) }"]`).addClass(params.slideDuplicatePrevClass) : $wrapperEl.children(`.${ params.slideClass }.${ params.slideDuplicateClass }[data-swiper-slide-index="${ prevSlide.attr(lS(0, 184)) }"]`).addClass(params.slideDuplicatePrevClass)), swiper.emitSlidesClasses();
    }
    function updateActiveIndex(newActiveIndex) {
        const swiper = this, translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate, {
                slidesGrid: slidesGrid,
                snapGrid: snapGrid,
                params: params,
                activeIndex: previousIndex,
                realIndex: previousRealIndex,
                snapIndex: previousSnapIndex
            } = swiper;
        let activeIndex = newActiveIndex, snapIndex;
        (() => {
            const __ifInstance26 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            (() => {
                                let i = 0;
                                const __forInstance55 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return i < slidesGrid.length ? 1 : 0;
                                        },
                                        update: () => {
                                            i += 1;
                                        },
                                        body: () => {
                                            void 0 !== slidesGrid[i + 1] ? translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2 ? activeIndex = i : translate >= slidesGrid[i] && translate < slidesGrid[i + 1] && (activeIndex = i + 1) : translate >= slidesGrid[i] && (activeIndex = i);
                                        }
                                    }
                                });
                                const __exports = __forInstance55.exports;
                                return __exports.data();
                            })();
                            params.normalizeSlideIndex && (activeIndex < 0 || void 0 === activeIndex) && (activeIndex = 0);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance26.exports;
            return __exports.data(void 0 === activeIndex ? 1 : 0);
        })();
        (() => {
            const __ifInstance27 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        snapIndex = snapGrid.indexOf(translate);
                    },
                    impFunc2: () => {
                        {
                            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
                        }
                    }
                }
            });
            const __exports = __ifInstance27.exports;
            return __exports.data(snapGrid.indexOf(translate) >= 0 ? 1 : 0);
        })();
        if (snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1), activeIndex === previousIndex)
            return void (snapIndex !== previousSnapIndex && (swiper.snapIndex = snapIndex, swiper.emit(lS(0, 185))));
        const realIndex = parseInt(swiper.slides.eq(activeIndex).attr(lS(0, 186)) || activeIndex, 10);
        Object.assign(swiper, {
            snapIndex: snapIndex,
            realIndex: realIndex,
            previousIndex: previousIndex,
            activeIndex: activeIndex
        }), swiper.emit(lS(0, 187)), swiper.emit(lS(0, 188)), previousRealIndex !== realIndex && swiper.emit(lS(0, 189)), (swiper.initialized || swiper.params.runCallbacksOnInit) && swiper.emit(lS(0, 190));
    }
    function updateClickedSlide(e) {
        const swiper = this, params = swiper.params, slide = $(e).closest(`.${ params.slideClass }`)[0];
        let slideFound = !1, slideIndex;
        if (slide)
            for (let i = 0; i < swiper.slides.length; i += 1)
                if (swiper.slides[i] === slide) {
                    slideFound = !0, slideIndex = i;
                    break;
                }
        if (!slide || !slideFound)
            return swiper.clickedSlide = void 0, void (swiper.clickedIndex = void 0);
        swiper.clickedSlide = slide, swiper.virtual && swiper.params.virtual.enabled ? swiper.clickedIndex = parseInt($(slide).attr(lS(0, 191)), 10) : swiper.clickedIndex = slideIndex, params.slideToClickedSlide && void 0 !== swiper.clickedIndex && swiper.clickedIndex !== swiper.activeIndex && swiper.slideToClickedSlide();
    }
    function getSwiperTranslate(axis) {
        void 0 === axis && (axis = this.isHorizontal() ? lS(0, 192) : lS(0, 193));
        const swiper = this, {
                params: params,
                rtlTranslate: rtl,
                translate: translate,
                $wrapperEl: $wrapperEl
            } = this;
        if (params.virtualTranslate)
            return rtl ? -translate : translate;
        if (params.cssMode)
            return translate;
        let currentTranslate = getTranslate($wrapperEl[0], axis);
        return rtl && (currentTranslate = -currentTranslate), currentTranslate || 0;
    }
    function setTranslate(translate, byController) {
        const swiper = this, {
                rtlTranslate: rtl,
                params: params,
                $wrapperEl: $wrapperEl,
                wrapperEl: wrapperEl,
                progress: progress
            } = swiper;
        let x = 0, y = 0;
        const z = 0;
        let newProgress;
        swiper.isHorizontal() ? x = rtl ? -translate : translate : y = translate, params.roundLengths && (x = Math.floor(x), y = Math.floor(y)), params.cssMode ? wrapperEl[swiper.isHorizontal() ? lS(0, 194) : lS(0, 195)] = swiper.isHorizontal() ? -x : -y : params.virtualTranslate || $wrapperEl.transform(`translate3d(${ x }px, ${ y }px, 0px)`), swiper.previousTranslate = swiper.translate, swiper.translate = swiper.isHorizontal() ? x : y;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        newProgress = 0 === translatesDiff ? 0 : (translate - swiper.minTranslate()) / translatesDiff, newProgress !== progress && swiper.updateProgress(translate), swiper.emit(lS(0, 196), swiper.translate, byController);
    }
    function minTranslate() {
        return -this.snapGrid[0];
    }
    function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
    }
    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
        void 0 === translate && (translate = 0), void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0), void 0 === translateBounds && (translateBounds = !0);
        const swiper = this, {
                params: params,
                wrapperEl: wrapperEl
            } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition)
            return !1;
        const minTranslate = swiper.minTranslate(), maxTranslate = swiper.maxTranslate();
        let newTranslate;
        if (newTranslate = translateBounds && translate > minTranslate ? minTranslate : translateBounds && translate < maxTranslate ? maxTranslate : translate, swiper.updateProgress(newTranslate), params.cssMode) {
            const isH = swiper.isHorizontal();
            if (0 === speed)
                wrapperEl[isH ? lS(0, 197) : lS(0, 198)] = -newTranslate;
            else {
                if (!swiper.support.smoothScroll)
                    return animateCSSModeScroll({
                        swiper: swiper,
                        targetPosition: -newTranslate,
                        side: isH ? lS(0, 199) : lS(0, 200)
                    }), !0;
                (() => {
                    const __callInstance138 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                wrapperEl.scrollTo({
                                    [isH ? lS(0, 201) : lS(0, 202)]: -newTranslate,
                                    behavior: 'smooth'
                                });
                            }
                        }
                    });
                    const __exports = __callInstance138.exports;
                    return __exports.data();
                })();
            }
            return !0;
        }
        return 0 === speed ? (swiper.setTransition(0), swiper.setTranslate(newTranslate), runCallbacks && (swiper.emit(lS(0, 203), speed, internal), swiper.emit(lS(0, 204)))) : (swiper.setTransition(speed), swiper.setTranslate(newTranslate), runCallbacks && (swiper.emit(lS(0, 205), speed, internal), swiper.emit(lS(0, 206))), swiper.animating || (swiper.animating = !0, swiper.onTranslateToWrapperTransitionEnd || (swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            swiper && !swiper.destroyed && e.target === this && (swiper.$wrapperEl[0].removeEventListener(lS(0, 207), swiper.onTranslateToWrapperTransitionEnd), swiper.$wrapperEl[0].removeEventListener(lS(0, 208), swiper.onTranslateToWrapperTransitionEnd), swiper.onTranslateToWrapperTransitionEnd = null, delete swiper.onTranslateToWrapperTransitionEnd, runCallbacks && swiper.emit(lS(0, 209)));
        }), swiper.$wrapperEl[0].addEventListener(lS(0, 210), swiper.onTranslateToWrapperTransitionEnd), swiper.$wrapperEl[0].addEventListener(lS(0, 211), swiper.onTranslateToWrapperTransitionEnd))), !0;
    }
    function setTransition(duration, byController) {
        const swiper = this;
        swiper.params.cssMode || swiper.$wrapperEl.transition(duration), swiper.emit(lS(0, 212), duration, byController);
    }
    function transitionEmit(_ref) {
        let {
            swiper: swiper,
            runCallbacks: runCallbacks,
            direction: direction,
            step: step
        } = _ref;
        const {
            activeIndex: activeIndex,
            previousIndex: previousIndex
        } = swiper;
        let dir = direction;
        if (dir || (dir = activeIndex > previousIndex ? lS(0, 213) : activeIndex < previousIndex ? lS(0, 214) : lS(0, 215)), swiper.emit(`transition${ step }`), runCallbacks && activeIndex !== previousIndex) {
            if (lS(0, 216) === dir)
                return void swiper.emit(`slideResetTransition${ step }`);
            swiper.emit(`slideChangeTransition${ step }`), lS(0, 217) === dir ? swiper.emit(`slideNextTransition${ step }`) : swiper.emit(`slidePrevTransition${ step }`);
        }
    }
    function transitionStart(runCallbacks, direction) {
        void 0 === runCallbacks && (runCallbacks = !0);
        const swiper = this, {params: params} = swiper;
        params.cssMode || (params.autoHeight && swiper.updateAutoHeight(), transitionEmit({
            swiper: swiper,
            runCallbacks: runCallbacks,
            direction: direction,
            step: 'Start'
        }));
    }
    function transitionEnd(runCallbacks, direction) {
        void 0 === runCallbacks && (runCallbacks = !0);
        const swiper = this, {params: params} = this;
        this.animating = !1, params.cssMode || (this.setTransition(0), transitionEmit({
            swiper: this,
            runCallbacks: runCallbacks,
            direction: direction,
            step: 'End'
        }));
    }
    function slideTo(index, speed, runCallbacks, internal, initial) {
        if (void 0 === index && (index = 0), void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0), lS(0, 218) != typeof index && lS(0, 219) != typeof index)
            throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${ typeof index }] given.`);
        if (lS(0, 220) == typeof index) {
            const indexAsNumber = parseInt(index, 10), isValidNumber = isFinite(indexAsNumber);
            if (!isValidNumber)
                throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${ index }] given.`);
            index = indexAsNumber;
        }
        const swiper = this;
        let slideIndex = index;
        slideIndex < 0 && (slideIndex = 0);
        const {
            params: params,
            snapGrid: snapGrid,
            slidesGrid: slidesGrid,
            previousIndex: previousIndex,
            activeIndex: activeIndex,
            rtlTranslate: rtl,
            wrapperEl: wrapperEl,
            enabled: enabled
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial)
            return !1;
        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
        snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1);
        const translate = -snapGrid[snapIndex];
        (() => {
            const __ifInstance28 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        for (let i = 0; i < slidesGrid.length; i += 1) {
                            const normalizedTranslate = -Math.floor(100 * translate), normalizedGrid = Math.floor(100 * slidesGrid[i]), normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);
                            void 0 !== slidesGrid[i + 1] ? normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2 ? slideIndex = i : normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext && (slideIndex = i + 1) : normalizedTranslate >= normalizedGrid && (slideIndex = i);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance28.exports;
            return __exports.data(params.normalizeSlideIndex ? 1 : 0);
        })();
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate())
                return !1;
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate() && (activeIndex || 0) !== slideIndex)
                return !1;
        }
        let direction;
        if (slideIndex !== (previousIndex || 0) && runCallbacks && swiper.emit(lS(0, 221)), swiper.updateProgress(translate), direction = slideIndex > activeIndex ? lS(0, 222) : slideIndex < activeIndex ? lS(0, 223) : lS(0, 224), rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)
            return swiper.updateActiveIndex(slideIndex), params.autoHeight && swiper.updateAutoHeight(), swiper.updateSlidesClasses(), lS(0, 225) !== params.effect && swiper.setTranslate(translate), lS(0, 226) !== direction && (swiper.transitionStart(runCallbacks, direction), swiper.transitionEnd(runCallbacks, direction)), !1;
        if (params.cssMode) {
            const isH = swiper.isHorizontal(), t = rtl ? translate : -translate;
            if (0 === speed) {
                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                isVirtual && (swiper.wrapperEl.style.scrollSnapType = lS(0, 227), swiper._immediateVirtual = !0), wrapperEl[isH ? lS(0, 228) : lS(0, 229)] = t, isVirtual && requestAnimationFrame(() => {
                    swiper.wrapperEl.style.scrollSnapType = lS(0, 230), swiper._swiperImmediateVirtual = !1;
                });
            } else {
                if (!swiper.support.smoothScroll)
                    return animateCSSModeScroll({
                        swiper: swiper,
                        targetPosition: t,
                        side: isH ? lS(0, 231) : lS(0, 232)
                    }), !0;
                (() => {
                    const __callInstance137 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                wrapperEl.scrollTo({
                                    [isH ? lS(0, 233) : lS(0, 234)]: t,
                                    behavior: 'smooth'
                                });
                            }
                        }
                    });
                    const __exports = __callInstance137.exports;
                    return __exports.data();
                })();
            }
            return !0;
        }
        return swiper.setTransition(speed), swiper.setTranslate(translate), swiper.updateActiveIndex(slideIndex), swiper.updateSlidesClasses(), swiper.emit(lS(0, 235), speed, internal), swiper.transitionStart(runCallbacks, direction), 0 === speed ? swiper.transitionEnd(runCallbacks, direction) : swiper.animating || (swiper.animating = !0, swiper.onSlideToWrapperTransitionEnd || (swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            swiper && !swiper.destroyed && e.target === this && (swiper.$wrapperEl[0].removeEventListener(lS(0, 236), swiper.onSlideToWrapperTransitionEnd), swiper.$wrapperEl[0].removeEventListener(lS(0, 237), swiper.onSlideToWrapperTransitionEnd), swiper.onSlideToWrapperTransitionEnd = null, delete swiper.onSlideToWrapperTransitionEnd, swiper.transitionEnd(runCallbacks, direction));
        }), swiper.$wrapperEl[0].addEventListener(lS(0, 238), swiper.onSlideToWrapperTransitionEnd), swiper.$wrapperEl[0].addEventListener(lS(0, 239), swiper.onSlideToWrapperTransitionEnd)), !0;
    }
    function slideToLoop(index, speed, runCallbacks, internal) {
        if (void 0 === index && (index = 0), void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0), lS(0, 240) == typeof index) {
            const indexAsNumber = parseInt(index, 10), isValidNumber = isFinite(indexAsNumber);
            if (!isValidNumber)
                throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${ index }] given.`);
            index = indexAsNumber;
        }
        const swiper = this;
        let newIndex = index;
        return swiper.params.loop && (newIndex += swiper.loopedSlides), swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
    function slideNext(speed, runCallbacks, internal) {
        void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
        const swiper = this, {
                animating: animating,
                enabled: enabled,
                params: params
            } = swiper;
        if (!enabled)
            return swiper;
        let perGroup = params.slidesPerGroup;
        lS(0, 241) === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto && (perGroup = Math.max(swiper.slidesPerViewDynamic(lS(0, 242), !0), 1));
        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
        if (params.loop) {
            if (animating && params.loopPreventsSlide)
                return !1;
            swiper.loopFix(), swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        return params.rewind && swiper.isEnd ? swiper.slideTo(0, speed, runCallbacks, internal) : swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }
    function slidePrev(speed, runCallbacks, internal) {
        void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
        const swiper = this, {
                params: params,
                animating: animating,
                snapGrid: snapGrid,
                slidesGrid: slidesGrid,
                rtlTranslate: rtlTranslate,
                enabled: enabled
            } = swiper;
        if (!enabled)
            return swiper;
        if (params.loop) {
            if (animating && params.loopPreventsSlide)
                return !1;
            swiper.loopFix(), swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        const translate = rtlTranslate ? swiper.translate : -swiper.translate;
        function normalize(val) {
            return val < 0 ? -Math.floor(Math.abs(val)) : Math.floor(val);
        }
        const normalizedTranslate = normalize(translate), normalizedSnapGrid = snapGrid.map(val => normalize(val));
        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        (() => {
            const __ifInstance29 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            let prevSnapIndex;
                            snapGrid.forEach((snap, snapIndex) => {
                                normalizedTranslate >= snap && (prevSnapIndex = snapIndex);
                            }), void 0 !== prevSnapIndex && (prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex]);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance29.exports;
            return __exports.data(void 0 === prevSnap && params.cssMode ? 1 : 0);
        })();
        let prevIndex = 0;
        if (void 0 !== prevSnap && (prevIndex = slidesGrid.indexOf(prevSnap), prevIndex < 0 && (prevIndex = swiper.activeIndex - 1), lS(0, 243) === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto && (prevIndex = prevIndex - swiper.slidesPerViewDynamic(lS(0, 244), !0) + 1, prevIndex = Math.max(prevIndex, 0))), params.rewind && swiper.isBeginning) {
            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    function slideReset(speed, runCallbacks, internal) {
        void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
        const swiper = this;
        return this.slideTo(this.activeIndex, speed, runCallbacks, internal);
    }
    function slideToClosest(speed, runCallbacks, internal, threshold) {
        void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0), void 0 === threshold && (threshold = 0.5);
        const swiper = this;
        let index = swiper.activeIndex;
        const skip = Math.min(swiper.params.slidesPerGroupSkip, index), snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup), translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        (() => {
            const __ifInstance30 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const currentSnap = swiper.snapGrid[snapIndex], nextSnap = swiper.snapGrid[snapIndex + 1];
                            translate - currentSnap > (nextSnap - currentSnap) * threshold && (index += swiper.params.slidesPerGroup);
                        }
                    },
                    impFunc2: () => {
                        {
                            const prevSnap = swiper.snapGrid[snapIndex - 1], currentSnap = swiper.snapGrid[snapIndex];
                            translate - prevSnap <= (currentSnap - prevSnap) * threshold && (index -= swiper.params.slidesPerGroup);
                        }
                    }
                }
            });
            const __exports = __ifInstance30.exports;
            return __exports.data(translate >= swiper.snapGrid[snapIndex] ? 1 : 0);
        })();
        return index = Math.max(index, 0), index = Math.min(index, swiper.slidesGrid.length - 1), swiper.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
        const swiper = this, {
                params: params,
                $wrapperEl: $wrapperEl
            } = swiper, slidesPerView = lS(0, 245) === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        let slideToIndex = swiper.clickedIndex, realIndex;
        if (params.loop) {
            if (swiper.animating)
                return;
            realIndex = parseInt($(swiper.clickedSlide).attr(lS(0, 246)), 10), params.centeredSlides ? slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2 ? (swiper.loopFix(), slideToIndex = $wrapperEl.children(`.${ params.slideClass }[data-swiper-slide-index="${ realIndex }"]:not(.${ params.slideDuplicateClass })`).eq(0).index(), nextTick(() => {
                (() => {
                    const __callInstance136 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.slideTo(slideToIndex);
                            }
                        }
                    });
                    const __exports = __callInstance136.exports;
                    return __exports.data();
                })();
            })) : swiper.slideTo(slideToIndex) : slideToIndex > swiper.slides.length - slidesPerView ? (swiper.loopFix(), slideToIndex = $wrapperEl.children(`.${ params.slideClass }[data-swiper-slide-index="${ realIndex }"]:not(.${ params.slideDuplicateClass })`).eq(0).index(), nextTick(() => {
                (() => {
                    const __callInstance135 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.slideTo(slideToIndex);
                            }
                        }
                    });
                    const __exports = __callInstance135.exports;
                    return __exports.data();
                })();
            })) : swiper.slideTo(slideToIndex);
        } else
            (() => {
                const __callInstance134 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            swiper.slideTo(slideToIndex);
                        }
                    }
                });
                const __exports = __callInstance134.exports;
                return __exports.data();
            })();
    }
    function loopCreate() {
        const swiper = this, document = getDocument(), {
                params: params,
                $wrapperEl: $wrapperEl
            } = swiper, $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
        (() => {
            const __callInstance133 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        $selector.children(`.${ params.slideClass }.${ params.slideDuplicateClass }`).remove();
                    }
                }
            });
            const __exports = __callInstance133.exports;
            return __exports.data();
        })();
        let slides = $selector.children(`.${ params.slideClass }`);
        (() => {
            const __ifInstance31 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
                            (() => {
                                const __ifInstance32 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                (() => {
                                                    let i = 0;
                                                    const __forInstance57 = new WebAssembly.Instance(__forWasmModule, {
                                                        env: {
                                                            test: () => {
                                                                return i < blankSlidesNum ? 1 : 0;
                                                            },
                                                            update: () => {
                                                                i += 1;
                                                            },
                                                            body: () => {
                                                                {
                                                                    const blankNode = $(document.createElement(lS(0, 247))).addClass(`${ params.slideClass } ${ params.slideBlankClass }`);
                                                                    (() => {
                                                                        const __callInstance132 = new WebAssembly.Instance(__callWasmModule, {
                                                                            env: {
                                                                                impFunc: () => {
                                                                                    $selector.append(blankNode);
                                                                                }
                                                                            }
                                                                        });
                                                                        const __exports = __callInstance132.exports;
                                                                        return __exports.data();
                                                                    })();
                                                                }
                                                            }
                                                        }
                                                    });
                                                    const __exports = __forInstance57.exports;
                                                    return __exports.data();
                                                })();
                                                slides = $selector.children(`.${ params.slideClass }`);
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance32.exports;
                                return __exports.data(blankSlidesNum !== params.slidesPerGroup ? 1 : 0);
                            })();
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance31.exports;
            return __exports.data(params.loopFillGroupWithBlank ? 1 : 0);
        })();
        lS(0, 248) !== params.slidesPerView || params.loopedSlides || (params.loopedSlides = slides.length), swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10)), swiper.loopedSlides += params.loopAdditionalSlides, swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit && (swiper.loopedSlides = slides.length);
        const prependSlides = [], appendSlides = [];
        (() => {
            const __callInstance131 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        slides.each((el, index) => {
                            const slide = $(el);
                            (() => {
                                const __callInstance130 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            slide.attr(lS(0, 249), index);
                                        }
                                    }
                                });
                                const __exports = __callInstance130.exports;
                                return __exports.data();
                            })();
                        });
                    }
                }
            });
            const __exports = __callInstance131.exports;
            return __exports.data();
        })();
        (() => {
            let i = 0;
            const __forInstance58 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < swiper.loopedSlides ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const index = i - Math.floor(i / slides.length) * slides.length;
                            appendSlides.push(slides.eq(index)[0]), prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
                        }
                    }
                }
            });
            const __exports = __forInstance58.exports;
            return __exports.data();
        })();
        (() => {
            let i = 0;
            const __forInstance59 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < appendSlides.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __callInstance129 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        $selector.append($(appendSlides[i].cloneNode(!0)).addClass(params.slideDuplicateClass));
                                    }
                                }
                            });
                            const __exports = __callInstance129.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __forInstance59.exports;
            return __exports.data();
        })();
        (() => {
            let i = prependSlides.length - 1;
            const __forInstance60 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i >= 0 ? 1 : 0;
                    },
                    update: () => {
                        i -= 1;
                    },
                    body: () => {
                        (() => {
                            const __callInstance128 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        $selector.prepend($(prependSlides[i].cloneNode(!0)).addClass(params.slideDuplicateClass));
                                    }
                                }
                            });
                            const __exports = __callInstance128.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __forInstance60.exports;
            return __exports.data();
        })();
    }
    function loopFix() {
        const swiper = this;
        (() => {
            const __callInstance127 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        swiper.emit(lS(0, 250));
                    }
                }
            });
            const __exports = __callInstance127.exports;
            return __exports.data();
        })();
        const {
            activeIndex: activeIndex,
            slides: slides,
            loopedSlides: loopedSlides,
            allowSlidePrev: allowSlidePrev,
            allowSlideNext: allowSlideNext,
            snapGrid: snapGrid,
            rtlTranslate: rtl
        } = swiper;
        let newIndex;
        swiper.allowSlidePrev = !0, swiper.allowSlideNext = !0;
        const snapTranslate = -snapGrid[activeIndex], diff = snapTranslate - swiper.getTranslate();
        (() => {
            const __ifInstance33 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            newIndex = slides.length - 3 * loopedSlides + activeIndex, newIndex += loopedSlides;
                            const slideChanged = swiper.slideTo(newIndex, 0, !1, !0);
                            slideChanged && 0 !== diff && swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
                        }
                    },
                    impFunc2: () => {
                        (() => {
                            const __ifInstance34 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            newIndex = -slides.length + activeIndex + loopedSlides, newIndex += loopedSlides;
                                            const slideChanged = swiper.slideTo(newIndex, 0, !1, !0);
                                            slideChanged && 0 !== diff && swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance34.exports;
                            return __exports.data(activeIndex >= slides.length - loopedSlides ? 1 : 0);
                        })();
                    }
                }
            });
            const __exports = __ifInstance33.exports;
            return __exports.data(activeIndex < loopedSlides ? 1 : 0);
        })();
        swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.emit(lS(0, 251));
    }
    function loopDestroy() {
        const swiper = this, {
                $wrapperEl: $wrapperEl,
                params: params,
                slides: slides
            } = this;
        $wrapperEl.children(`.${ params.slideClass }.${ params.slideDuplicateClass },.${ params.slideClass }.${ params.slideBlankClass }`).remove(), slides.removeAttr(lS(0, 252));
    }
    function setGrabCursor(moving) {
        const swiper = this;
        if (this.support.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode)
            return;
        const el = lS(0, 253) === this.params.touchEventsTarget ? this.el : this.wrapperEl;
        el.style.cursor = lS(0, 254), el.style.cursor = moving ? lS(0, 255) : lS(0, 256);
    }
    function unsetGrabCursor() {
        const swiper = this;
        this.support.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this[lS(0, 257) === this.params.touchEventsTarget ? lS(0, 258) : lS(0, 259)].style.cursor = lS(0, 260));
    }
    function closestElement(selector, base) {
        function __closestFrom(el) {
            if (!el || el === getDocument() || el === getWindow())
                return null;
            el.assignedSlot && (el = el.assignedSlot);
            const found = el.closest(selector);
            return found || el.getRootNode ? found || __closestFrom(el.getRootNode().host) : null;
        }
        return void 0 === base && (base = this), __closestFrom(base);
    }
    function onTouchStart(event) {
        const swiper = this, document = getDocument(), window = getWindow(), data = swiper.touchEventsData, {
                params: params,
                touches: touches,
                enabled: enabled
            } = swiper;
        if (!enabled)
            return;
        if (swiper.animating && params.preventInteractionOnTransition)
            return;
        !swiper.animating && params.cssMode && params.loop && swiper.loopFix();
        let e = event;
        e.originalEvent && (e = e.originalEvent);
        let $targetEl = $(e.target);
        if (lS(0, 261) === params.touchEventsTarget && !$targetEl.closest(swiper.wrapperEl).length)
            return;
        if (data.isTouchEvent = lS(0, 262) === e.type, !data.isTouchEvent && lS(0, 263) in e && 3 === e.which)
            return;
        if (!data.isTouchEvent && lS(0, 264) in e && e.button > 0)
            return;
        if (data.isTouched && data.isMoved)
            return;
        const swipingClassHasValue = !!params.noSwipingClass && lS(0, 265) !== params.noSwipingClass, eventPath = event.composedPath ? event.composedPath() : event.path;
        swipingClassHasValue && e.target && e.target.shadowRoot && eventPath && ($targetEl = $(eventPath[0]));
        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${ params.noSwipingClass }`, isTargetShadow = !(!e.target || !e.target.shadowRoot);
        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0]))
            return void (swiper.allowClick = !0);
        if (params.swipeHandler && !$targetEl.closest(params.swipeHandler)[0])
            return;
        touches.currentX = lS(0, 266) === e.type ? e.targetTouches[0].pageX : e.pageX, touches.currentY = lS(0, 267) === e.type ? e.targetTouches[0].pageY : e.pageY;
        const startX = touches.currentX, startY = touches.currentY, edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection, edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
            if (lS(0, 268) !== edgeSwipeDetection)
                return;
            (() => {
                const __callInstance126 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            event.preventDefault();
                        }
                    }
                });
                const __exports = __callInstance126.exports;
                return __exports.data();
            })();
        }
        (() => {
            const __ifInstance35 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            let preventDefault = !0;
                            $targetEl.is(data.focusableElements) && (preventDefault = !1, lS(0, 270) === $targetEl[0].nodeName && (data.isTouched = !1)), document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0] && document.activeElement.blur();
                            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
                            !params.touchStartForcePreventDefault && !shouldPreventDefault || $targetEl[0].isContentEditable || e.preventDefault();
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance35.exports;
            return __exports.data((Object.assign(data, {
                isTouched: !0,
                isMoved: !1,
                allowTouchCallbacks: !0,
                isScrolling: void 0,
                startMoving: void 0
            }), touches.startX = startX, touches.startY = startY, data.touchStartTime = now(), swiper.allowClick = !0, swiper.updateSize(), swiper.swipeDirection = void 0, params.threshold > 0 && (data.allowThresholdMove = !1), lS(0, 269) !== e.type) ? 1 : 0);
        })();
        swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode && swiper.freeMode.onTouchStart(), swiper.emit(lS(0, 271), e);
    }
    function onTouchMove(event) {
        const document = getDocument(), swiper = this, data = swiper.touchEventsData, {
                params: params,
                touches: touches,
                rtlTranslate: rtl,
                enabled: enabled
            } = swiper;
        if (!enabled)
            return;
        let e = event;
        if (e.originalEvent && (e = e.originalEvent), !data.isTouched)
            return void (data.startMoving && data.isScrolling && swiper.emit(lS(0, 272), e));
        if (data.isTouchEvent && lS(0, 273) !== e.type)
            return;
        const targetTouch = lS(0, 274) === e.type && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]), pageX = lS(0, 275) === e.type ? targetTouch.pageX : e.pageX, pageY = lS(0, 276) === e.type ? targetTouch.pageY : e.pageY;
        if (e.preventedByNestedSwiper)
            return touches.startX = pageX, void (touches.startY = pageY);
        if (!swiper.allowTouchMove)
            return $(e.target).is(data.focusableElements) || (swiper.allowClick = !1), void (data.isTouched && (Object.assign(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
            }), data.touchStartTime = now()));
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop)
            if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate())
                    return data.isTouched = !1, void (data.isMoved = !1);
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())
                return;
        if (data.isTouchEvent && document.activeElement && e.target === document.activeElement && $(e.target).is(data.focusableElements))
            return data.isMoved = !0, void (swiper.allowClick = !1);
        if (data.allowTouchCallbacks && swiper.emit(lS(0, 277), e), e.targetTouches && e.targetTouches.length > 1)
            return;
        touches.currentX = pageX, touches.currentY = pageY;
        const diffX = touches.currentX - touches.startX, diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
            return;
        (() => {
            const __ifInstance36 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            let touchAngle;
                            swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX ? data.isScrolling = !1 : diffX * diffX + diffY * diffY >= 25 && (touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI, data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance36.exports;
            return __exports.data(void 0 === data.isScrolling ? 1 : 0);
        })();
        if (data.isScrolling && swiper.emit(lS(0, 278), e), void 0 === data.startMoving && (touches.currentX === touches.startX && touches.currentY === touches.startY || (data.startMoving = !0)), data.isScrolling)
            return void (data.isTouched = !1);
        if (!data.startMoving)
            return;
        swiper.allowClick = !1, !params.cssMode && e.cancelable && e.preventDefault(), params.touchMoveStopPropagation && !params.nested && e.stopPropagation(), data.isMoved || (params.loop && !params.cssMode && swiper.loopFix(), data.startTranslate = swiper.getTranslate(), swiper.setTransition(0), swiper.animating && swiper.$wrapperEl.trigger(lS(0, 279)), data.allowMomentumBounce = !1, !params.grabCursor || !0 !== swiper.allowSlideNext && !0 !== swiper.allowSlidePrev || swiper.setGrabCursor(!0), swiper.emit(lS(0, 280), e)), swiper.emit(lS(0, 281), e), data.isMoved = !0;
        let diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff, diff *= params.touchRatio, rtl && (diff = -diff), swiper.swipeDirection = diff > 0 ? lS(0, 282) : lS(0, 283), data.currentTranslate = diff + data.startTranslate;
        let disableParentSwiper = !0, resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges && (resistanceRatio = 0), diff > 0 && data.currentTranslate > swiper.minTranslate() ? (disableParentSwiper = !1, params.resistance && (data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio)) : diff < 0 && data.currentTranslate < swiper.maxTranslate() && (disableParentSwiper = !1, params.resistance && (data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio)), disableParentSwiper && (e.preventedByNestedSwiper = !0), !swiper.allowSlideNext && lS(0, 284) === swiper.swipeDirection && data.currentTranslate < data.startTranslate && (data.currentTranslate = data.startTranslate), !swiper.allowSlidePrev && lS(0, 285) === swiper.swipeDirection && data.currentTranslate > data.startTranslate && (data.currentTranslate = data.startTranslate), swiper.allowSlidePrev || swiper.allowSlideNext || (data.currentTranslate = data.startTranslate), params.threshold > 0) {
            if (!(Math.abs(diff) > params.threshold || data.allowThresholdMove))
                return void (data.currentTranslate = data.startTranslate);
            if (!data.allowThresholdMove)
                return data.allowThresholdMove = !0, touches.startX = touches.currentX, touches.startY = touches.currentY, data.currentTranslate = data.startTranslate, void (touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY);
        }
        params.followFinger && !params.cssMode && ((params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) && (swiper.updateActiveIndex(), swiper.updateSlidesClasses()), swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.freeMode.onTouchMove(), swiper.updateProgress(data.currentTranslate), swiper.setTranslate(data.currentTranslate));
    }
    function onTouchEnd(event) {
        const swiper = this, data = swiper.touchEventsData, {
                params: params,
                touches: touches,
                rtlTranslate: rtl,
                slidesGrid: slidesGrid,
                enabled: enabled
            } = swiper;
        if (!enabled)
            return;
        let e = event;
        if (e.originalEvent && (e = e.originalEvent), data.allowTouchCallbacks && swiper.emit(lS(0, 286), e), data.allowTouchCallbacks = !1, !data.isTouched)
            return data.isMoved && params.grabCursor && swiper.setGrabCursor(!1), data.isMoved = !1, void (data.startMoving = !1);
        params.grabCursor && data.isMoved && data.isTouched && (!0 === swiper.allowSlideNext || !0 === swiper.allowSlidePrev) && swiper.setGrabCursor(!1);
        const touchEndTime = now(), timeDiff = touchEndTime - data.touchStartTime;
        (() => {
            const __ifInstance37 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const pathTree = e.path || e.composedPath && e.composedPath();
                            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target), swiper.emit(lS(0, 287), e), timeDiff < 300 && touchEndTime - data.lastClickTime < 300 && swiper.emit(lS(0, 288), e);
                        }
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance37.exports;
            return __exports.data(swiper.allowClick ? 1 : 0);
        })();
        if (data.lastClickTime = now(), nextTick(() => {
                swiper.destroyed || (swiper.allowClick = !0);
            }), !data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate)
            return data.isTouched = !1, data.isMoved = !1, void (data.startMoving = !1);
        let currentPos;
        if (data.isTouched = !1, data.isMoved = !1, data.startMoving = !1, currentPos = params.followFinger ? rtl ? swiper.translate : -swiper.translate : -data.currentTranslate, params.cssMode)
            return;
        if (swiper.params.freeMode && params.freeMode.enabled)
            return void swiper.freeMode.onTouchEnd({ currentPos: currentPos });
        let stopIndex = 0, groupSize = swiper.slidesSizesGrid[0];
        (() => {
            let i = 0;
            const __forInstance61 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < slidesGrid.length ? 1 : 0;
                    },
                    update: () => {
                        i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
                    },
                    body: () => {
                        {
                            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                            void 0 !== slidesGrid[i + increment] ? currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment] && (stopIndex = i, groupSize = slidesGrid[i + increment] - slidesGrid[i]) : currentPos >= slidesGrid[i] && (stopIndex = i, groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2]);
                        }
                    }
                }
            });
            const __exports = __forInstance61.exports;
            return __exports.data();
        })();
        let rewindFirstIndex = null, rewindLastIndex = null;
        params.rewind && (swiper.isBeginning ? rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1 : swiper.isEnd && (rewindFirstIndex = 0));
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize, increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes)
                return void swiper.slideTo(swiper.activeIndex);
            lS(0, 289) === swiper.swipeDirection && (ratio >= params.longSwipesRatio ? swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment) : swiper.slideTo(stopIndex)), lS(0, 290) === swiper.swipeDirection && (ratio > 1 - params.longSwipesRatio ? swiper.slideTo(stopIndex + increment) : null !== rewindLastIndex && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio ? swiper.slideTo(rewindLastIndex) : swiper.slideTo(stopIndex));
        } else {
            if (!params.shortSwipes)
                return void swiper.slideTo(swiper.activeIndex);
            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
            isNavButtonTarget ? e.target === swiper.navigation.nextEl ? swiper.slideTo(stopIndex + increment) : swiper.slideTo(stopIndex) : (lS(0, 291) === swiper.swipeDirection && swiper.slideTo(null !== rewindFirstIndex ? rewindFirstIndex : stopIndex + increment), lS(0, 292) === swiper.swipeDirection && swiper.slideTo(null !== rewindLastIndex ? rewindLastIndex : stopIndex));
        }
    }
    function onResize() {
        const swiper = this, {
                params: params,
                el: el
            } = swiper;
        if (el && 0 === el.offsetWidth)
            return;
        params.breakpoints && swiper.setBreakpoint();
        const {
            allowSlideNext: allowSlideNext,
            allowSlidePrev: allowSlidePrev,
            snapGrid: snapGrid
        } = swiper;
        swiper.allowSlideNext = !0, swiper.allowSlidePrev = !0, swiper.updateSize(), swiper.updateSlides(), swiper.updateSlidesClasses(), (lS(0, 293) === params.slidesPerView || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : swiper.slideTo(swiper.activeIndex, 0, !1, !0), swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused && swiper.autoplay.run(), swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow();
    }
    function onClick(e) {
        const swiper = this;
        swiper.enabled && (swiper.allowClick || (swiper.params.preventClicks && e.preventDefault(), swiper.params.preventClicksPropagation && swiper.animating && (e.stopPropagation(), e.stopImmediatePropagation())));
    }
    function onScroll() {
        const swiper = this, {
                wrapperEl: wrapperEl,
                rtlTranslate: rtlTranslate,
                enabled: enabled
            } = swiper;
        if (!enabled)
            return;
        let newProgress;
        swiper.previousTranslate = swiper.translate, swiper.isHorizontal() ? swiper.translate = -wrapperEl.scrollLeft : swiper.translate = -wrapperEl.scrollTop, 0 === swiper.translate && (swiper.translate = 0), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        newProgress = 0 === translatesDiff ? 0 : (swiper.translate - swiper.minTranslate()) / translatesDiff, newProgress !== swiper.progress && swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate), swiper.emit(lS(0, 294), swiper.translate, !1);
    }
    let dummyEventAttached = !1;
    function dummyEventListener() {
    }
    const events = (swiper, method) => {
        const document = getDocument(), {
                params: params,
                touchEvents: touchEvents,
                el: el,
                wrapperEl: wrapperEl,
                device: device,
                support: support
            } = swiper, capture = !!params.nested, domMethod = lS(0, 295) === method ? lS(0, 296) : lS(0, 297), swiperMethod = method;
        (() => {
            const __ifInstance38 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const passiveListener = !(lS(0, 298) !== touchEvents.start || !support.passiveListener || !params.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener), el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                                passive: !1,
                                capture: capture
                            } : capture), el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener), touchEvents.cancel && el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
                        }
                    },
                    impFunc2: () => {
                        el[domMethod](touchEvents.start, swiper.onTouchStart, !1), document[domMethod](touchEvents.move, swiper.onTouchMove, capture), document[domMethod](touchEvents.end, swiper.onTouchEnd, !1);
                    }
                }
            });
            const __exports = __ifInstance38.exports;
            return __exports.data(support.touch ? 1 : 0);
        })();
        (params.preventClicks || params.preventClicksPropagation) && el[domMethod](lS(0, 299), swiper.onClick, !0), params.cssMode && wrapperEl[domMethod](lS(0, 300), swiper.onScroll), params.updateOnWindowResize ? swiper[swiperMethod](device.ios || device.android ? lS(0, 301) : lS(0, 302), onResize, !0) : swiper[swiperMethod](lS(0, 303), onResize, !0);
    };
    function attachEvents() {
        const swiper = this, document = getDocument(), {
                params: params,
                support: support
            } = swiper;
        swiper.onTouchStart = onTouchStart.bind(swiper), swiper.onTouchMove = onTouchMove.bind(swiper), swiper.onTouchEnd = onTouchEnd.bind(swiper), params.cssMode && (swiper.onScroll = onScroll.bind(swiper)), swiper.onClick = onClick.bind(swiper), support.touch && !dummyEventAttached && (document.addEventListener(lS(0, 304), dummyEventListener), dummyEventAttached = !0), events(swiper, lS(0, 305));
    }
    function detachEvents() {
        const swiper = this;
        (() => {
            const __callInstance125 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        events(this, lS(0, 306));
                    }
                }
            });
            const __exports = __callInstance125.exports;
            return __exports.data();
        })();
    }
    var events$1;
    const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
    function setBreakpoint() {
        const swiper = this, {
                activeIndex: activeIndex,
                initialized: initialized,
                loopedSlides: loopedSlides = 0,
                params: params,
                $el: $el
            } = swiper, breakpoints = params.breakpoints;
        if (!breakpoints || breakpoints && 0 === Object.keys(breakpoints).length)
            return;
        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
        if (!breakpoint || swiper.currentBreakpoint === breakpoint)
            return;
        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0, breakpointParams = breakpointOnlyParams || swiper.originalParams, wasMultiRow = isGridEnabled(swiper, params), isMultiRow = isGridEnabled(swiper, breakpointParams), wasEnabled = params.enabled;
        wasMultiRow && !isMultiRow ? ($el.removeClass(`${ params.containerModifierClass }grid ${ params.containerModifierClass }grid-column`), swiper.emitContainerClasses()) : !wasMultiRow && isMultiRow && ($el.addClass(`${ params.containerModifierClass }grid`), (breakpointParams.grid.fill && lS(0, 307) === breakpointParams.grid.fill || !breakpointParams.grid.fill && lS(0, 308) === params.grid.fill) && $el.addClass(`${ params.containerModifierClass }grid-column`), swiper.emitContainerClasses()), [
            lS(0, 309),
            lS(0, 310),
            lS(0, 311)
        ].forEach(prop => {
            const wasModuleEnabled = params[prop] && params[prop].enabled, isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
            wasModuleEnabled && !isModuleEnabled && swiper[prop].disable(), !wasModuleEnabled && isModuleEnabled && swiper[prop].enable();
        });
        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction, needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
        directionChanged && initialized && swiper.changeDirection(), extend(swiper.params, breakpointParams);
        const isEnabled = swiper.params.enabled;
        Object.assign(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev
        }), wasEnabled && !isEnabled ? swiper.disable() : !wasEnabled && isEnabled && swiper.enable(), swiper.currentBreakpoint = breakpoint, swiper.emit(lS(0, 312), breakpointParams), needsReLoop && initialized && (swiper.loopDestroy(), swiper.loopCreate(), swiper.updateSlides(), swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, !1)), swiper.emit(lS(0, 313), breakpointParams);
    }
    function getBreakpoint(breakpoints, base, containerEl) {
        if (void 0 === base && (base = lS(0, 314)), !breakpoints || lS(0, 315) === base && !containerEl)
            return;
        let breakpoint = !1;
        const window = getWindow(), currentHeight = lS(0, 316) === base ? window.innerHeight : containerEl.clientHeight, points = Object.keys(breakpoints).map(point => {
                if (lS(0, 317) == typeof point && 0 === point.indexOf(lS(0, 318))) {
                    const minRatio = parseFloat(point.substr(1)), value = currentHeight * minRatio;
                    return {
                        value: value,
                        point: point
                    };
                }
                return {
                    value: point,
                    point: point
                };
            });
        (() => {
            const __callInstance124 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
                    }
                }
            });
            const __exports = __callInstance124.exports;
            return __exports.data();
        })();
        (() => {
            let i = 0;
            const __forInstance62 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < points.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const {
                                point: point,
                                value: value
                            } = points[i];
                            lS(0, 319) === base ? window.matchMedia(`(min-width: ${ value }px)`).matches && (breakpoint = point) : value <= containerEl.clientWidth && (breakpoint = point);
                        }
                    }
                }
            });
            const __exports = __forInstance62.exports;
            return __exports.data();
        })();
        return breakpoint || lS(0, 320);
    }
    var breakpoints, classes, images;
    function prepareClasses(entries, prefix) {
        const resultClasses = [];
        return entries.forEach(item => {
            lS(0, 321) == typeof item ? Object.keys(item).forEach(classNames => {
                item[classNames] && resultClasses.push(prefix + classNames);
            }) : lS(0, 322) == typeof item && resultClasses.push(prefix + item);
        }), resultClasses;
    }
    function addClasses() {
        const swiper = this, {
                classNames: classNames,
                params: params,
                rtl: rtl,
                $el: $el,
                device: device,
                support: support
            } = this, suffixes = prepareClasses([
                lS(0, 323),
                params.direction,
                { 'pointer-events': !support.touch },
                { 'free-mode': this.params.freeMode && params.freeMode.enabled },
                { autoheight: params.autoHeight },
                { rtl: rtl },
                { grid: params.grid && params.grid.rows > 1 },
                { 'grid-column': params.grid && params.grid.rows > 1 && lS(0, 324) === params.grid.fill },
                { android: device.android },
                { ios: device.ios },
                { 'css-mode': params.cssMode },
                { centered: params.cssMode && params.centeredSlides },
                { 'watch-progress': params.watchSlidesProgress }
            ], params.containerModifierClass);
        classNames.push(...suffixes), $el.addClass([...classNames].join(lS(0, 325))), this.emitContainerClasses();
    }
    function removeClasses() {
        const swiper = this, {
                $el: $el,
                classNames: classNames
            } = this;
        $el.removeClass(classNames.join(lS(0, 326))), this.emitContainerClasses();
    }
    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        const window = getWindow();
        let image;
        function onReady() {
            callback && callback();
        }
        const isPicture = $(imageEl).parent(lS(0, 327))[0];
        isPicture || imageEl.complete && checkForComplete ? onReady() : src ? (image = new window.Image(), image.onload = onReady, image.onerror = onReady, sizes && (image.sizes = sizes), srcset && (image.srcset = srcset), src && (image.src = src)) : onReady();
    }
    function preloadImages() {
        const swiper = this;
        function onReady() {
            null != swiper && swiper && !swiper.destroyed && (void 0 !== swiper.imagesLoaded && (swiper.imagesLoaded += 1), swiper.imagesLoaded === swiper.imagesToLoad.length && (swiper.params.updateOnImagesReady && swiper.update(), swiper.emit(lS(0, 328))));
        }
        swiper.imagesToLoad = swiper.$el.find(lS(0, 329));
        (() => {
            let i = 0;
            const __forInstance63 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < swiper.imagesToLoad.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        {
                            const imageEl = swiper.imagesToLoad[i];
                            (() => {
                                const __callInstance123 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute(lS(0, 330)), imageEl.srcset || imageEl.getAttribute(lS(0, 331)), imageEl.sizes || imageEl.getAttribute(lS(0, 332)), !0, onReady);
                                        }
                                    }
                                });
                                const __exports = __callInstance123.exports;
                                return __exports.data();
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance63.exports;
            return __exports.data();
        })();
    }
    function checkOverflow() {
        const swiper = this, {
                isLocked: wasLocked,
                params: params
            } = swiper, {slidesOffsetBefore: slidesOffsetBefore} = params;
        (() => {
            const __ifInstance39 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            const lastSlideIndex = swiper.slides.length - 1, lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + 2 * slidesOffsetBefore;
                            swiper.isLocked = swiper.size > lastSlideRightEdge;
                        }
                    },
                    impFunc2: () => {
                        swiper.isLocked = 1 === swiper.snapGrid.length;
                    }
                }
            });
            const __exports = __ifInstance39.exports;
            return __exports.data(slidesOffsetBefore ? 1 : 0);
        })();
        !0 === params.allowSlideNext && (swiper.allowSlideNext = !swiper.isLocked), !0 === params.allowSlidePrev && (swiper.allowSlidePrev = !swiper.isLocked), wasLocked && wasLocked !== swiper.isLocked && (swiper.isEnd = !1), wasLocked !== swiper.isLocked && swiper.emit(swiper.isLocked ? lS(0, 333) : lS(0, 334));
    }
    var checkOverflow$1, defaults = {
            init: !0,
            direction: 'horizontal',
            touchEventsTarget: 'wrapper',
            initialSlide: 0,
            speed: 300,
            cssMode: !1,
            updateOnWindowResize: !0,
            resizeObserver: !0,
            nested: !1,
            createElements: !1,
            enabled: !0,
            focusableElements: 'input, select, option, textarea, button, video, label',
            width: null,
            height: null,
            preventInteractionOnTransition: !1,
            userAgent: null,
            url: null,
            edgeSwipeDetection: !1,
            edgeSwipeThreshold: 20,
            autoHeight: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: 'slide',
            breakpoints: void 0,
            breakpointsBase: 'window',
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: !1,
            centeredSlides: !1,
            centeredSlidesBounds: !1,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: !0,
            centerInsufficientSlides: !1,
            watchOverflow: !0,
            roundLengths: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: !0,
            allowTouchMove: !0,
            threshold: 0,
            touchMoveStopPropagation: !1,
            touchStartPreventDefault: !0,
            touchStartForcePreventDefault: !1,
            touchReleaseOnEdges: !1,
            uniqueNavElements: !0,
            resistance: !0,
            resistanceRatio: 0.85,
            watchSlidesProgress: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            preloadImages: !0,
            updateOnImagesReady: !0,
            loop: !1,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopedSlidesLimit: !0,
            loopFillGroupWithBlank: !1,
            loopPreventsSlide: !0,
            rewind: !1,
            allowSlidePrev: !0,
            allowSlideNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: 'swiper-no-swiping',
            noSwipingSelector: null,
            passiveListeners: !0,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: 'swiper-',
            slideClass: 'swiper-slide',
            slideBlankClass: 'swiper-slide-invisible-blank',
            slideActiveClass: 'swiper-slide-active',
            slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
            slideVisibleClass: 'swiper-slide-visible',
            slideDuplicateClass: 'swiper-slide-duplicate',
            slideNextClass: 'swiper-slide-next',
            slideDuplicateNextClass: 'swiper-slide-duplicate-next',
            slidePrevClass: 'swiper-slide-prev',
            slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
            wrapperClass: 'swiper-wrapper',
            runCallbacksOnInit: !0,
            _emitClasses: !1
        };
    function moduleExtendParams(params, allModulesParams) {
        return function extendParams(obj) {
            void 0 === obj && (obj = {});
            const moduleParamName = Object.keys(obj)[0], moduleParams = obj[moduleParamName];
            lS(0, 335) == typeof moduleParams && null !== moduleParams ? ([
                lS(0, 336),
                lS(0, 337),
                lS(0, 338)
            ].indexOf(moduleParamName) >= 0 && !0 === params[moduleParamName] && (params[moduleParamName] = { auto: !0 }), moduleParamName in params && lS(0, 339) in moduleParams ? (!0 === params[moduleParamName] && (params[moduleParamName] = { enabled: !0 }), lS(0, 340) != typeof params[moduleParamName] || lS(0, 341) in params[moduleParamName] || (params[moduleParamName].enabled = !0), params[moduleParamName] || (params[moduleParamName] = { enabled: !1 }), extend(allModulesParams, obj)) : extend(allModulesParams, obj)) : extend(allModulesParams, obj);
        };
    }
    const prototypes = {
            eventsEmitter: eventsEmitter,
            update: {
                updateSize: updateSize,
                updateSlides: updateSlides,
                updateAutoHeight: updateAutoHeight,
                updateSlidesOffset: updateSlidesOffset,
                updateSlidesProgress: updateSlidesProgress,
                updateProgress: updateProgress,
                updateSlidesClasses: updateSlidesClasses,
                updateActiveIndex: updateActiveIndex,
                updateClickedSlide: updateClickedSlide
            },
            translate: {
                getTranslate: getSwiperTranslate,
                setTranslate: setTranslate,
                minTranslate: minTranslate,
                maxTranslate: maxTranslate,
                translateTo: translateTo
            },
            transition: {
                setTransition: setTransition,
                transitionStart: transitionStart,
                transitionEnd: transitionEnd
            },
            slide: {
                slideTo: slideTo,
                slideToLoop: slideToLoop,
                slideNext: slideNext,
                slidePrev: slidePrev,
                slideReset: slideReset,
                slideToClosest: slideToClosest,
                slideToClickedSlide: slideToClickedSlide
            },
            loop: {
                loopCreate: loopCreate,
                loopFix: loopFix,
                loopDestroy: loopDestroy
            },
            grabCursor: {
                setGrabCursor: setGrabCursor,
                unsetGrabCursor: unsetGrabCursor
            },
            events: {
                attachEvents: attachEvents,
                detachEvents: detachEvents
            },
            breakpoints: {
                setBreakpoint: setBreakpoint,
                getBreakpoint: getBreakpoint
            },
            checkOverflow: { checkOverflow: checkOverflow },
            classes: {
                addClasses: addClasses,
                removeClasses: removeClasses
            },
            images: {
                loadImage: loadImage,
                preloadImages: preloadImages
            }
        }, extendedDefaults = {};
    class Swiper {
        constructor() {
            let el, params;
            (() => {
                var _len = arguments.length, args = new Array(_len), _key = 0;
                const __forInstance64 = new WebAssembly.Instance(__forWasmModule, {
                    env: {
                        test: () => {
                            return _key < _len ? 1 : 0;
                        },
                        update: () => {
                            _key++;
                        },
                        body: () => {
                            args[_key] = arguments[_key];
                        }
                    }
                });
                const __exports = __forInstance64.exports;
                return __exports.data();
            })();
            if (1 === args.length && args[0].constructor && lS(0, 342) === Object.prototype.toString.call(args[0]).slice(8, -1) ? params = args[0] : [el, params] = args, params || (params = {}), params = extend({}, params), el && !params.el && (params.el = el), params.el && $(params.el).length > 1) {
                const swipers = [];
                return $(params.el).each(containerEl => {
                    const newParams = extend({}, params, { el: containerEl });
                    (() => {
                        const __callInstance122 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    swipers.push(new Swiper(newParams));
                                }
                            }
                        });
                        const __exports = __callInstance122.exports;
                        return __exports.data();
                    })();
                }), swipers;
            }
            const swiper = this;
            swiper.__swiper__ = !0, swiper.support = getSupport(), swiper.device = getDevice({ userAgent: params.userAgent }), swiper.browser = getBrowser(), swiper.eventsListeners = {}, swiper.eventsAnyListeners = [], swiper.modules = [...swiper.__modules__], params.modules && Array.isArray(params.modules) && swiper.modules.push(...params.modules);
            const allModulesParams = {};
            (() => {
                const __callInstance121 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            swiper.modules.forEach(mod => {
                                (() => {
                                    const __callInstance120 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                mod({
                                                    swiper: swiper,
                                                    extendParams: moduleExtendParams(params, allModulesParams),
                                                    on: swiper.on.bind(swiper),
                                                    once: swiper.once.bind(swiper),
                                                    off: swiper.off.bind(swiper),
                                                    emit: swiper.emit.bind(swiper)
                                                });
                                            }
                                        }
                                    });
                                    const __exports = __callInstance120.exports;
                                    return __exports.data();
                                })();
                            });
                        }
                    }
                });
                const __exports = __callInstance121.exports;
                return __exports.data();
            })();
            const swiperParams = extend({}, defaults, allModulesParams);
            return swiper.params = extend({}, swiperParams, extendedDefaults, params), swiper.originalParams = extend({}, swiper.params), swiper.passedParams = extend({}, params), swiper.params && swiper.params.on && Object.keys(swiper.params.on).forEach(eventName => {
                (() => {
                    const __callInstance119 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.on(eventName, swiper.params.on[eventName]);
                            }
                        }
                    });
                    const __exports = __callInstance119.exports;
                    return __exports.data();
                })();
            }), swiper.params && swiper.params.onAny && swiper.onAny(swiper.params.onAny), swiper.$ = $, Object.assign(swiper, {
                enabled: swiper.params.enabled,
                el: el,
                classNames: [],
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => lS(0, 343) === swiper.params.direction,
                isVertical: () => lS(0, 344) === swiper.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: function touchEvents() {
                    const touch = [
                            lS(0, 345),
                            lS(0, 346),
                            lS(0, 347),
                            lS(0, 348)
                        ], desktop = [
                            lS(0, 349),
                            lS(0, 350),
                            lS(0, 351)
                        ];
                    return swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                        cancel: touch[3]
                    }, swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2]
                    }, swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }(),
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: swiper.params.focusableElements,
                    lastClickTime: now(),
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    isTouchEvent: void 0,
                    startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }), swiper.emit(lS(0, 352)), swiper.params.init && swiper.init(), swiper;
        }
        enable() {
            const swiper = this;
            swiper.enabled || (swiper.enabled = !0, swiper.params.grabCursor && swiper.setGrabCursor(), swiper.emit(lS(0, 353)));
        }
        disable() {
            const swiper = this;
            swiper.enabled && (swiper.enabled = !1, swiper.params.grabCursor && swiper.unsetGrabCursor(), swiper.emit(lS(0, 354)));
        }
        setProgress(progress, speed) {
            const swiper = this;
            progress = Math.min(Math.max(progress, 0), 1);
            const min = this.minTranslate(), max = this.maxTranslate(), current = (max - min) * progress + min;
            this.translateTo(current, void 0 === speed ? 0 : speed), this.updateActiveIndex(), this.updateSlidesClasses();
        }
        emitContainerClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el)
                return;
            const cls = swiper.el.className.split(lS(0, 355)).filter(className => 0 === className.indexOf(lS(0, 356)) || 0 === className.indexOf(swiper.params.containerModifierClass));
            (() => {
                const __callInstance118 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            swiper.emit(lS(0, 357), cls.join(lS(0, 358)));
                        }
                    }
                });
                const __exports = __callInstance118.exports;
                return __exports.data();
            })();
        }
        getSlideClasses(slideEl) {
            const swiper = this;
            return swiper.destroyed ? lS(0, 359) : slideEl.className.split(lS(0, 360)).filter(className => 0 === className.indexOf(lS(0, 361)) || 0 === className.indexOf(swiper.params.slideClass)).join(lS(0, 362));
        }
        emitSlidesClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el)
                return;
            const updates = [];
            swiper.slides.each(slideEl => {
                const classNames = swiper.getSlideClasses(slideEl);
                updates.push({
                    slideEl: slideEl,
                    classNames: classNames
                }), swiper.emit(lS(0, 363), slideEl, classNames);
            }), swiper.emit(lS(0, 364), updates);
        }
        slidesPerViewDynamic(view, exact) {
            void 0 === view && (view = lS(0, 365)), void 0 === exact && (exact = !1);
            const swiper = this, {
                    params: params,
                    slides: slides,
                    slidesGrid: slidesGrid,
                    slidesSizesGrid: slidesSizesGrid,
                    size: swiperSize,
                    activeIndex: activeIndex
                } = this;
            let spv = 1;
            (() => {
                const __ifInstance40 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let slideSize = slides[activeIndex].swiperSlideSize, breakLoop;
                                (() => {
                                    let i = activeIndex + 1;
                                    const __forInstance65 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return i < slides.length ? 1 : 0;
                                            },
                                            update: () => {
                                                i += 1;
                                            },
                                            body: () => {
                                                slides[i] && !breakLoop && (slideSize += slides[i].swiperSlideSize, spv += 1, slideSize > swiperSize && (breakLoop = !0));
                                            }
                                        }
                                    });
                                    const __exports = __forInstance65.exports;
                                    return __exports.data();
                                })();
                                (() => {
                                    let i = activeIndex - 1;
                                    const __forInstance66 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return i >= 0 ? 1 : 0;
                                            },
                                            update: () => {
                                                i -= 1;
                                            },
                                            body: () => {
                                                slides[i] && !breakLoop && (slideSize += slides[i].swiperSlideSize, spv += 1, slideSize > swiperSize && (breakLoop = !0));
                                            }
                                        }
                                    });
                                    const __exports = __forInstance66.exports;
                                    return __exports.data();
                                })();
                            }
                        },
                        impFunc2: () => {
                            (() => {
                                const __ifInstance41 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            for (let i = activeIndex + 1; i < slides.length; i += 1) {
                                                const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                                                slideInView && (spv += 1);
                                            }
                                        },
                                        impFunc2: () => {
                                            for (let i = activeIndex - 1; i >= 0; i -= 1) {
                                                const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                                                slideInView && (spv += 1);
                                            }
                                        }
                                    }
                                });
                                const __exports = __ifInstance41.exports;
                                return __exports.data(lS(0, 366) === view ? 1 : 0);
                            })();
                        }
                    }
                });
                const __exports = __ifInstance40.exports;
                return __exports.data(params.centeredSlides ? 1 : 0);
            })();
            return spv;
        }
        update() {
            const swiper = this;
            if (!swiper || swiper.destroyed)
                return;
            const {
                snapGrid: snapGrid,
                params: params
            } = swiper;
            function setTranslate() {
                const translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate, newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
            }
            let translated;
            params.breakpoints && swiper.setBreakpoint(), swiper.updateSize(), swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses(), swiper.params.freeMode && swiper.params.freeMode.enabled ? (setTranslate(), swiper.params.autoHeight && swiper.updateAutoHeight()) : (translated = (lS(0, 367) === swiper.params.slidesPerView || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : swiper.slideTo(swiper.activeIndex, 0, !1, !0), translated || setTranslate()), params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow(), swiper.emit(lS(0, 368));
        }
        changeDirection(newDirection, needUpdate) {
            void 0 === needUpdate && (needUpdate = !0);
            const swiper = this, currentDirection = swiper.params.direction;
            return newDirection || (newDirection = lS(0, 369) === currentDirection ? lS(0, 370) : lS(0, 371)), newDirection === currentDirection || lS(0, 372) !== newDirection && lS(0, 373) !== newDirection ? swiper : (swiper.$el.removeClass(`${ swiper.params.containerModifierClass }${ currentDirection }`).addClass(`${ swiper.params.containerModifierClass }${ newDirection }`), swiper.emitContainerClasses(), swiper.params.direction = newDirection, swiper.slides.each(slideEl => {
                lS(0, 374) === newDirection ? slideEl.style.width = lS(0, 375) : slideEl.style.height = lS(0, 376);
            }), swiper.emit(lS(0, 377)), needUpdate && swiper.update(), swiper);
        }
        changeLanguageDirection(direction) {
            const swiper = this;
            swiper.rtl && lS(0, 378) === direction || !swiper.rtl && lS(0, 379) === direction || (swiper.rtl = lS(0, 380) === direction, swiper.rtlTranslate = lS(0, 381) === swiper.params.direction && swiper.rtl, swiper.rtl ? (swiper.$el.addClass(`${ swiper.params.containerModifierClass }rtl`), swiper.el.dir = lS(0, 382)) : (swiper.$el.removeClass(`${ swiper.params.containerModifierClass }rtl`), swiper.el.dir = lS(0, 383)), swiper.update());
        }
        mount(el) {
            const swiper = this;
            if (swiper.mounted)
                return !0;
            const $el = $(el || swiper.params.el);
            if (!(el = $el[0]))
                return !1;
            el.swiper = swiper;
            const getWrapperSelector = () => `.${ (swiper.params.wrapperClass || lS(0, 384)).trim().split(lS(0, 385)).join(lS(0, 386)) }`, getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = $(el.shadowRoot.querySelector(getWrapperSelector()));
                        return res.children = options => $el.children(options), res;
                    }
                    return $el.children ? $el.children(getWrapperSelector()) : $($el).children(getWrapperSelector());
                };
            let $wrapperEl = getWrapper();
            (() => {
                const __ifInstance42 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const document = getDocument(), wrapper = document.createElement(lS(0, 387));
                                $wrapperEl = $(wrapper), wrapper.className = swiper.params.wrapperClass, $el.append(wrapper), $el.children(`.${ swiper.params.slideClass }`).each(slideEl => {
                                    (() => {
                                        const __callInstance117 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    $wrapperEl.append(slideEl);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance117.exports;
                                        return __exports.data();
                                    })();
                                });
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance42.exports;
                return __exports.data(0 === $wrapperEl.length && swiper.params.createElements ? 1 : 0);
            })();
            return Object.assign(swiper, {
                $el: $el,
                el: el,
                $wrapperEl: $wrapperEl,
                wrapperEl: $wrapperEl[0],
                mounted: !0,
                rtl: lS(0, 388) === el.dir.toLowerCase() || lS(0, 389) === $el.css(lS(0, 390)),
                rtlTranslate: lS(0, 391) === swiper.params.direction && (lS(0, 392) === el.dir.toLowerCase() || lS(0, 393) === $el.css(lS(0, 394))),
                wrongRTL: lS(0, 395) === $wrapperEl.css(lS(0, 396))
            }), !0;
        }
        init(el) {
            const swiper = this;
            if (swiper.initialized)
                return swiper;
            const mounted = swiper.mount(el);
            return !1 === mounted ? swiper : (swiper.emit(lS(0, 397)), swiper.params.breakpoints && swiper.setBreakpoint(), swiper.addClasses(), swiper.params.loop && swiper.loopCreate(), swiper.updateSize(), swiper.updateSlides(), swiper.params.watchOverflow && swiper.checkOverflow(), swiper.params.grabCursor && swiper.enabled && swiper.setGrabCursor(), swiper.params.preloadImages && swiper.preloadImages(), swiper.params.loop ? swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, !1, !0) : swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, !1, !0), swiper.attachEvents(), swiper.initialized = !0, swiper.emit(lS(0, 398)), swiper.emit(lS(0, 399)), swiper);
        }
        destroy(deleteInstance, cleanStyles) {
            void 0 === deleteInstance && (deleteInstance = !0), void 0 === cleanStyles && (cleanStyles = !0);
            const swiper = this, {
                    params: params,
                    $el: $el,
                    $wrapperEl: $wrapperEl,
                    slides: slides
                } = swiper;
            return void 0 === swiper.params || swiper.destroyed ? null : (swiper.emit(lS(0, 400)), swiper.initialized = !1, swiper.detachEvents(), params.loop && swiper.loopDestroy(), cleanStyles && (swiper.removeClasses(), $el.removeAttr(lS(0, 401)), $wrapperEl.removeAttr(lS(0, 402)), slides && slides.length && slides.removeClass([
                params.slideVisibleClass,
                params.slideActiveClass,
                params.slideNextClass,
                params.slidePrevClass
            ].join(lS(0, 403))).removeAttr(lS(0, 404)).removeAttr(lS(0, 405))), swiper.emit(lS(0, 406)), Object.keys(swiper.eventsListeners).forEach(eventName => {
                (() => {
                    const __callInstance116 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.off(eventName);
                            }
                        }
                    });
                    const __exports = __callInstance116.exports;
                    return __exports.data();
                })();
            }), !1 !== deleteInstance && (swiper.$el[0].swiper = null, deleteProps(swiper)), swiper.destroyed = !0, null);
        }
        static extendDefaults(newDefaults) {
            (() => {
                const __callInstance115 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            extend(extendedDefaults, newDefaults);
                        }
                    }
                });
                const __exports = __callInstance115.exports;
                return __exports.data();
            })();
        }
        static get extendedDefaults() {
            return extendedDefaults;
        }
        static get defaults() {
            return defaults;
        }
        static installModule(mod) {
            Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
            const modules = Swiper.prototype.__modules__;
            lS(0, 407) == typeof mod && modules.indexOf(mod) < 0 && modules.push(mod);
        }
        static use(module) {
            return Array.isArray(module) ? (module.forEach(m => Swiper.installModule(m)), Swiper) : (Swiper.installModule(module), Swiper);
        }
    }
    function Virtual(_ref) {
        let {
                swiper: swiper,
                extendParams: extendParams,
                on: on,
                emit: emit
            } = _ref, cssModeTimeout;
        function renderSlide(slide, index) {
            const params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index])
                return swiper.virtual.cache[index];
            const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${ swiper.params.slideClass }" data-swiper-slide-index="${ index }">${ slide }</div>`);
            return $slideEl.attr(lS(0, 408)) || $slideEl.attr(lS(0, 409), index), params.cache && (swiper.virtual.cache[index] = $slideEl), $slideEl;
        }
        function update(force) {
            const {
                    slidesPerView: slidesPerView,
                    slidesPerGroup: slidesPerGroup,
                    centeredSlides: centeredSlides
                } = swiper.params, {
                    addSlidesBefore: addSlidesBefore,
                    addSlidesAfter: addSlidesAfter
                } = swiper.params.virtual, {
                    from: previousFrom,
                    to: previousTo,
                    slides: slides,
                    slidesGrid: previousSlidesGrid,
                    offset: previousOffset
                } = swiper.virtual;
            swiper.params.cssMode || swiper.updateActiveIndex();
            const activeIndex = swiper.activeIndex || 0;
            let offsetProp, slidesAfter, slidesBefore;
            offsetProp = swiper.rtlTranslate ? lS(0, 410) : swiper.isHorizontal() ? lS(0, 411) : lS(0, 412), centeredSlides ? (slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter, slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore) : (slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter, slidesBefore = slidesPerGroup + addSlidesBefore);
            const from = Math.max((activeIndex || 0) - slidesBefore, 0), to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1), offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            function onRendered() {
                swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses(), swiper.lazy && swiper.params.lazy.enabled && swiper.lazy.load(), emit(lS(0, 413));
            }
            if (Object.assign(swiper.virtual, {
                    from: from,
                    to: to,
                    offset: offset,
                    slidesGrid: swiper.slidesGrid
                }), previousFrom === from && previousTo === to && !force)
                return swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset && swiper.slides.css(offsetProp, `${ offset }px`), swiper.updateProgress(), void emit(lS(0, 414));
            if (swiper.params.virtual.renderExternal)
                return swiper.params.virtual.renderExternal.call(swiper, {
                    offset: offset,
                    from: from,
                    to: to,
                    slides: function getSlides() {
                        const slidesToRender = [];
                        (() => {
                            let i = from;
                            const __forInstance69 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return i <= to ? 1 : 0;
                                    },
                                    update: () => {
                                        i += 1;
                                    },
                                    body: () => {
                                        (() => {
                                            const __callInstance114 = new WebAssembly.Instance(__callWasmModule, {
                                                env: {
                                                    impFunc: () => {
                                                        slidesToRender.push(slides[i]);
                                                    }
                                                }
                                            });
                                            const __exports = __callInstance114.exports;
                                            return __exports.data();
                                        })();
                                    }
                                }
                            });
                            const __exports = __forInstance69.exports;
                            return __exports.data();
                        })();
                        return slidesToRender;
                    }()
                }), void (swiper.params.virtual.renderExternalUpdate ? onRendered() : emit(lS(0, 415)));
            const prependIndexes = [], appendIndexes = [];
            (() => {
                const __ifInstance43 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            (() => {
                                const __callInstance113 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            swiper.$wrapperEl.find(`.${ swiper.params.slideClass }`).remove();
                                        }
                                    }
                                });
                                const __exports = __callInstance113.exports;
                                return __exports.data();
                            })();
                        },
                        impFunc2: () => {
                            for (let i = previousFrom; i <= previousTo; i += 1)
                                (i < from || i > to) && swiper.$wrapperEl.find(`.${ swiper.params.slideClass }[data-swiper-slide-index="${ i }"]`).remove();
                        }
                    }
                });
                const __exports = __ifInstance43.exports;
                return __exports.data(force ? 1 : 0);
            })();
            (() => {
                let i = 0;
                const __forInstance71 = new WebAssembly.Instance(__forWasmModule, {
                    env: {
                        test: () => {
                            return i < slides.length ? 1 : 0;
                        },
                        update: () => {
                            i += 1;
                        },
                        body: () => {
                            i >= from && i <= to && (void 0 === previousTo || force ? appendIndexes.push(i) : (i > previousTo && appendIndexes.push(i), i < previousFrom && prependIndexes.push(i)));
                        }
                    }
                });
                const __exports = __forInstance71.exports;
                return __exports.data();
            })();
            appendIndexes.forEach(index => {
                (() => {
                    const __callInstance112 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.$wrapperEl.append(renderSlide(slides[index], index));
                            }
                        }
                    });
                    const __exports = __callInstance112.exports;
                    return __exports.data();
                })();
            }), prependIndexes.sort((a, b) => b - a).forEach(index => {
                (() => {
                    const __callInstance111 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
                            }
                        }
                    });
                    const __exports = __callInstance111.exports;
                    return __exports.data();
                })();
            }), swiper.$wrapperEl.children(lS(0, 416)).css(offsetProp, `${ offset }px`), onRendered();
        }
        function appendSlide(slides) {
            (() => {
                const __ifInstance44 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            for (let i = 0; i < slides.length; i += 1)
                                slides[i] && swiper.virtual.slides.push(slides[i]);
                        },
                        impFunc2: () => {
                            (() => {
                                const __callInstance110 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            swiper.virtual.slides.push(slides);
                                        }
                                    }
                                });
                                const __exports = __callInstance110.exports;
                                return __exports.data();
                            })();
                        }
                    }
                });
                const __exports = __ifInstance44.exports;
                return __exports.data(lS(0, 417) == typeof slides && lS(0, 418) in slides ? 1 : 0);
            })();
            (() => {
                const __callInstance109 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            update(!0);
                        }
                    }
                });
                const __exports = __callInstance109.exports;
                return __exports.data();
            })();
        }
        function prependSlide(slides) {
            const activeIndex = swiper.activeIndex;
            let newActiveIndex = activeIndex + 1, numberOfNewSlides = 1;
            (() => {
                const __ifInstance45 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                (() => {
                                    let i = 0;
                                    const __forInstance73 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return i < slides.length ? 1 : 0;
                                            },
                                            update: () => {
                                                i += 1;
                                            },
                                            body: () => {
                                                slides[i] && swiper.virtual.slides.unshift(slides[i]);
                                            }
                                        }
                                    });
                                    const __exports = __forInstance73.exports;
                                    return __exports.data();
                                })();
                                newActiveIndex = activeIndex + slides.length, numberOfNewSlides = slides.length;
                            }
                        },
                        impFunc2: () => {
                            (() => {
                                const __callInstance108 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            swiper.virtual.slides.unshift(slides);
                                        }
                                    }
                                });
                                const __exports = __callInstance108.exports;
                                return __exports.data();
                            })();
                        }
                    }
                });
                const __exports = __ifInstance45.exports;
                return __exports.data(Array.isArray(slides) ? 1 : 0);
            })();
            (() => {
                const __ifInstance46 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const cache = swiper.virtual.cache, newCache = {};
                                Object.keys(cache).forEach(cachedIndex => {
                                    const $cachedEl = cache[cachedIndex], cachedElIndex = $cachedEl.attr(lS(0, 419));
                                    cachedElIndex && $cachedEl.attr(lS(0, 420), parseInt(cachedElIndex, 10) + numberOfNewSlides), newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
                                }), swiper.virtual.cache = newCache;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance46.exports;
                return __exports.data(swiper.params.virtual.cache ? 1 : 0);
            })();
            update(!0), swiper.slideTo(newActiveIndex, 0);
        }
        function removeSlide(slidesIndexes) {
            if (null == slidesIndexes)
                return;
            let activeIndex = swiper.activeIndex;
            (() => {
                const __ifInstance47 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            for (let i = slidesIndexes.length - 1; i >= 0; i -= 1)
                                swiper.virtual.slides.splice(slidesIndexes[i], 1), swiper.params.virtual.cache && delete swiper.virtual.cache[slidesIndexes[i]], slidesIndexes[i] < activeIndex && (activeIndex -= 1), activeIndex = Math.max(activeIndex, 0);
                        },
                        impFunc2: () => {
                            swiper.virtual.slides.splice(slidesIndexes, 1), swiper.params.virtual.cache && delete swiper.virtual.cache[slidesIndexes], slidesIndexes < activeIndex && (activeIndex -= 1), activeIndex = Math.max(activeIndex, 0);
                        }
                    }
                });
                const __exports = __ifInstance47.exports;
                return __exports.data(Array.isArray(slidesIndexes) ? 1 : 0);
            })();
            update(!0), swiper.slideTo(activeIndex, 0);
        }
        function removeAllSlides() {
            swiper.virtual.slides = [], swiper.params.virtual.cache && (swiper.virtual.cache = {}), update(!0), swiper.slideTo(0, 0);
        }
        extendParams({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        }), swiper.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        }, on(lS(0, 421), () => {
            swiper.params.virtual.enabled && (swiper.virtual.slides = swiper.params.virtual.slides, swiper.classNames.push(`${ swiper.params.containerModifierClass }virtual`), swiper.params.watchSlidesProgress = !0, swiper.originalParams.watchSlidesProgress = !0, swiper.params.initialSlide || update());
        }), on(lS(0, 422), () => {
            swiper.params.virtual.enabled && (swiper.params.cssMode && !swiper._immediateVirtual ? (clearTimeout(cssModeTimeout), cssModeTimeout = setTimeout(() => {
                (() => {
                    const __callInstance107 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                update();
                            }
                        }
                    });
                    const __exports = __callInstance107.exports;
                    return __exports.data();
                })();
            }, 100)) : update());
        }), on(lS(0, 423), () => {
            swiper.params.virtual.enabled && swiper.params.cssMode && setCSSProperty(swiper.wrapperEl, lS(0, 424), `${ swiper.virtualSize }px`);
        }), Object.assign(swiper.virtual, {
            appendSlide: appendSlide,
            prependSlide: prependSlide,
            removeSlide: removeSlide,
            removeAllSlides: removeAllSlides,
            update: update
        });
    }
    function Keyboard(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        const document = getDocument(), window = getWindow();
        function handle(event) {
            if (!swiper.enabled)
                return;
            const {rtlTranslate: rtl} = swiper;
            let e = event;
            e.originalEvent && (e = e.originalEvent);
            const kc = e.keyCode || e.charCode, pageUpDown = swiper.params.keyboard.pageUpDown, isPageUp = pageUpDown && 33 === kc, isPageDown = pageUpDown && 34 === kc, isArrowLeft = 37 === kc, isArrowRight = 39 === kc, isArrowUp = 38 === kc, isArrowDown = 40 === kc;
            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown))
                return !1;
            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp))
                return !1;
            if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || document.activeElement && document.activeElement.nodeName && (lS(0, 425) === document.activeElement.nodeName.toLowerCase() || lS(0, 426) === document.activeElement.nodeName.toLowerCase()))) {
                if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
                    let inView = !1;
                    if (swiper.$el.parents(`.${ swiper.params.slideClass }`).length > 0 && 0 === swiper.$el.parents(`.${ swiper.params.slideActiveClass }`).length)
                        return;
                    const $el = swiper.$el, swiperWidth = $el[0].clientWidth, swiperHeight = $el[0].clientHeight, windowWidth = window.innerWidth, windowHeight = window.innerHeight, swiperOffset = swiper.$el.offset();
                    rtl && (swiperOffset.left -= swiper.$el[0].scrollLeft);
                    const swiperCoord = [
                        [
                            swiperOffset.left,
                            swiperOffset.top
                        ],
                        [
                            swiperOffset.left + swiperWidth,
                            swiperOffset.top
                        ],
                        [
                            swiperOffset.left,
                            swiperOffset.top + swiperHeight
                        ],
                        [
                            swiperOffset.left + swiperWidth,
                            swiperOffset.top + swiperHeight
                        ]
                    ];
                    for (let i = 0; i < swiperCoord.length; i += 1) {
                        const point = swiperCoord[i];
                        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                            if (0 === point[0] && 0 === point[1])
                                continue;
                            inView = !0;
                        }
                    }
                    if (!inView)
                        return;
                }
                swiper.isHorizontal() ? ((isPageUp || isPageDown || isArrowLeft || isArrowRight) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) && swiper.slideNext(), ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) && swiper.slidePrev()) : ((isPageUp || isPageDown || isArrowUp || isArrowDown) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), (isPageDown || isArrowDown) && swiper.slideNext(), (isPageUp || isArrowUp) && swiper.slidePrev()), emit(lS(0, 427), kc);
            }
        }
        function enable() {
            swiper.keyboard.enabled || ($(document).on(lS(0, 428), handle), swiper.keyboard.enabled = !0);
        }
        function disable() {
            swiper.keyboard.enabled && ($(document).off(lS(0, 429), handle), swiper.keyboard.enabled = !1);
        }
        swiper.keyboard = { enabled: !1 }, extendParams({
            keyboard: {
                enabled: !1,
                onlyInViewport: !0,
                pageUpDown: !0
            }
        }), on(lS(0, 430), () => {
            swiper.params.keyboard.enabled && enable();
        }), on(lS(0, 431), () => {
            swiper.keyboard.enabled && disable();
        }), Object.assign(swiper.keyboard, {
            enable: enable,
            disable: disable
        });
    }
    function Mousewheel(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        const window = getWindow();
        let timeout;
        extendParams({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: 'container',
                thresholdDelta: null,
                thresholdTime: null
            }
        }), swiper.mousewheel = { enabled: !1 };
        let lastScrollTime = now(), lastEventBeforeSnap;
        const recentWheelEvents = [];
        function normalize(e) {
            const PIXEL_STEP = 10, LINE_HEIGHT = 40, PAGE_HEIGHT = 800;
            let sX = 0, sY = 0, pX = 0, pY = 0;
            return lS(0, 432) in e && (sY = e.detail), lS(0, 433) in e && (sY = -e.wheelDelta / 120), lS(0, 434) in e && (sY = -e.wheelDeltaY / 120), lS(0, 435) in e && (sX = -e.wheelDeltaX / 120), lS(0, 436) in e && e.axis === e.HORIZONTAL_AXIS && (sX = sY, sY = 0), pX = 10 * sX, pY = 10 * sY, lS(0, 437) in e && (pY = e.deltaY), lS(0, 438) in e && (pX = e.deltaX), e.shiftKey && !pX && (pX = pY, pY = 0), (pX || pY) && e.deltaMode && (1 === e.deltaMode ? (pX *= 40, pY *= 40) : (pX *= 800, pY *= 800)), pX && !sX && (sX = pX < 1 ? -1 : 1), pY && !sY && (sY = pY < 1 ? -1 : 1), {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }
        function handleMouseEnter() {
            swiper.enabled && (swiper.mouseEntered = !0);
        }
        function handleMouseLeave() {
            swiper.enabled && (swiper.mouseEntered = !1);
        }
        function animateSlider(newEvent) {
            return !(swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) && (!(swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) && (newEvent.delta >= 6 && now() - lastScrollTime < 60 || (newEvent.direction < 0 ? swiper.isEnd && !swiper.params.loop || swiper.animating || (swiper.slideNext(), emit(lS(0, 439), newEvent.raw)) : swiper.isBeginning && !swiper.params.loop || swiper.animating || (swiper.slidePrev(), emit(lS(0, 440), newEvent.raw)), lastScrollTime = new window.Date().getTime(), !1)));
        }
        function releaseScroll(newEvent) {
            const params = swiper.params.mousewheel;
            if (newEvent.direction < 0) {
                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges)
                    return !0;
            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges)
                return !0;
            return !1;
        }
        function handle(event) {
            let e = event, disableParentSwiper = !0;
            if (!swiper.enabled)
                return;
            const params = swiper.params.mousewheel;
            swiper.params.cssMode && e.preventDefault();
            let target = swiper.$el;
            if (lS(0, 441) !== swiper.params.mousewheel.eventsTarget && (target = $(swiper.params.mousewheel.eventsTarget)), !swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges)
                return !0;
            e.originalEvent && (e = e.originalEvent);
            let delta = 0;
            const rtlFactor = swiper.rtlTranslate ? -1 : 1, data = normalize(e);
            if (params.forceToAxis)
                if (swiper.isHorizontal()) {
                    if (!(Math.abs(data.pixelX) > Math.abs(data.pixelY)))
                        return !0;
                    delta = -data.pixelX * rtlFactor;
                } else {
                    if (!(Math.abs(data.pixelY) > Math.abs(data.pixelX)))
                        return !0;
                    delta = -data.pixelY;
                }
            else
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            if (0 === delta)
                return !0;
            params.invert && (delta = -delta);
            let positions = swiper.getTranslate() + delta * params.sensitivity;
            if (positions >= swiper.minTranslate() && (positions = swiper.minTranslate()), positions <= swiper.maxTranslate() && (positions = swiper.maxTranslate()), disableParentSwiper = !!swiper.params.loop || !(positions === swiper.minTranslate() || positions === swiper.maxTranslate()), disableParentSwiper && swiper.params.nested && e.stopPropagation(), swiper.params.freeMode && swiper.params.freeMode.enabled) {
                const newEvent = {
                        time: now(),
                        delta: Math.abs(delta),
                        direction: Math.sign(delta)
                    }, ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                if (!ignoreWheelEvents) {
                    lastEventBeforeSnap = void 0, swiper.params.loop && swiper.loopFix();
                    let position = swiper.getTranslate() + delta * params.sensitivity;
                    const wasBeginning = swiper.isBeginning, wasEnd = swiper.isEnd;
                    (() => {
                        const __ifInstance48 = new WebAssembly.Instance(__ifWasmModule, {
                            env: {
                                impFunc1: () => {
                                    {
                                        clearTimeout(timeout), timeout = void 0, recentWheelEvents.length >= 15 && recentWheelEvents.shift();
                                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0, firstEvent = recentWheelEvents[0];
                                        (() => {
                                            const __ifInstance49 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        (() => {
                                                            const __callInstance106 = new WebAssembly.Instance(__callWasmModule, {
                                                                env: {
                                                                    impFunc: () => {
                                                                        recentWheelEvents.splice(0);
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __callInstance106.exports;
                                                            return __exports.data();
                                                        })();
                                                    },
                                                    impFunc2: () => {
                                                        (() => {
                                                            const __ifInstance50 = new WebAssembly.Instance(__ifWasmModule, {
                                                                env: {
                                                                    impFunc1: () => {
                                                                        {
                                                                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                                                                            lastEventBeforeSnap = newEvent, recentWheelEvents.splice(0), timeout = nextTick(() => {
                                                                                (() => {
                                                                                    const __callInstance105 = new WebAssembly.Instance(__callWasmModule, {
                                                                                        env: {
                                                                                            impFunc: () => {
                                                                                                swiper.slideToClosest(swiper.params.speed, !0, void 0, snapToThreshold);
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                    const __exports = __callInstance105.exports;
                                                                                    return __exports.data();
                                                                                })();
                                                                            }, 0);
                                                                        }
                                                                    },
                                                                    impFunc2: () => {
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __ifInstance50.exports;
                                                            return __exports.data(recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6 ? 1 : 0);
                                                        })();
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance49.exports;
                                            return __exports.data((recentWheelEvents.push(newEvent), prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) ? 1 : 0);
                                        })();
                                        timeout || (timeout = nextTick(() => {
                                            const snapToThreshold = 0.5;
                                            lastEventBeforeSnap = newEvent, recentWheelEvents.splice(0), swiper.slideToClosest(swiper.params.speed, !0, void 0, 0.5);
                                        }, 500));
                                    }
                                },
                                impFunc2: () => {
                                }
                            }
                        });
                        const __exports = __ifInstance48.exports;
                        return __exports.data((position >= swiper.minTranslate() && (position = swiper.minTranslate()), position <= swiper.maxTranslate() && (position = swiper.maxTranslate()), swiper.setTransition(0), swiper.setTranslate(position), swiper.updateProgress(), swiper.updateActiveIndex(), swiper.updateSlidesClasses(), (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) && swiper.updateSlidesClasses(), swiper.params.freeMode.sticky) ? 1 : 0);
                    })();
                    if (ignoreWheelEvents || emit(lS(0, 442), e), swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction && swiper.autoplay.stop(), position === swiper.minTranslate() || position === swiper.maxTranslate())
                        return !0;
                }
            } else {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta),
                    raw: event
                };
                recentWheelEvents.length >= 2 && recentWheelEvents.shift();
                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
                if (recentWheelEvents.push(newEvent), prevEvent ? (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) && animateSlider(newEvent) : animateSlider(newEvent), releaseScroll(newEvent))
                    return !0;
            }
            return e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1;
        }
        function events(method) {
            let target = swiper.$el;
            lS(0, 443) !== swiper.params.mousewheel.eventsTarget && (target = $(swiper.params.mousewheel.eventsTarget)), target[method](lS(0, 444), handleMouseEnter), target[method](lS(0, 445), handleMouseLeave), target[method](lS(0, 446), handle);
        }
        function enable() {
            return swiper.params.cssMode ? (swiper.wrapperEl.removeEventListener(lS(0, 447), handle), !0) : !swiper.mousewheel.enabled && (events(lS(0, 448)), swiper.mousewheel.enabled = !0, !0);
        }
        function disable() {
            return swiper.params.cssMode ? (swiper.wrapperEl.addEventListener(event, handle), !0) : !!swiper.mousewheel.enabled && (events(lS(0, 449)), swiper.mousewheel.enabled = !1, !0);
        }
        on(lS(0, 450), () => {
            !swiper.params.mousewheel.enabled && swiper.params.cssMode && disable(), swiper.params.mousewheel.enabled && enable();
        }), on(lS(0, 451), () => {
            swiper.params.cssMode && enable(), swiper.mousewheel.enabled && disable();
        }), Object.assign(swiper.mousewheel, {
            enable: enable,
            disable: disable
        });
    }
    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
        const document = getDocument();
        return swiper.params.createElements && Object.keys(checkProps).forEach(key => {
            (() => {
                const __ifInstance51 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let element = swiper.$el.children(`.${ checkProps[key] }`)[0];
                                element || (element = document.createElement(lS(0, 452)), element.className = checkProps[key], swiper.$el.append(element)), params[key] = element, originalParams[key] = element;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance51.exports;
                return __exports.data(!params[key] && !0 === params.auto ? 1 : 0);
            })();
        }), params;
    }
    function Navigation(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        function getEl(el) {
            let $el;
            return el && ($el = $(el), swiper.params.uniqueNavElements && lS(0, 453) == typeof el && $el.length > 1 && 1 === swiper.$el.find(el).length && ($el = swiper.$el.find(el))), $el;
        }
        function toggleEl($el, disabled) {
            const params = swiper.params.navigation;
            $el && $el.length > 0 && ($el[disabled ? lS(0, 454) : lS(0, 455)](params.disabledClass), $el[0] && lS(0, 456) === $el[0].tagName && ($el[0].disabled = disabled), swiper.params.watchOverflow && swiper.enabled && $el[swiper.isLocked ? lS(0, 457) : lS(0, 458)](params.lockClass));
        }
        function update() {
            if (swiper.params.loop)
                return;
            const {
                $nextEl: $nextEl,
                $prevEl: $prevEl
            } = swiper.navigation;
            toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind), toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
        }
        function onPrevClick(e) {
            e.preventDefault(), (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) && (swiper.slidePrev(), emit(lS(0, 459)));
        }
        function onNextClick(e) {
            e.preventDefault(), (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) && (swiper.slideNext(), emit(lS(0, 460)));
        }
        function init() {
            const params = swiper.params.navigation;
            if (swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: 'swiper-button-next',
                    prevEl: 'swiper-button-prev'
                }), !params.nextEl && !params.prevEl)
                return;
            const $nextEl = getEl(params.nextEl), $prevEl = getEl(params.prevEl);
            $nextEl && $nextEl.length > 0 && $nextEl.on(lS(0, 461), onNextClick), $prevEl && $prevEl.length > 0 && $prevEl.on(lS(0, 462), onPrevClick), Object.assign(swiper.navigation, {
                $nextEl: $nextEl,
                nextEl: $nextEl && $nextEl[0],
                $prevEl: $prevEl,
                prevEl: $prevEl && $prevEl[0]
            }), swiper.enabled || ($nextEl && $nextEl.addClass(params.lockClass), $prevEl && $prevEl.addClass(params.lockClass));
        }
        function destroy() {
            const {
                $nextEl: $nextEl,
                $prevEl: $prevEl
            } = swiper.navigation;
            $nextEl && $nextEl.length && ($nextEl.off(lS(0, 463), onNextClick), $nextEl.removeClass(swiper.params.navigation.disabledClass)), $prevEl && $prevEl.length && ($prevEl.off(lS(1, 0), onPrevClick), $prevEl.removeClass(swiper.params.navigation.disabledClass));
        }
        extendParams({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: 'swiper-button-disabled',
                hiddenClass: 'swiper-button-hidden',
                lockClass: 'swiper-button-lock',
                navigationDisabledClass: 'swiper-navigation-disabled'
            }
        }), swiper.navigation = {
            nextEl: null,
            $nextEl: null,
            prevEl: null,
            $prevEl: null
        }, on(lS(1, 1), () => {
            !1 === swiper.params.navigation.enabled ? disable() : (init(), update());
        }), on(lS(1, 2), () => {
            (() => {
                const __callInstance104 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            update();
                        }
                    }
                });
                const __exports = __callInstance104.exports;
                return __exports.data();
            })();
        }), on(lS(1, 3), () => {
            (() => {
                const __callInstance103 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            destroy();
                        }
                    }
                });
                const __exports = __callInstance103.exports;
                return __exports.data();
            })();
        }), on(lS(1, 4), () => {
            const {
                $nextEl: $nextEl,
                $prevEl: $prevEl
            } = swiper.navigation;
            $nextEl && $nextEl[swiper.enabled ? lS(1, 5) : lS(1, 6)](swiper.params.navigation.lockClass), $prevEl && $prevEl[swiper.enabled ? lS(1, 7) : lS(1, 8)](swiper.params.navigation.lockClass);
        }), on(lS(1, 9), (_s, e) => {
            const {
                    $nextEl: $nextEl,
                    $prevEl: $prevEl
                } = swiper.navigation, targetEl = e.target;
            if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
                    return;
                let isHidden;
                $nextEl ? isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass) : $prevEl && (isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass)), emit(!0 === isHidden ? lS(1, 10) : lS(1, 11)), $nextEl && $nextEl.toggleClass(swiper.params.navigation.hiddenClass), $prevEl && $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
            }
        });
        const enable = () => {
                swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass), init(), update();
            }, disable = () => {
                swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass), destroy();
            };
        (() => {
            const __callInstance102 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.assign(swiper.navigation, {
                            enable: enable,
                            disable: disable,
                            update: update,
                            init: init,
                            destroy: destroy
                        });
                    }
                }
            });
            const __exports = __callInstance102.exports;
            return __exports.data();
        })();
    }
    function classesToSelector(classes) {
        return void 0 === classes && (classes = lS(1, 12)), `.${ classes.trim().replace(/([\.:!\/])/g, lS(1, 13)).replace(/ /g, lS(1, 14)) }`;
    }
    function Pagination(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        const pfx = lS(1, 15);
        let bulletSize;
        extendParams({
            pagination: {
                el: null,
                bulletElement: 'span',
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: 'bullets',
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: number => number,
                formatFractionTotal: number => number,
                bulletClass: `${ pfx }-bullet`,
                bulletActiveClass: `${ pfx }-bullet-active`,
                modifierClass: `${ pfx }-`,
                currentClass: `${ pfx }-current`,
                totalClass: `${ pfx }-total`,
                hiddenClass: `${ pfx }-hidden`,
                progressbarFillClass: `${ pfx }-progressbar-fill`,
                progressbarOppositeClass: `${ pfx }-progressbar-opposite`,
                clickableClass: `${ pfx }-clickable`,
                lockClass: `${ pfx }-lock`,
                horizontalClass: `${ pfx }-horizontal`,
                verticalClass: `${ pfx }-vertical`,
                paginationDisabledClass: `${ pfx }-disabled`
            }
        }), swiper.pagination = {
            el: null,
            $el: null,
            bullets: []
        };
        let dynamicBulletIndex = 0;
        function isPaginationDisabled() {
            return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || 0 === swiper.pagination.$el.length;
        }
        function setSideBullets($bulletEl, position) {
            const {bulletActiveClass: bulletActiveClass} = swiper.params.pagination;
            (() => {
                const __callInstance101 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $bulletEl[position]().addClass(`${ bulletActiveClass }-${ position }`)[position]().addClass(`${ bulletActiveClass }-${ position }-${ position }`);
                        }
                    }
                });
                const __exports = __callInstance101.exports;
                return __exports.data();
            })();
        }
        function update() {
            const rtl = swiper.rtl, params = swiper.params.pagination;
            if (isPaginationDisabled())
                return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length, $el = swiper.pagination.$el;
            let current;
            const total = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            (() => {
                const __ifInstance52 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                const bullets = swiper.pagination.bullets;
                                let firstIndex, lastIndex, midIndex;
                                (() => {
                                    const __ifInstance53 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                (() => {
                                                    const __callInstance100 = new WebAssembly.Instance(__callWasmModule, {
                                                        env: {
                                                            impFunc: () => {
                                                                bullets.each(bullet => {
                                                                    const $bullet = $(bullet), bulletIndex = $bullet.index();
                                                                    bulletIndex === current && $bullet.addClass(params.bulletActiveClass), params.dynamicBullets && (bulletIndex >= firstIndex && bulletIndex <= lastIndex && $bullet.addClass(`${ params.bulletActiveClass }-main`), bulletIndex === firstIndex && setSideBullets($bullet, lS(1, 29)), bulletIndex === lastIndex && setSideBullets($bullet, lS(1, 30)));
                                                                });
                                                            }
                                                        }
                                                    });
                                                    const __exports = __callInstance100.exports;
                                                    return __exports.data();
                                                })();
                                            },
                                            impFunc2: () => {
                                                {
                                                    const $bullet = bullets.eq(current), bulletIndex = $bullet.index();
                                                    (() => {
                                                        const __ifInstance54 = new WebAssembly.Instance(__ifWasmModule, {
                                                            env: {
                                                                impFunc1: () => {
                                                                    {
                                                                        const $firstDisplayedBullet = bullets.eq(firstIndex), $lastDisplayedBullet = bullets.eq(lastIndex);
                                                                        (() => {
                                                                            let i = firstIndex;
                                                                            const __forInstance75 = new WebAssembly.Instance(__forWasmModule, {
                                                                                env: {
                                                                                    test: () => {
                                                                                        return i <= lastIndex ? 1 : 0;
                                                                                    },
                                                                                    update: () => {
                                                                                        i += 1;
                                                                                    },
                                                                                    body: () => {
                                                                                        (() => {
                                                                                            const __callInstance99 = new WebAssembly.Instance(__callWasmModule, {
                                                                                                env: {
                                                                                                    impFunc: () => {
                                                                                                        bullets.eq(i).addClass(`${ params.bulletActiveClass }-main`);
                                                                                                    }
                                                                                                }
                                                                                            });
                                                                                            const __exports = __callInstance99.exports;
                                                                                            return __exports.data();
                                                                                        })();
                                                                                    }
                                                                                }
                                                                            });
                                                                            const __exports = __forInstance75.exports;
                                                                            return __exports.data();
                                                                        })();
                                                                        (() => {
                                                                            const __ifInstance55 = new WebAssembly.Instance(__ifWasmModule, {
                                                                                env: {
                                                                                    impFunc1: () => {
                                                                                        (() => {
                                                                                            const __ifInstance56 = new WebAssembly.Instance(__ifWasmModule, {
                                                                                                env: {
                                                                                                    impFunc1: () => {
                                                                                                        {
                                                                                                            (() => {
                                                                                                                let i = params.dynamicMainBullets;
                                                                                                                const __forInstance76 = new WebAssembly.Instance(__forWasmModule, {
                                                                                                                    env: {
                                                                                                                        test: () => {
                                                                                                                            return i >= 0 ? 1 : 0;
                                                                                                                        },
                                                                                                                        update: () => {
                                                                                                                            i -= 1;
                                                                                                                        },
                                                                                                                        body: () => {
                                                                                                                            (() => {
                                                                                                                                const __callInstance98 = new WebAssembly.Instance(__callWasmModule, {
                                                                                                                                    env: {
                                                                                                                                        impFunc: () => {
                                                                                                                                            bullets.eq(bullets.length - i).addClass(`${ params.bulletActiveClass }-main`);
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                });
                                                                                                                                const __exports = __callInstance98.exports;
                                                                                                                                return __exports.data();
                                                                                                                            })();
                                                                                                                        }
                                                                                                                    }
                                                                                                                });
                                                                                                                const __exports = __forInstance76.exports;
                                                                                                                return __exports.data();
                                                                                                            })();
                                                                                                            (() => {
                                                                                                                const __callInstance97 = new WebAssembly.Instance(__callWasmModule, {
                                                                                                                    env: {
                                                                                                                        impFunc: () => {
                                                                                                                            bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${ params.bulletActiveClass }-prev`);
                                                                                                                        }
                                                                                                                    }
                                                                                                                });
                                                                                                                const __exports = __callInstance97.exports;
                                                                                                                return __exports.data();
                                                                                                            })();
                                                                                                        }
                                                                                                    },
                                                                                                    impFunc2: () => {
                                                                                                        setSideBullets($firstDisplayedBullet, lS(1, 31)), setSideBullets($lastDisplayedBullet, lS(1, 32));
                                                                                                    }
                                                                                                }
                                                                                            });
                                                                                            const __exports = __ifInstance56.exports;
                                                                                            return __exports.data(bulletIndex >= bullets.length ? 1 : 0);
                                                                                        })();
                                                                                    },
                                                                                    impFunc2: () => {
                                                                                        setSideBullets($firstDisplayedBullet, lS(1, 33)), setSideBullets($lastDisplayedBullet, lS(1, 34));
                                                                                    }
                                                                                }
                                                                            });
                                                                            const __exports = __ifInstance55.exports;
                                                                            return __exports.data(swiper.params.loop ? 1 : 0);
                                                                        })();
                                                                    }
                                                                },
                                                                impFunc2: () => {
                                                                }
                                                            }
                                                        });
                                                        const __exports = __ifInstance54.exports;
                                                        return __exports.data(($bullet.addClass(params.bulletActiveClass), params.dynamicBullets) ? 1 : 0);
                                                    })();
                                                }
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance53.exports;
                                    return __exports.data((params.dynamicBullets && (bulletSize = bullets.eq(0)[swiper.isHorizontal() ? lS(1, 18) : lS(1, 19)](!0), $el.css(swiper.isHorizontal() ? lS(1, 20) : lS(1, 21), `${ bulletSize * (params.dynamicMainBullets + 4) }px`), params.dynamicMainBullets > 1 && void 0 !== swiper.previousIndex && (dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0), dynamicBulletIndex > params.dynamicMainBullets - 1 ? dynamicBulletIndex = params.dynamicMainBullets - 1 : dynamicBulletIndex < 0 && (dynamicBulletIndex = 0)), firstIndex = Math.max(current - dynamicBulletIndex, 0), lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1), midIndex = (lastIndex + firstIndex) / 2), bullets.removeClass([
                                        lS(1, 22),
                                        lS(1, 23),
                                        lS(1, 24),
                                        lS(1, 25),
                                        lS(1, 26),
                                        lS(1, 27)
                                    ].map(suffix => `${ params.bulletActiveClass }${ suffix }`).join(lS(1, 28))), $el.length > 1) ? 1 : 0);
                                })();
                                (() => {
                                    const __ifInstance57 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4), bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize, offsetProp = rtl ? lS(1, 35) : lS(1, 36);
                                                    (() => {
                                                        const __callInstance96 = new WebAssembly.Instance(__callWasmModule, {
                                                            env: {
                                                                impFunc: () => {
                                                                    bullets.css(swiper.isHorizontal() ? offsetProp : lS(1, 37), `${ bulletsOffset }px`);
                                                                }
                                                            }
                                                        });
                                                        const __exports = __callInstance96.exports;
                                                        return __exports.data();
                                                    })();
                                                }
                                            },
                                            impFunc2: () => {
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance57.exports;
                                    return __exports.data(params.dynamicBullets ? 1 : 0);
                                })();
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance52.exports;
                return __exports.data((swiper.params.loop ? (current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup), current > slidesLength - 1 - 2 * swiper.loopedSlides && (current -= slidesLength - 2 * swiper.loopedSlides), current > total - 1 && (current -= total), current < 0 && lS(1, 16) !== swiper.params.paginationType && (current = total + current)) : current = void 0 !== swiper.snapIndex ? swiper.snapIndex : swiper.activeIndex || 0, lS(1, 17) === params.type && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) ? 1 : 0);
            })();
            (() => {
                const __ifInstance58 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let progressbarDirection;
                                progressbarDirection = params.progressbarOpposite ? swiper.isHorizontal() ? lS(1, 40) : lS(1, 41) : swiper.isHorizontal() ? lS(1, 42) : lS(1, 43);
                                const scale = (current + 1) / total;
                                let scaleX = 1, scaleY = 1;
                                lS(1, 44) === progressbarDirection ? scaleX = scale : scaleY = scale, $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${ scaleX }) scaleY(${ scaleY })`).transition(swiper.params.speed);
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance58.exports;
                return __exports.data((lS(1, 38) === params.type && ($el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1)), $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total))), lS(1, 39) === params.type) ? 1 : 0);
            })();
            lS(1, 45) === params.type && params.renderCustom ? ($el.html(params.renderCustom(swiper, current + 1, total)), emit(lS(1, 46), $el[0])) : emit(lS(1, 47), $el[0]), swiper.params.watchOverflow && swiper.enabled && $el[swiper.isLocked ? lS(1, 48) : lS(1, 49)](params.lockClass);
        }
        function render() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled())
                return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length, $el = swiper.pagination.$el;
            let paginationHTML = lS(1, 50);
            (() => {
                const __ifInstance59 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                                swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength && (numberOfBullets = slidesLength);
                                (() => {
                                    let i = 0;
                                    const __forInstance77 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return i < numberOfBullets ? 1 : 0;
                                            },
                                            update: () => {
                                                i += 1;
                                            },
                                            body: () => {
                                                params.renderBullet ? paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass) : paginationHTML += `<${ params.bulletElement } class="${ params.bulletClass }"></${ params.bulletElement }>`;
                                            }
                                        }
                                    });
                                    const __exports = __forInstance77.exports;
                                    return __exports.data();
                                })();
                                $el.html(paginationHTML), swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance59.exports;
                return __exports.data(lS(1, 51) === params.type ? 1 : 0);
            })();
            lS(1, 52) === params.type && (paginationHTML = params.renderFraction ? params.renderFraction.call(swiper, params.currentClass, params.totalClass) : `<span class="${ params.currentClass }"></span>` + lS(1, 53) + `<span class="${ params.totalClass }"></span>`, $el.html(paginationHTML)), lS(1, 54) === params.type && (paginationHTML = params.renderProgressbar ? params.renderProgressbar.call(swiper, params.progressbarFillClass) : `<span class="${ params.progressbarFillClass }"></span>`, $el.html(paginationHTML)), lS(1, 55) !== params.type && emit(lS(1, 56), swiper.pagination.$el[0]);
        }
        function init() {
            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, { el: 'swiper-pagination' });
            const params = swiper.params.pagination;
            if (!params.el)
                return;
            let $el = $(params.el);
            0 !== $el.length && (swiper.params.uniqueNavElements && lS(1, 57) == typeof params.el && $el.length > 1 && ($el = swiper.$el.find(params.el), $el.length > 1 && ($el = $el.filter(el => $(el).parents(lS(1, 58))[0] === swiper.el))), lS(1, 59) === params.type && params.clickable && $el.addClass(params.clickableClass), $el.addClass(params.modifierClass + params.type), $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass), lS(1, 60) === params.type && params.dynamicBullets && ($el.addClass(`${ params.modifierClass }${ params.type }-dynamic`), dynamicBulletIndex = 0, params.dynamicMainBullets < 1 && (params.dynamicMainBullets = 1)), lS(1, 61) === params.type && params.progressbarOpposite && $el.addClass(params.progressbarOppositeClass), params.clickable && $el.on(lS(1, 62), classesToSelector(params.bulletClass), function onClick(e) {
                (() => {
                    const __callInstance95 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                e.preventDefault();
                            }
                        }
                    });
                    const __exports = __callInstance95.exports;
                    return __exports.data();
                })();
                let index = $(this).index() * swiper.params.slidesPerGroup;
                swiper.params.loop && (index += swiper.loopedSlides), swiper.slideTo(index);
            }), Object.assign(swiper.pagination, {
                $el: $el,
                el: $el[0]
            }), swiper.enabled || $el.addClass(params.lockClass));
        }
        function destroy() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled())
                return;
            const $el = swiper.pagination.$el;
            $el.removeClass(params.hiddenClass), $el.removeClass(params.modifierClass + params.type), $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass), swiper.pagination.bullets && swiper.pagination.bullets.removeClass && swiper.pagination.bullets.removeClass(params.bulletActiveClass), params.clickable && $el.off(lS(1, 63), classesToSelector(params.bulletClass));
        }
        on(lS(1, 64), () => {
            !1 === swiper.params.pagination.enabled ? disable() : (init(), render(), update());
        }), on(lS(1, 65), () => {
            swiper.params.loop ? update() : void 0 === swiper.snapIndex && update();
        }), on(lS(1, 66), () => {
            swiper.params.loop || update();
        }), on(lS(1, 67), () => {
            swiper.params.loop && (render(), update());
        }), on(lS(1, 68), () => {
            swiper.params.loop || (render(), update());
        }), on(lS(1, 69), () => {
            (() => {
                const __callInstance94 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            destroy();
                        }
                    }
                });
                const __exports = __callInstance94.exports;
                return __exports.data();
            })();
        }), on(lS(1, 70), () => {
            const {$el: $el} = swiper.pagination;
            $el && $el[swiper.enabled ? lS(1, 71) : lS(1, 72)](swiper.params.pagination.lockClass);
        }), on(lS(1, 73), () => {
            (() => {
                const __callInstance93 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            update();
                        }
                    }
                });
                const __exports = __callInstance93.exports;
                return __exports.data();
            })();
        }), on(lS(1, 74), (_s, e) => {
            const targetEl = e.target, {$el: $el} = swiper.pagination;
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
                    return;
                const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
                emit(!0 === isHidden ? lS(1, 75) : lS(1, 76)), $el.toggleClass(swiper.params.pagination.hiddenClass);
            }
        });
        const enable = () => {
                swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass), swiper.pagination.$el && swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass), init(), render(), update();
            }, disable = () => {
                swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass), swiper.pagination.$el && swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass), destroy();
            };
        (() => {
            const __callInstance92 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.assign(swiper.pagination, {
                            enable: enable,
                            disable: disable,
                            render: render,
                            update: update,
                            init: init,
                            destroy: destroy
                        });
                    }
                }
            });
            const __exports = __callInstance92.exports;
            return __exports.data();
        })();
    }
    function Scrollbar(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        const document = getDocument();
        let isTouched = !1, timeout = null, dragTimeout = null, dragStartPos, dragSize, trackSize, divider;
        function setTranslate() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
                return;
            const {
                    scrollbar: scrollbar,
                    rtlTranslate: rtl,
                    progress: progress
                } = swiper, {
                    $dragEl: $dragEl,
                    $el: $el
                } = scrollbar, params = swiper.params.scrollbar;
            let newSize = dragSize, newPos = (trackSize - dragSize) * progress;
            rtl ? (newPos = -newPos, newPos > 0 ? (newSize = dragSize - newPos, newPos = 0) : -newPos + dragSize > trackSize && (newSize = trackSize + newPos)) : newPos < 0 ? (newSize = dragSize + newPos, newPos = 0) : newPos + dragSize > trackSize && (newSize = trackSize - newPos), swiper.isHorizontal() ? ($dragEl.transform(`translate3d(${ newPos }px, 0, 0)`), $dragEl[0].style.width = `${ newSize }px`) : ($dragEl.transform(`translate3d(0px, ${ newPos }px, 0)`), $dragEl[0].style.height = `${ newSize }px`), params.hide && (clearTimeout(timeout), $el[0].style.opacity = 1, timeout = setTimeout(() => {
                $el[0].style.opacity = 0, $el.transition(400);
            }, 1000));
        }
        function setTransition(duration) {
            swiper.params.scrollbar.el && swiper.scrollbar.el && swiper.scrollbar.$dragEl.transition(duration);
        }
        function updateSize() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
                return;
            const {scrollbar: scrollbar} = swiper, {
                    $dragEl: $dragEl,
                    $el: $el
                } = scrollbar;
            $dragEl[0].style.width = lS(1, 77), $dragEl[0].style.height = lS(1, 78), trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight, divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0)), dragSize = lS(1, 79) === swiper.params.scrollbar.dragSize ? trackSize * divider : parseInt(swiper.params.scrollbar.dragSize, 10), swiper.isHorizontal() ? $dragEl[0].style.width = `${ dragSize }px` : $dragEl[0].style.height = `${ dragSize }px`, $el[0].style.display = divider >= 1 ? lS(1, 80) : lS(1, 81), swiper.params.scrollbar.hide && ($el[0].style.opacity = 0), swiper.params.watchOverflow && swiper.enabled && scrollbar.$el[swiper.isLocked ? lS(1, 82) : lS(1, 83)](swiper.params.scrollbar.lockClass);
        }
        function getPointerPosition(e) {
            return swiper.isHorizontal() ? lS(1, 84) === e.type || lS(1, 85) === e.type ? e.targetTouches[0].clientX : e.clientX : lS(1, 86) === e.type || lS(1, 87) === e.type ? e.targetTouches[0].clientY : e.clientY;
        }
        function setDragPosition(e) {
            const {
                    scrollbar: scrollbar,
                    rtlTranslate: rtl
                } = swiper, {$el: $el} = scrollbar;
            let positionRatio;
            positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? lS(1, 88) : lS(1, 89)] - (null !== dragStartPos ? dragStartPos : dragSize / 2)) / (trackSize - dragSize), positionRatio = Math.max(Math.min(positionRatio, 1), 0), rtl && (positionRatio = 1 - positionRatio);
            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
            swiper.updateProgress(position), swiper.setTranslate(position), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
        }
        function onDragStart(e) {
            const params = swiper.params.scrollbar, {
                    scrollbar: scrollbar,
                    $wrapperEl: $wrapperEl
                } = swiper, {
                    $el: $el,
                    $dragEl: $dragEl
                } = scrollbar;
            isTouched = !0, dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? lS(1, 90) : lS(1, 91)] : null, e.preventDefault(), e.stopPropagation(), $wrapperEl.transition(100), $dragEl.transition(100), setDragPosition(e), clearTimeout(dragTimeout), $el.transition(0), params.hide && $el.css(lS(1, 92), 1), swiper.params.cssMode && swiper.$wrapperEl.css(lS(1, 93), lS(1, 94)), emit(lS(1, 95), e);
        }
        function onDragMove(e) {
            const {
                    scrollbar: scrollbar,
                    $wrapperEl: $wrapperEl
                } = swiper, {
                    $el: $el,
                    $dragEl: $dragEl
                } = scrollbar;
            isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, setDragPosition(e), $wrapperEl.transition(0), $el.transition(0), $dragEl.transition(0), emit(lS(1, 96), e));
        }
        function onDragEnd(e) {
            const params = swiper.params.scrollbar, {
                    scrollbar: scrollbar,
                    $wrapperEl: $wrapperEl
                } = swiper, {$el: $el} = scrollbar;
            isTouched && (isTouched = !1, swiper.params.cssMode && (swiper.$wrapperEl.css(lS(1, 97), lS(1, 98)), $wrapperEl.transition(lS(1, 99))), params.hide && (clearTimeout(dragTimeout), dragTimeout = nextTick(() => {
                $el.css(lS(1, 100), 0), $el.transition(400);
            }, 1000)), emit(lS(1, 101), e), params.snapOnRelease && swiper.slideToClosest());
        }
        function events(method) {
            const {
                    scrollbar: scrollbar,
                    touchEventsTouch: touchEventsTouch,
                    touchEventsDesktop: touchEventsDesktop,
                    params: params,
                    support: support
                } = swiper, $el = scrollbar.$el;
            if (!$el)
                return;
            const target = $el[0], activeListener = !(!support.passiveListener || !params.passiveListeners) && {
                    passive: !1,
                    capture: !1
                }, passiveListener = !(!support.passiveListener || !params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                };
            if (!target)
                return;
            const eventMethod = lS(1, 102) === method ? lS(1, 103) : lS(1, 104);
            support.touch ? (target[eventMethod](touchEventsTouch.start, onDragStart, activeListener), target[eventMethod](touchEventsTouch.move, onDragMove, activeListener), target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener)) : (target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener), document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener), document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener));
        }
        function enableDraggable() {
            swiper.params.scrollbar.el && swiper.scrollbar.el && events(lS(1, 105));
        }
        function disableDraggable() {
            swiper.params.scrollbar.el && swiper.scrollbar.el && events(lS(1, 106));
        }
        function init() {
            const {
                scrollbar: scrollbar,
                $el: $swiperEl
            } = swiper;
            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, { el: 'swiper-scrollbar' });
            const params = swiper.params.scrollbar;
            if (!params.el)
                return;
            let $el = $(params.el);
            swiper.params.uniqueNavElements && lS(1, 107) == typeof params.el && $el.length > 1 && 1 === $swiperEl.find(params.el).length && ($el = $swiperEl.find(params.el)), $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            let $dragEl = $el.find(`.${ swiper.params.scrollbar.dragClass }`);
            0 === $dragEl.length && ($dragEl = $(`<div class="${ swiper.params.scrollbar.dragClass }"></div>`), $el.append($dragEl)), Object.assign(scrollbar, {
                $el: $el,
                el: $el[0],
                $dragEl: $dragEl,
                dragEl: $dragEl[0]
            }), params.draggable && enableDraggable(), $el && $el[swiper.enabled ? lS(1, 108) : lS(1, 109)](swiper.params.scrollbar.lockClass);
        }
        function destroy() {
            const params = swiper.params.scrollbar, $el = swiper.scrollbar.$el;
            $el && $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass), disableDraggable();
        }
        extendParams({
            scrollbar: {
                el: null,
                dragSize: 'auto',
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: 'swiper-scrollbar-lock',
                dragClass: 'swiper-scrollbar-drag',
                scrollbarDisabledClass: 'swiper-scrollbar-disabled',
                horizontalClass: 'swiper-scrollbar-horizontal',
                verticalClass: 'swiper-scrollbar-vertical'
            }
        }), swiper.scrollbar = {
            el: null,
            dragEl: null,
            $el: null,
            $dragEl: null
        }, on(lS(1, 110), () => {
            !1 === swiper.params.scrollbar.enabled ? disable() : (init(), updateSize(), setTranslate());
        }), on(lS(1, 111), () => {
            (() => {
                const __callInstance91 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            updateSize();
                        }
                    }
                });
                const __exports = __callInstance91.exports;
                return __exports.data();
            })();
        }), on(lS(1, 112), () => {
            (() => {
                const __callInstance90 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            setTranslate();
                        }
                    }
                });
                const __exports = __callInstance90.exports;
                return __exports.data();
            })();
        }), on(lS(1, 113), (_s, duration) => {
            (() => {
                const __callInstance89 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            setTransition(duration);
                        }
                    }
                });
                const __exports = __callInstance89.exports;
                return __exports.data();
            })();
        }), on(lS(1, 114), () => {
            const {$el: $el} = swiper.scrollbar;
            $el && $el[swiper.enabled ? lS(1, 115) : lS(1, 116)](swiper.params.scrollbar.lockClass);
        }), on(lS(1, 117), () => {
            (() => {
                const __callInstance88 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            destroy();
                        }
                    }
                });
                const __exports = __callInstance88.exports;
                return __exports.data();
            })();
        });
        const enable = () => {
                swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass), swiper.scrollbar.$el && swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass), init(), updateSize(), setTranslate();
            }, disable = () => {
                swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass), swiper.scrollbar.$el && swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass), destroy();
            };
        (() => {
            const __callInstance87 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.assign(swiper.scrollbar, {
                            enable: enable,
                            disable: disable,
                            updateSize: updateSize,
                            setTranslate: setTranslate,
                            init: init,
                            destroy: destroy
                        });
                    }
                }
            });
            const __exports = __callInstance87.exports;
            return __exports.data();
        })();
    }
    function Parallax(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance86 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({ parallax: { enabled: !1 } });
                    }
                }
            });
            const __exports = __callInstance86.exports;
            return __exports.data();
        })();
        const setTransform = (el, progress) => {
                const {rtl: rtl} = swiper, $el = $(el), rtlFactor = rtl ? -1 : 1, p = $el.attr(lS(1, 118)) || lS(1, 119);
                let x = $el.attr(lS(1, 120)), y = $el.attr(lS(1, 121));
                const scale = $el.attr(lS(1, 122)), opacity = $el.attr(lS(1, 123));
                (() => {
                    const __ifInstance60 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
                                    $el[0].style.opacity = currentOpacity;
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance60.exports;
                    return __exports.data((x || y ? (x = x || lS(1, 124), y = y || lS(1, 125)) : swiper.isHorizontal() ? (x = p, y = lS(1, 126)) : (y = p, x = lS(1, 127)), x = x.indexOf(lS(1, 128)) >= 0 ? `${ parseInt(x, 10) * progress * rtlFactor }%` : `${ x * progress * rtlFactor }px`, y = y.indexOf(lS(1, 129)) >= 0 ? `${ parseInt(y, 10) * progress }%` : `${ y * progress }px`, null != opacity) ? 1 : 0);
                })();
                (() => {
                    const __ifInstance61 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                (() => {
                                    const __callInstance85 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                $el.transform(`translate3d(${ x }, ${ y }, 0px)`);
                                            }
                                        }
                                    });
                                    const __exports = __callInstance85.exports;
                                    return __exports.data();
                                })();
                            },
                            impFunc2: () => {
                                {
                                    const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
                                    (() => {
                                        const __callInstance84 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    $el.transform(`translate3d(${ x }, ${ y }, 0px) scale(${ currentScale })`);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance84.exports;
                                        return __exports.data();
                                    })();
                                }
                            }
                        }
                    });
                    const __exports = __ifInstance61.exports;
                    return __exports.data(null == scale ? 1 : 0);
                })();
            }, setTranslate = () => {
                const {
                    $el: $el,
                    slides: slides,
                    progress: progress,
                    snapGrid: snapGrid
                } = swiper;
                $el.children(lS(1, 130)).each(el => {
                    (() => {
                        const __callInstance83 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    setTransform(el, progress);
                                }
                            }
                        });
                        const __exports = __callInstance83.exports;
                        return __exports.data();
                    })();
                }), slides.each((slideEl, slideIndex) => {
                    let slideProgress = slideEl.progress;
                    swiper.params.slidesPerGroup > 1 && lS(1, 131) !== swiper.params.slidesPerView && (slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1)), slideProgress = Math.min(Math.max(slideProgress, -1), 1), $(slideEl).find(lS(1, 132)).each(el => {
                        (() => {
                            const __callInstance82 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        setTransform(el, slideProgress);
                                    }
                                }
                            });
                            const __exports = __callInstance82.exports;
                            return __exports.data();
                        })();
                    });
                });
            }, setTransition = function (duration) {
                void 0 === duration && (duration = swiper.params.speed);
                const {$el: $el} = swiper;
                (() => {
                    const __callInstance81 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                $el.find(lS(1, 133)).each(parallaxEl => {
                                    const $parallaxEl = $(parallaxEl);
                                    let parallaxDuration = parseInt($parallaxEl.attr(lS(1, 134)), 10) || duration;
                                    0 === duration && (parallaxDuration = 0), $parallaxEl.transition(parallaxDuration);
                                });
                            }
                        }
                    });
                    const __exports = __callInstance81.exports;
                    return __exports.data();
                })();
            };
        on(lS(1, 135), () => {
            swiper.params.parallax.enabled && (swiper.params.watchSlidesProgress = !0, swiper.originalParams.watchSlidesProgress = !0);
        }), on(lS(1, 136), () => {
            swiper.params.parallax.enabled && setTranslate();
        }), on(lS(1, 137), () => {
            swiper.params.parallax.enabled && setTranslate();
        }), on(lS(1, 138), (_swiper, duration) => {
            swiper.params.parallax.enabled && setTransition(duration);
        });
    }
    function Zoom(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        const window = getWindow();
        extendParams({
            zoom: {
                enabled: !1,
                maxRatio: 3,
                minRatio: 1,
                toggle: !0,
                containerClass: 'swiper-zoom-container',
                zoomedSlideClass: 'swiper-slide-zoomed'
            }
        }), swiper.zoom = { enabled: !1 };
        let currentScale = 1, isScaling = !1, gesturesEnabled, fakeGestureTouched, fakeGestureMoved;
        const gesture = {
                $slideEl: void 0,
                slideWidth: void 0,
                slideHeight: void 0,
                $imageEl: void 0,
                $imageWrapEl: void 0,
                maxRatio: 3
            }, image = {
                isTouched: void 0,
                isMoved: void 0,
                currentX: void 0,
                currentY: void 0,
                minX: void 0,
                minY: void 0,
                maxX: void 0,
                maxY: void 0,
                width: void 0,
                height: void 0,
                startX: void 0,
                startY: void 0,
                touchesStart: {},
                touchesCurrent: {}
            }, velocity = {
                x: void 0,
                y: void 0,
                prevPositionX: void 0,
                prevPositionY: void 0,
                prevTime: void 0
            };
        let scale = 1;
        function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2)
                return 1;
            const x1 = e.targetTouches[0].pageX, y1 = e.targetTouches[0].pageY, x2 = e.targetTouches[1].pageX, y2 = e.targetTouches[1].pageY, distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            return distance;
        }
        function onGestureStart(e) {
            const support = swiper.support, params = swiper.params.zoom;
            if (fakeGestureTouched = !1, fakeGestureMoved = !1, !support.gestures) {
                if (lS(1, 139) !== e.type || lS(1, 140) === e.type && e.targetTouches.length < 2)
                    return;
                fakeGestureTouched = !0, gesture.scaleStart = getDistanceBetweenTouches(e);
            }
            gesture.$slideEl && gesture.$slideEl.length || (gesture.$slideEl = $(e.target).closest(`.${ swiper.params.slideClass }`), 0 === gesture.$slideEl.length && (gesture.$slideEl = swiper.slides.eq(swiper.activeIndex)), gesture.$imageEl = gesture.$slideEl.find(`.${ params.containerClass }`).eq(0).find(lS(1, 141)).eq(0), gesture.$imageWrapEl = gesture.$imageEl.parent(`.${ params.containerClass }`), gesture.maxRatio = gesture.$imageWrapEl.attr(lS(1, 142)) || params.maxRatio, 0 !== gesture.$imageWrapEl.length) ? (gesture.$imageEl && gesture.$imageEl.transition(0), isScaling = !0) : gesture.$imageEl = void 0;
        }
        function onGestureChange(e) {
            const support = swiper.support, params = swiper.params.zoom, zoom = swiper.zoom;
            if (!support.gestures) {
                if (lS(1, 143) !== e.type || lS(1, 144) === e.type && e.targetTouches.length < 2)
                    return;
                fakeGestureMoved = !0, gesture.scaleMove = getDistanceBetweenTouches(e);
            }
            gesture.$imageEl && 0 !== gesture.$imageEl.length ? (support.gestures ? zoom.scale = e.scale * currentScale : zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale, zoom.scale > gesture.maxRatio && (zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5), zoom.scale < params.minRatio && (zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5), gesture.$imageEl.transform(`translate3d(0,0,0) scale(${ zoom.scale })`)) : lS(1, 145) === e.type && onGestureStart(e);
        }
        function onGestureEnd(e) {
            const device = swiper.device, support = swiper.support, params = swiper.params.zoom, zoom = swiper.zoom;
            if (!support.gestures) {
                if (!fakeGestureTouched || !fakeGestureMoved)
                    return;
                if (lS(1, 146) !== e.type || lS(1, 147) === e.type && e.changedTouches.length < 2 && !device.android)
                    return;
                fakeGestureTouched = !1, fakeGestureMoved = !1;
            }
            gesture.$imageEl && 0 !== gesture.$imageEl.length && (zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio), gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${ zoom.scale })`), currentScale = zoom.scale, isScaling = !1, 1 === zoom.scale && (gesture.$slideEl = void 0));
        }
        function onTouchStart(e) {
            const device = swiper.device;
            gesture.$imageEl && 0 !== gesture.$imageEl.length && (image.isTouched || (device.android && e.cancelable && e.preventDefault(), image.isTouched = !0, image.touchesStart.x = lS(1, 148) === e.type ? e.targetTouches[0].pageX : e.pageX, image.touchesStart.y = lS(1, 149) === e.type ? e.targetTouches[0].pageY : e.pageY));
        }
        function onTouchMove(e) {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || 0 === gesture.$imageEl.length)
                return;
            if (swiper.allowClick = !1, !image.isTouched || !gesture.$slideEl)
                return;
            image.isMoved || (image.width = gesture.$imageEl[0].offsetWidth, image.height = gesture.$imageEl[0].offsetHeight, image.startX = getTranslate(gesture.$imageWrapEl[0], lS(1, 150)) || 0, image.startY = getTranslate(gesture.$imageWrapEl[0], lS(1, 151)) || 0, gesture.slideWidth = gesture.$slideEl[0].offsetWidth, gesture.slideHeight = gesture.$slideEl[0].offsetHeight, gesture.$imageWrapEl.transition(0));
            const scaledWidth = image.width * zoom.scale, scaledHeight = image.height * zoom.scale;
            if (!(scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)) {
                if (image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0), image.maxX = -image.minX, image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0), image.maxY = -image.minY, image.touchesCurrent.x = lS(1, 152) === e.type ? e.targetTouches[0].pageX : e.pageX, image.touchesCurrent.y = lS(1, 153) === e.type ? e.targetTouches[0].pageY : e.pageY, !image.isMoved && !isScaling) {
                    if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x))
                        return void (image.isTouched = !1);
                    if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y))
                        return void (image.isTouched = !1);
                }
                e.cancelable && e.preventDefault(), e.stopPropagation(), image.isMoved = !0, image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX, image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY, image.currentX < image.minX && (image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8), image.currentX > image.maxX && (image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8), image.currentY < image.minY && (image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8), image.currentY > image.maxY && (image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8), velocity.prevPositionX || (velocity.prevPositionX = image.touchesCurrent.x), velocity.prevPositionY || (velocity.prevPositionY = image.touchesCurrent.y), velocity.prevTime || (velocity.prevTime = Date.now()), velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2, velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2, Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2 && (velocity.x = 0), Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2 && (velocity.y = 0), velocity.prevPositionX = image.touchesCurrent.x, velocity.prevPositionY = image.touchesCurrent.y, velocity.prevTime = Date.now(), gesture.$imageWrapEl.transform(`translate3d(${ image.currentX }px, ${ image.currentY }px,0)`);
            }
        }
        function onTouchEnd() {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || 0 === gesture.$imageEl.length)
                return;
            if (!image.isTouched || !image.isMoved)
                return image.isTouched = !1, void (image.isMoved = !1);
            image.isTouched = !1, image.isMoved = !1;
            let momentumDurationX = 300, momentumDurationY = 300;
            const momentumDistanceX = velocity.x * momentumDurationX, newPositionX = image.currentX + momentumDistanceX, momentumDistanceY = velocity.y * momentumDurationY, newPositionY = image.currentY + momentumDistanceY;
            0 !== velocity.x && (momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x)), 0 !== velocity.y && (momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y));
            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX, image.currentY = newPositionY;
            const scaledWidth = image.width * zoom.scale, scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0), image.maxX = -image.minX, image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0), image.maxY = -image.minY, image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX), image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY), gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${ image.currentX }px, ${ image.currentY }px,0)`);
        }
        function onTransitionEnd() {
            const zoom = swiper.zoom;
            gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex && (gesture.$imageEl && gesture.$imageEl.transform(lS(1, 154)), gesture.$imageWrapEl && gesture.$imageWrapEl.transform(lS(1, 155)), zoom.scale = 1, currentScale = 1, gesture.$slideEl = void 0, gesture.$imageEl = void 0, gesture.$imageWrapEl = void 0);
        }
        function zoomIn(e) {
            const zoom = swiper.zoom, params = swiper.params.zoom;
            if (gesture.$slideEl || (e && e.target && (gesture.$slideEl = $(e.target).closest(`.${ swiper.params.slideClass }`)), gesture.$slideEl || (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? gesture.$slideEl = swiper.$wrapperEl.children(`.${ swiper.params.slideActiveClass }`) : gesture.$slideEl = swiper.slides.eq(swiper.activeIndex)), gesture.$imageEl = gesture.$slideEl.find(`.${ params.containerClass }`).eq(0).find(lS(1, 156)).eq(0), gesture.$imageWrapEl = gesture.$imageEl.parent(`.${ params.containerClass }`)), !gesture.$imageEl || 0 === gesture.$imageEl.length || !gesture.$imageWrapEl || 0 === gesture.$imageWrapEl.length)
                return;
            let touchX, touchY, offsetX, offsetY, diffX, diffY, translateX, translateY, imageWidth, imageHeight, scaledWidth, scaledHeight, translateMinX, translateMinY, translateMaxX, translateMaxY, slideWidth, slideHeight;
            swiper.params.cssMode && (swiper.wrapperEl.style.overflow = lS(1, 157), swiper.wrapperEl.style.touchAction = lS(1, 158)), gesture.$slideEl.addClass(`${ params.zoomedSlideClass }`), void 0 === image.touchesStart.x && e ? (touchX = lS(1, 159) === e.type ? e.changedTouches[0].pageX : e.pageX, touchY = lS(1, 160) === e.type ? e.changedTouches[0].pageY : e.pageY) : (touchX = image.touchesStart.x, touchY = image.touchesStart.y), zoom.scale = gesture.$imageWrapEl.attr(lS(1, 161)) || params.maxRatio, currentScale = gesture.$imageWrapEl.attr(lS(1, 162)) || params.maxRatio, e ? (slideWidth = gesture.$slideEl[0].offsetWidth, slideHeight = gesture.$slideEl[0].offsetHeight, offsetX = gesture.$slideEl.offset().left + window.scrollX, offsetY = gesture.$slideEl.offset().top + window.scrollY, diffX = offsetX + slideWidth / 2 - touchX, diffY = offsetY + slideHeight / 2 - touchY, imageWidth = gesture.$imageEl[0].offsetWidth, imageHeight = gesture.$imageEl[0].offsetHeight, scaledWidth = imageWidth * zoom.scale, scaledHeight = imageHeight * zoom.scale, translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0), translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0), translateMaxX = -translateMinX, translateMaxY = -translateMinY, translateX = diffX * zoom.scale, translateY = diffY * zoom.scale, translateX < translateMinX && (translateX = translateMinX), translateX > translateMaxX && (translateX = translateMaxX), translateY < translateMinY && (translateY = translateMinY), translateY > translateMaxY && (translateY = translateMaxY)) : (translateX = 0, translateY = 0), gesture.$imageWrapEl.transition(300).transform(`translate3d(${ translateX }px, ${ translateY }px,0)`), gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${ zoom.scale })`);
        }
        function zoomOut() {
            const zoom = swiper.zoom, params = swiper.params.zoom;
            gesture.$slideEl || (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? gesture.$slideEl = swiper.$wrapperEl.children(`.${ swiper.params.slideActiveClass }`) : gesture.$slideEl = swiper.slides.eq(swiper.activeIndex), gesture.$imageEl = gesture.$slideEl.find(`.${ params.containerClass }`).eq(0).find(lS(1, 163)).eq(0), gesture.$imageWrapEl = gesture.$imageEl.parent(`.${ params.containerClass }`)), gesture.$imageEl && 0 !== gesture.$imageEl.length && gesture.$imageWrapEl && 0 !== gesture.$imageWrapEl.length && (swiper.params.cssMode && (swiper.wrapperEl.style.overflow = lS(1, 164), swiper.wrapperEl.style.touchAction = lS(1, 165)), zoom.scale = 1, currentScale = 1, gesture.$imageWrapEl.transition(300).transform(lS(1, 166)), gesture.$imageEl.transition(300).transform(lS(1, 167)), gesture.$slideEl.removeClass(`${ params.zoomedSlideClass }`), gesture.$slideEl = void 0);
        }
        function zoomToggle(e) {
            const zoom = swiper.zoom;
            zoom.scale && 1 !== zoom.scale ? zoomOut() : zoomIn(e);
        }
        function getListeners() {
            const support = swiper.support, passiveListener = !(lS(1, 168) !== swiper.touchEvents.start || !support.passiveListener || !swiper.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                }, activeListenerWithCapture = !support.passiveListener || {
                    passive: !1,
                    capture: !0
                };
            return {
                passiveListener: passiveListener,
                activeListenerWithCapture: activeListenerWithCapture
            };
        }
        function getSlideSelector() {
            return `.${ swiper.params.slideClass }`;
        }
        function toggleGestures(method) {
            const {passiveListener: passiveListener} = getListeners(), slideSelector = getSlideSelector();
            swiper.$wrapperEl[method](lS(1, 169), slideSelector, onGestureStart, passiveListener), swiper.$wrapperEl[method](lS(1, 170), slideSelector, onGestureChange, passiveListener), swiper.$wrapperEl[method](lS(1, 171), slideSelector, onGestureEnd, passiveListener);
        }
        function enableGestures() {
            gesturesEnabled || (gesturesEnabled = !0, toggleGestures(lS(1, 172)));
        }
        function disableGestures() {
            gesturesEnabled && (gesturesEnabled = !1, toggleGestures(lS(1, 173)));
        }
        function enable() {
            const zoom = swiper.zoom;
            if (zoom.enabled)
                return;
            zoom.enabled = !0;
            const support = swiper.support, {
                    passiveListener: passiveListener,
                    activeListenerWithCapture: activeListenerWithCapture
                } = getListeners(), slideSelector = getSlideSelector();
            support.gestures ? (swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener), swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener)) : lS(1, 174) === swiper.touchEvents.start && (swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener), swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture), swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener), swiper.touchEvents.cancel && swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener)), swiper.$wrapperEl.on(swiper.touchEvents.move, `.${ swiper.params.zoom.containerClass }`, onTouchMove, activeListenerWithCapture);
        }
        function disable() {
            const zoom = swiper.zoom;
            if (!zoom.enabled)
                return;
            const support = swiper.support;
            zoom.enabled = !1;
            const {
                    passiveListener: passiveListener,
                    activeListenerWithCapture: activeListenerWithCapture
                } = getListeners(), slideSelector = getSlideSelector();
            support.gestures ? (swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener), swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener)) : lS(1, 175) === swiper.touchEvents.start && (swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener), swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture), swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener), swiper.touchEvents.cancel && swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener)), swiper.$wrapperEl.off(swiper.touchEvents.move, `.${ swiper.params.zoom.containerClass }`, onTouchMove, activeListenerWithCapture);
        }
        Object.defineProperty(swiper.zoom, lS(1, 176), {
            get: () => scale,
            set(value) {
                (() => {
                    const __ifInstance62 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : void 0, slideEl = gesture.$slideEl ? gesture.$slideEl[0] : void 0;
                                    (() => {
                                        const __callInstance80 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    emit(lS(1, 177), value, imageEl, slideEl);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance80.exports;
                                        return __exports.data();
                                    })();
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance62.exports;
                    return __exports.data(scale !== value ? 1 : 0);
                })();
                scale = value;
            }
        }), on(lS(1, 178), () => {
            swiper.params.zoom.enabled && enable();
        }), on(lS(1, 179), () => {
            (() => {
                const __callInstance79 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            disable();
                        }
                    }
                });
                const __exports = __callInstance79.exports;
                return __exports.data();
            })();
        }), on(lS(1, 180), (_s, e) => {
            swiper.zoom.enabled && onTouchStart(e);
        }), on(lS(1, 181), (_s, e) => {
            swiper.zoom.enabled && onTouchEnd();
        }), on(lS(1, 182), (_s, e) => {
            !swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle && zoomToggle(e);
        }), on(lS(1, 183), () => {
            swiper.zoom.enabled && swiper.params.zoom.enabled && onTransitionEnd();
        }), on(lS(1, 184), () => {
            swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode && onTransitionEnd();
        }), Object.assign(swiper.zoom, {
            enable: enable,
            disable: disable,
            in: zoomIn,
            out: zoomOut,
            toggle: zoomToggle
        });
    }
    function Lazy(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on,
            emit: emit
        } = _ref;
        extendParams({
            lazy: {
                checkInView: !1,
                enabled: !1,
                loadPrevNext: !1,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: !1,
                scrollingElement: '',
                elementClass: 'swiper-lazy',
                loadingClass: 'swiper-lazy-loading',
                loadedClass: 'swiper-lazy-loaded',
                preloaderClass: 'swiper-lazy-preloader'
            }
        }), swiper.lazy = {};
        let scrollHandlerAttached = !1, initialImageLoaded = !1;
        function loadInSlide(index, loadInDuplicate) {
            void 0 === loadInDuplicate && (loadInDuplicate = !0);
            const params = swiper.params.lazy;
            if (void 0 === index)
                return;
            if (0 === swiper.slides.length)
                return;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled, $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${ swiper.params.slideClass }[data-swiper-slide-index="${ index }"]`) : swiper.slides.eq(index), $images = $slideEl.find(`.${ params.elementClass }:not(.${ params.loadedClass }):not(.${ params.loadingClass })`);
            !$slideEl.hasClass(params.elementClass) || $slideEl.hasClass(params.loadedClass) || $slideEl.hasClass(params.loadingClass) || $images.push($slideEl[0]), 0 !== $images.length && $images.each(imageEl => {
                const $imageEl = $(imageEl);
                (() => {
                    const __callInstance78 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                $imageEl.addClass(params.loadingClass);
                            }
                        }
                    });
                    const __exports = __callInstance78.exports;
                    return __exports.data();
                })();
                const background = $imageEl.attr(lS(1, 185)), src = $imageEl.attr(lS(1, 186)), srcset = $imageEl.attr(lS(1, 187)), sizes = $imageEl.attr(lS(1, 188)), $pictureEl = $imageEl.parent(lS(1, 189));
                swiper.loadImage($imageEl[0], src || background, srcset, sizes, !1, () => {
                    (() => {
                        const __ifInstance63 = new WebAssembly.Instance(__ifWasmModule, {
                            env: {
                                impFunc1: () => {
                                    {
                                        (() => {
                                            const __ifInstance64 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        {
                                                            const slideOriginalIndex = $slideEl.attr(lS(1, 203));
                                                            (() => {
                                                                const __ifInstance65 = new WebAssembly.Instance(__ifWasmModule, {
                                                                    env: {
                                                                        impFunc1: () => {
                                                                            {
                                                                                const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${ slideOriginalIndex }"]:not(.${ swiper.params.slideDuplicateClass })`);
                                                                                (() => {
                                                                                    const __callInstance77 = new WebAssembly.Instance(__callWasmModule, {
                                                                                        env: {
                                                                                            impFunc: () => {
                                                                                                loadInSlide(originalSlide.index(), !1);
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                    const __exports = __callInstance77.exports;
                                                                                    return __exports.data();
                                                                                })();
                                                                            }
                                                                        },
                                                                        impFunc2: () => {
                                                                            {
                                                                                const duplicatedSlide = swiper.$wrapperEl.children(`.${ swiper.params.slideDuplicateClass }[data-swiper-slide-index="${ slideOriginalIndex }"]`);
                                                                                (() => {
                                                                                    const __callInstance76 = new WebAssembly.Instance(__callWasmModule, {
                                                                                        env: {
                                                                                            impFunc: () => {
                                                                                                loadInSlide(duplicatedSlide.index(), !1);
                                                                                            }
                                                                                        }
                                                                                    });
                                                                                    const __exports = __callInstance76.exports;
                                                                                    return __exports.data();
                                                                                })();
                                                                            }
                                                                        }
                                                                    }
                                                                });
                                                                const __exports = __ifInstance65.exports;
                                                                return __exports.data($slideEl.hasClass(swiper.params.slideDuplicateClass) ? 1 : 0);
                                                            })();
                                                        }
                                                    },
                                                    impFunc2: () => {
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance64.exports;
                                            return __exports.data((background ? ($imageEl.css(lS(1, 190), `url("${ background }")`), $imageEl.removeAttr(lS(1, 191))) : (srcset && ($imageEl.attr(lS(1, 192), srcset), $imageEl.removeAttr(lS(1, 193))), sizes && ($imageEl.attr(lS(1, 194), sizes), $imageEl.removeAttr(lS(1, 195))), $pictureEl.length && $pictureEl.children(lS(1, 196)).each(sourceEl => {
                                                const $source = $(sourceEl);
                                                $source.attr(lS(1, 197)) && ($source.attr(lS(1, 198), $source.attr(lS(1, 199))), $source.removeAttr(lS(1, 200)));
                                            }), src && ($imageEl.attr(lS(1, 201), src), $imageEl.removeAttr(lS(1, 202)))), $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass), $slideEl.find(`.${ params.preloaderClass }`).remove(), swiper.params.loop && loadInDuplicate) ? 1 : 0);
                                        })();
                                        emit(lS(1, 204), $slideEl[0], $imageEl[0]), swiper.params.autoHeight && swiper.updateAutoHeight();
                                    }
                                },
                                impFunc2: () => {
                                }
                            }
                        });
                        const __exports = __ifInstance63.exports;
                        return __exports.data(null != swiper && swiper && (!swiper || swiper.params) && !swiper.destroyed ? 1 : 0);
                    })();
                }), emit(lS(1, 205), $slideEl[0], $imageEl[0]);
            });
        }
        function load() {
            const {
                    $wrapperEl: $wrapperEl,
                    params: swiperParams,
                    slides: slides,
                    activeIndex: activeIndex
                } = swiper, isVirtual = swiper.virtual && swiperParams.virtual.enabled, params = swiperParams.lazy;
            let slidesPerView = swiperParams.slidesPerView;
            function slideExist(index) {
                if (isVirtual) {
                    if ($wrapperEl.children(`.${ swiperParams.slideClass }[data-swiper-slide-index="${ index }"]`).length)
                        return !0;
                } else if (slides[index])
                    return !0;
                return !1;
            }
            function slideIndex(slideEl) {
                return isVirtual ? $(slideEl).attr(lS(1, 206)) : $(slideEl).index();
            }
            (() => {
                const __ifInstance66 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            (() => {
                                const __callInstance75 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            $wrapperEl.children(`.${ swiperParams.slideVisibleClass }`).each(slideEl => {
                                                const index = isVirtual ? $(slideEl).attr(lS(1, 208)) : $(slideEl).index();
                                                (() => {
                                                    const __callInstance74 = new WebAssembly.Instance(__callWasmModule, {
                                                        env: {
                                                            impFunc: () => {
                                                                loadInSlide(index);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __callInstance74.exports;
                                                    return __exports.data();
                                                })();
                                            });
                                        }
                                    }
                                });
                                const __exports = __callInstance75.exports;
                                return __exports.data();
                            })();
                        },
                        impFunc2: () => {
                            (() => {
                                const __ifInstance67 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1)
                                                slideExist(i) && loadInSlide(i);
                                        },
                                        impFunc2: () => {
                                            (() => {
                                                const __callInstance73 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            loadInSlide(activeIndex);
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance73.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                });
                                const __exports = __ifInstance67.exports;
                                return __exports.data(slidesPerView > 1 ? 1 : 0);
                            })();
                        }
                    }
                });
                const __exports = __ifInstance66.exports;
                return __exports.data((lS(1, 207) === slidesPerView && (slidesPerView = 0), initialImageLoaded || (initialImageLoaded = !0), swiper.params.watchSlidesProgress) ? 1 : 0);
            })();
            (() => {
                const __ifInstance68 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            (() => {
                                const __ifInstance69 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                const amount = params.loadPrevNextAmount, spv = Math.ceil(slidesPerView), maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length), minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                                                (() => {
                                                    let i = activeIndex + spv;
                                                    const __forInstance79 = new WebAssembly.Instance(__forWasmModule, {
                                                        env: {
                                                            test: () => {
                                                                return i < maxIndex ? 1 : 0;
                                                            },
                                                            update: () => {
                                                                i += 1;
                                                            },
                                                            body: () => {
                                                                slideExist(i) && loadInSlide(i);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __forInstance79.exports;
                                                    return __exports.data();
                                                })();
                                                (() => {
                                                    let i = minIndex;
                                                    const __forInstance80 = new WebAssembly.Instance(__forWasmModule, {
                                                        env: {
                                                            test: () => {
                                                                return i < activeIndex ? 1 : 0;
                                                            },
                                                            update: () => {
                                                                i += 1;
                                                            },
                                                            body: () => {
                                                                slideExist(i) && loadInSlide(i);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __forInstance80.exports;
                                                    return __exports.data();
                                                })();
                                            }
                                        },
                                        impFunc2: () => {
                                            {
                                                const nextSlide = $wrapperEl.children(`.${ swiperParams.slideNextClass }`);
                                                nextSlide.length > 0 && loadInSlide(slideIndex(nextSlide));
                                                const prevSlide = $wrapperEl.children(`.${ swiperParams.slidePrevClass }`);
                                                prevSlide.length > 0 && loadInSlide(slideIndex(prevSlide));
                                            }
                                        }
                                    }
                                });
                                const __exports = __ifInstance69.exports;
                                return __exports.data(slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1 ? 1 : 0);
                            })();
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance68.exports;
                return __exports.data(params.loadPrevNext ? 1 : 0);
            })();
        }
        function checkInViewOnLoad() {
            const window = getWindow();
            if (!swiper || swiper.destroyed)
                return;
            const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window), isWindow = $scrollElement[0] === window, scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth, scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight, swiperOffset = swiper.$el.offset(), {rtlTranslate: rtl} = swiper;
            let inView = !1;
            rtl && (swiperOffset.left -= swiper.$el[0].scrollLeft);
            const swiperCoord = [
                [
                    swiperOffset.left,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left + swiper.width,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left,
                    swiperOffset.top + swiper.height
                ],
                [
                    swiperOffset.left + swiper.width,
                    swiperOffset.top + swiper.height
                ]
            ];
            for (let i = 0; i < swiperCoord.length; i += 1) {
                const point = swiperCoord[i];
                if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
                    if (0 === point[0] && 0 === point[1])
                        continue;
                    inView = !0;
                }
            }
            const passiveListener = !(lS(1, 209) !== swiper.touchEvents.start || !swiper.support.passiveListener || !swiper.params.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            inView ? (load(), $scrollElement.off(lS(1, 210), checkInViewOnLoad, passiveListener)) : scrollHandlerAttached || (scrollHandlerAttached = !0, $scrollElement.on(lS(1, 211), checkInViewOnLoad, passiveListener));
        }
        on(lS(1, 212), () => {
            swiper.params.lazy.enabled && swiper.params.preloadImages && (swiper.params.preloadImages = !1);
        }), on(lS(1, 213), () => {
            swiper.params.lazy.enabled && (swiper.params.lazy.checkInView ? checkInViewOnLoad() : load());
        }), on(lS(1, 214), () => {
            swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky && load();
        }), on(lS(1, 215), () => {
            swiper.params.lazy.enabled && (swiper.params.lazy.checkInView ? checkInViewOnLoad() : load());
        }), on(lS(1, 216), () => {
            swiper.params.lazy.enabled && (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) && (swiper.params.lazy.checkInView ? checkInViewOnLoad() : load());
        }), on(lS(1, 217), () => {
            swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart && (swiper.params.lazy.checkInView ? checkInViewOnLoad() : load());
        }), on(lS(1, 218), () => {
            const {
                lazy: lazy,
                cssMode: cssMode,
                watchSlidesProgress: watchSlidesProgress,
                touchReleaseOnEdges: touchReleaseOnEdges,
                resistanceRatio: resistanceRatio
            } = swiper.params;
            lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || 0 === resistanceRatio)) && load();
        }), on(lS(1, 219), () => {
            swiper.$el && swiper.$el.find(`.${ swiper.params.lazy.loadingClass }`).removeClass(swiper.params.lazy.loadingClass);
        }), Object.assign(swiper.lazy, {
            load: load,
            loadInSlide: loadInSlide
        });
    }
    function Controller(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        function LinearSpline(x, y) {
            const binarySearch = function search() {
                let maxIndex, minIndex, guess;
                return (array, val) => {
                    (() => {
                        minIndex = -1, maxIndex = array.length;
                        const __forInstance81 = new WebAssembly.Instance(__forWasmModule, {
                            env: {
                                test: () => {
                                    return maxIndex - minIndex > 1 ? 1 : 0;
                                },
                                update: () => {
                                },
                                body: () => {
                                    guess = maxIndex + minIndex >> 1, array[guess] <= val ? minIndex = guess : maxIndex = guess;
                                }
                            }
                        });
                        const __exports = __forInstance81.exports;
                        return __exports.data();
                    })();
                    return maxIndex;
                };
            }();
            let i1, i3;
            return this.x = x, this.y = y, this.lastIndex = x.length - 1, this.interpolate = function interpolate(x2) {
                return x2 ? (i3 = binarySearch(this.x, x2), i1 = i3 - 1, (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1]) : 0;
            }, this;
        }
        function getInterpolateFunction(c) {
            swiper.controller.spline || (swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid));
        }
        function setTranslate(_t, byController) {
            const controlled = swiper.controller.control;
            let multiplier, controlledTranslate;
            const Swiper = swiper.constructor;
            function setControlledTranslate(c) {
                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                lS(1, 220) === swiper.params.controller.by && (getInterpolateFunction(c), controlledTranslate = -swiper.controller.spline.interpolate(-translate)), controlledTranslate && lS(1, 221) !== swiper.params.controller.by || (multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate()), controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate()), swiper.params.controller.inverse && (controlledTranslate = c.maxTranslate() - controlledTranslate), c.updateProgress(controlledTranslate), c.setTranslate(controlledTranslate, swiper), c.updateActiveIndex(), c.updateSlidesClasses();
            }
            (() => {
                const __ifInstance70 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            for (let i = 0; i < controlled.length; i += 1)
                                controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTranslate(controlled[i]);
                        },
                        impFunc2: () => {
                            controlled instanceof Swiper && byController !== controlled && setControlledTranslate(controlled);
                        }
                    }
                });
                const __exports = __ifInstance70.exports;
                return __exports.data(Array.isArray(controlled) ? 1 : 0);
            })();
        }
        function setTransition(duration, byController) {
            const Swiper = swiper.constructor, controlled = swiper.controller.control;
            let i;
            function setControlledTransition(c) {
                c.setTransition(duration, swiper), 0 !== duration && (c.transitionStart(), c.params.autoHeight && nextTick(() => {
                    (() => {
                        const __callInstance72 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    c.updateAutoHeight();
                                }
                            }
                        });
                        const __exports = __callInstance72.exports;
                        return __exports.data();
                    })();
                }), c.$wrapperEl.transitionEnd(() => {
                    controlled && (c.params.loop && lS(1, 222) === swiper.params.controller.by && c.loopFix(), c.transitionEnd());
                }));
            }
            (() => {
                const __ifInstance71 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            for (i = 0; i < controlled.length; i += 1)
                                controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTransition(controlled[i]);
                        },
                        impFunc2: () => {
                            controlled instanceof Swiper && byController !== controlled && setControlledTransition(controlled);
                        }
                    }
                });
                const __exports = __ifInstance71.exports;
                return __exports.data(Array.isArray(controlled) ? 1 : 0);
            })();
        }
        function removeSpline() {
            swiper.controller.control && swiper.controller.spline && (swiper.controller.spline = void 0, delete swiper.controller.spline);
        }
        extendParams({
            controller: {
                control: void 0,
                inverse: !1,
                by: 'slide'
            }
        }), swiper.controller = { control: void 0 }, on(lS(1, 223), () => {
            swiper.controller.control = swiper.params.controller.control;
        }), on(lS(1, 224), () => {
            (() => {
                const __callInstance71 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            removeSpline();
                        }
                    }
                });
                const __exports = __callInstance71.exports;
                return __exports.data();
            })();
        }), on(lS(1, 225), () => {
            (() => {
                const __callInstance70 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            removeSpline();
                        }
                    }
                });
                const __exports = __callInstance70.exports;
                return __exports.data();
            })();
        }), on(lS(1, 226), () => {
            (() => {
                const __callInstance69 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            removeSpline();
                        }
                    }
                });
                const __exports = __callInstance69.exports;
                return __exports.data();
            })();
        }), on(lS(1, 227), (_s, translate, byController) => {
            swiper.controller.control && swiper.controller.setTranslate(translate, byController);
        }), on(lS(1, 228), (_s, duration, byController) => {
            swiper.controller.control && swiper.controller.setTransition(duration, byController);
        }), Object.assign(swiper.controller, {
            setTranslate: setTranslate,
            setTransition: setTransition
        });
    }
    function A11y(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        extendParams({
            a11y: {
                enabled: !0,
                notificationClass: 'swiper-notification',
                prevSlideMessage: 'Previous slide',
                nextSlideMessage: 'Next slide',
                firstSlideMessage: 'This is the first slide',
                lastSlideMessage: 'This is the last slide',
                paginationBulletMessage: 'Go to slide {{index}}',
                slideLabelMessage: '{{index}} / {{slidesLength}}',
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: 'group',
                id: null
            }
        }), swiper.a11y = { clicked: !1 };
        let liveRegion = null;
        function notify(message) {
            const notification = liveRegion;
            0 !== notification.length && (notification.html(lS(1, 229)), notification.html(message));
        }
        function getRandomNumber(size) {
            void 0 === size && (size = 16);
            const randomChar = () => Math.round(16 * Math.random()).toString(16);
            return lS(1, 230).repeat(size).replace(/x/g, randomChar);
        }
        function makeElFocusable($el) {
            (() => {
                const __callInstance68 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 231), lS(1, 232));
                        }
                    }
                });
                const __exports = __callInstance68.exports;
                return __exports.data();
            })();
        }
        function makeElNotFocusable($el) {
            (() => {
                const __callInstance67 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 233), lS(1, 234));
                        }
                    }
                });
                const __exports = __callInstance67.exports;
                return __exports.data();
            })();
        }
        function addElRole($el, role) {
            (() => {
                const __callInstance66 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 235), role);
                        }
                    }
                });
                const __exports = __callInstance66.exports;
                return __exports.data();
            })();
        }
        function addElRoleDescription($el, description) {
            (() => {
                const __callInstance65 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 236), description);
                        }
                    }
                });
                const __exports = __callInstance65.exports;
                return __exports.data();
            })();
        }
        function addElControls($el, controls) {
            (() => {
                const __callInstance64 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 237), controls);
                        }
                    }
                });
                const __exports = __callInstance64.exports;
                return __exports.data();
            })();
        }
        function addElLabel($el, label) {
            (() => {
                const __callInstance63 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 238), label);
                        }
                    }
                });
                const __exports = __callInstance63.exports;
                return __exports.data();
            })();
        }
        function addElId($el, id) {
            (() => {
                const __callInstance62 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 239), id);
                        }
                    }
                });
                const __exports = __callInstance62.exports;
                return __exports.data();
            })();
        }
        function addElLive($el, live) {
            (() => {
                const __callInstance61 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 240), live);
                        }
                    }
                });
                const __exports = __callInstance61.exports;
                return __exports.data();
            })();
        }
        function disableEl($el) {
            (() => {
                const __callInstance60 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 241), !0);
                        }
                    }
                });
                const __exports = __callInstance60.exports;
                return __exports.data();
            })();
        }
        function enableEl($el) {
            (() => {
                const __callInstance59 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $el.attr(lS(1, 242), !1);
                        }
                    }
                });
                const __exports = __callInstance59.exports;
                return __exports.data();
            })();
        }
        function onEnterOrSpaceKey(e) {
            if (13 !== e.keyCode && 32 !== e.keyCode)
                return;
            const params = swiper.params.a11y, $targetEl = $(e.target);
            swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl) && (swiper.isEnd && !swiper.params.loop || swiper.slideNext(), swiper.isEnd ? notify(params.lastSlideMessage) : notify(params.nextSlideMessage)), swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl) && (swiper.isBeginning && !swiper.params.loop || swiper.slidePrev(), swiper.isBeginning ? notify(params.firstSlideMessage) : notify(params.prevSlideMessage)), swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass)) && $targetEl[0].click();
        }
        function updateNavigation() {
            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation)
                return;
            const {
                $nextEl: $nextEl,
                $prevEl: $prevEl
            } = swiper.navigation;
            $prevEl && $prevEl.length > 0 && (swiper.isBeginning ? (disableEl($prevEl), makeElNotFocusable($prevEl)) : (enableEl($prevEl), makeElFocusable($prevEl))), $nextEl && $nextEl.length > 0 && (swiper.isEnd ? (disableEl($nextEl), makeElNotFocusable($nextEl)) : (enableEl($nextEl), makeElFocusable($nextEl)));
        }
        function hasPagination() {
            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
        }
        function hasClickablePagination() {
            return hasPagination() && swiper.params.pagination.clickable;
        }
        function updatePagination() {
            const params = swiper.params.a11y;
            hasPagination() && swiper.pagination.bullets.each(bulletEl => {
                const $bulletEl = $(bulletEl);
                swiper.params.pagination.clickable && (makeElFocusable($bulletEl), swiper.params.pagination.renderBullet || (addElRole($bulletEl, lS(1, 243)), addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1)))), $bulletEl.is(`.${ swiper.params.pagination.bulletActiveClass }`) ? $bulletEl.attr(lS(1, 244), lS(1, 245)) : $bulletEl.removeAttr(lS(1, 246));
            });
        }
        const initNavEl = ($el, wrapperId, message) => {
                makeElFocusable($el), lS(1, 247) !== $el[0].tagName && (addElRole($el, lS(1, 248)), $el.on(lS(1, 249), onEnterOrSpaceKey)), addElLabel($el, message), addElControls($el, wrapperId);
            }, handlePointerDown = () => {
                swiper.a11y.clicked = !0;
            }, handlePointerUp = () => {
                (() => {
                    const __callInstance58 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                requestAnimationFrame(() => {
                                    (() => {
                                        const __callInstance57 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    requestAnimationFrame(() => {
                                                        swiper.destroyed || (swiper.a11y.clicked = !1);
                                                    });
                                                }
                                            }
                                        });
                                        const __exports = __callInstance57.exports;
                                        return __exports.data();
                                    })();
                                });
                            }
                        }
                    });
                    const __exports = __callInstance58.exports;
                    return __exports.data();
                })();
            }, handleFocus = e => {
                if (swiper.a11y.clicked)
                    return;
                const slideEl = e.target.closest(`.${ swiper.params.slideClass }`);
                if (!slideEl || !swiper.slides.includes(slideEl))
                    return;
                const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex, isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
                isActive || isVisible || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (swiper.isHorizontal() ? swiper.el.scrollLeft = 0 : swiper.el.scrollTop = 0, swiper.slideTo(swiper.slides.indexOf(slideEl), 0));
            }, initSlides = () => {
                const params = swiper.params.a11y;
                params.itemRoleDescriptionMessage && addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage), params.slideRole && addElRole($(swiper.slides), params.slideRole);
                const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
                params.slideLabelMessage && swiper.slides.each((slideEl, index) => {
                    const $slideEl = $(slideEl), slideIndex = swiper.params.loop ? parseInt($slideEl.attr(lS(1, 250)), 10) : index, ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                    (() => {
                        const __callInstance56 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    addElLabel($slideEl, ariaLabelMessage);
                                }
                            }
                        });
                        const __exports = __callInstance56.exports;
                        return __exports.data();
                    })();
                });
            }, init = () => {
                const params = swiper.params.a11y;
                (() => {
                    const __callInstance55 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.$el.append(liveRegion);
                            }
                        }
                    });
                    const __exports = __callInstance55.exports;
                    return __exports.data();
                })();
                const $containerEl = swiper.$el;
                params.containerRoleDescriptionMessage && addElRoleDescription($containerEl, params.containerRoleDescriptionMessage), params.containerMessage && addElLabel($containerEl, params.containerMessage);
                const $wrapperEl = swiper.$wrapperEl, wrapperId = params.id || $wrapperEl.attr(lS(1, 251)) || `swiper-wrapper-${ getRandomNumber(16) }`, live = swiper.params.autoplay && swiper.params.autoplay.enabled ? lS(1, 252) : lS(1, 253);
                let $nextEl, $prevEl;
                addElId($wrapperEl, wrapperId), addElLive($wrapperEl, live), initSlides(), swiper.navigation && swiper.navigation.$nextEl && ($nextEl = swiper.navigation.$nextEl), swiper.navigation && swiper.navigation.$prevEl && ($prevEl = swiper.navigation.$prevEl), $nextEl && $nextEl.length && initNavEl($nextEl, wrapperId, params.nextSlideMessage), $prevEl && $prevEl.length && initNavEl($prevEl, wrapperId, params.prevSlideMessage), hasClickablePagination() && swiper.pagination.$el.on(lS(1, 254), classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey), swiper.$el.on(lS(1, 255), handleFocus, !0), swiper.$el.on(lS(1, 256), handlePointerDown, !0), swiper.$el.on(lS(1, 257), handlePointerUp, !0);
            };
        function destroy() {
            let $nextEl, $prevEl;
            liveRegion && liveRegion.length > 0 && liveRegion.remove(), swiper.navigation && swiper.navigation.$nextEl && ($nextEl = swiper.navigation.$nextEl), swiper.navigation && swiper.navigation.$prevEl && ($prevEl = swiper.navigation.$prevEl), $nextEl && $nextEl.off(lS(1, 258), onEnterOrSpaceKey), $prevEl && $prevEl.off(lS(1, 259), onEnterOrSpaceKey), hasClickablePagination() && swiper.pagination.$el.off(lS(1, 260), classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey), swiper.$el.off(lS(1, 261), handleFocus, !0), swiper.$el.off(lS(1, 262), handlePointerDown, !0), swiper.$el.off(lS(1, 263), handlePointerUp, !0);
        }
        on(lS(1, 264), () => {
            liveRegion = $(`<span class="${ swiper.params.a11y.notificationClass }" aria-live="assertive" aria-atomic="true"></span>`);
        }), on(lS(1, 265), () => {
            swiper.params.a11y.enabled && init();
        }), on(lS(1, 266), () => {
            swiper.params.a11y.enabled && initSlides();
        }), on(lS(1, 267), () => {
            swiper.params.a11y.enabled && updateNavigation();
        }), on(lS(1, 268), () => {
            swiper.params.a11y.enabled && updatePagination();
        }), on(lS(1, 269), () => {
            swiper.params.a11y.enabled && destroy();
        });
    }
    function History(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance54 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            history: {
                                enabled: !1,
                                root: '',
                                replaceState: !1,
                                key: 'slides',
                                keepQuery: !1
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance54.exports;
            return __exports.data();
        })();
        let initialized = !1, paths = {};
        const slugify = text => text.toString().replace(/\s+/g, lS(1, 270)).replace(/[^\w-]+/g, lS(1, 271)).replace(/--+/g, lS(1, 272)).replace(/^-+/, lS(1, 273)).replace(/-+$/, lS(1, 274)), getPathValues = urlOverride => {
                const window = getWindow();
                let location;
                location = urlOverride ? new URL(urlOverride) : window.location;
                const pathArray = location.pathname.slice(1).split(lS(1, 275)).filter(part => lS(1, 276) !== part), total = pathArray.length, key = pathArray[total - 2], value = pathArray[total - 1];
                return {
                    key: key,
                    value: value
                };
            }, setHistory = (key, index) => {
                const window = getWindow();
                if (!initialized || !swiper.params.history.enabled)
                    return;
                let location;
                location = swiper.params.url ? new URL(swiper.params.url) : window.location;
                const slide = swiper.slides.eq(index);
                let value = slugify(slide.attr(lS(1, 277)));
                (() => {
                    const __ifInstance72 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    let root = swiper.params.history.root;
                                    lS(1, 278) === root[root.length - 1] && (root = root.slice(0, root.length - 1)), value = `${ root }/${ key }/${ value }`;
                                }
                            },
                            impFunc2: () => {
                                location.pathname.includes(key) || (value = `${ key }/${ value }`);
                            }
                        }
                    });
                    const __exports = __ifInstance72.exports;
                    return __exports.data(swiper.params.history.root.length > 0 ? 1 : 0);
                })();
                swiper.params.history.keepQuery && (value += location.search);
                const currentState = window.history.state;
                currentState && currentState.value === value || (swiper.params.history.replaceState ? window.history.replaceState({ value: value }, null, value) : window.history.pushState({ value: value }, null, value));
            }, scrollToSlide = (speed, value, runCallbacks) => {
                (() => {
                    const __ifInstance73 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                                    const slide = swiper.slides.eq(i), slideHistory = slugify(slide.attr(lS(1, 279)));
                                    (() => {
                                        const __ifInstance74 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        const index = slide.index();
                                                        (() => {
                                                            const __callInstance53 = new WebAssembly.Instance(__callWasmModule, {
                                                                env: {
                                                                    impFunc: () => {
                                                                        swiper.slideTo(index, speed, runCallbacks);
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __callInstance53.exports;
                                                            return __exports.data();
                                                        })();
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance74.exports;
                                        return __exports.data(slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass) ? 1 : 0);
                                    })();
                                }
                            },
                            impFunc2: () => {
                                (() => {
                                    const __callInstance52 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                swiper.slideTo(0, speed, runCallbacks);
                                            }
                                        }
                                    });
                                    const __exports = __callInstance52.exports;
                                    return __exports.data();
                                })();
                            }
                        }
                    });
                    const __exports = __ifInstance73.exports;
                    return __exports.data(value ? 1 : 0);
                })();
            }, setHistoryPopState = () => {
                paths = getPathValues(swiper.params.url), scrollToSlide(swiper.params.speed, paths.value, !1);
            }, init = () => {
                const window = getWindow();
                if (swiper.params.history) {
                    if (!window.history || !window.history.pushState)
                        return swiper.params.history.enabled = !1, void (swiper.params.hashNavigation.enabled = !0);
                    initialized = !0, paths = getPathValues(swiper.params.url), (paths.key || paths.value) && (scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit), swiper.params.history.replaceState || window.addEventListener(lS(1, 280), setHistoryPopState));
                }
            }, destroy = () => {
                const window = getWindow();
                swiper.params.history.replaceState || window.removeEventListener(lS(1, 281), setHistoryPopState);
            };
        on(lS(1, 282), () => {
            swiper.params.history.enabled && init();
        }), on(lS(1, 283), () => {
            swiper.params.history.enabled && destroy();
        }), on(lS(1, 284), () => {
            initialized && setHistory(swiper.params.history.key, swiper.activeIndex);
        }), on(lS(1, 285), () => {
            initialized && swiper.params.cssMode && setHistory(swiper.params.history.key, swiper.activeIndex);
        });
    }
    function HashNavigation(_ref) {
        let {
                swiper: swiper,
                extendParams: extendParams,
                emit: emit,
                on: on
            } = _ref, initialized = !1;
        const document = getDocument(), window = getWindow();
        (() => {
            const __callInstance51 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            hashNavigation: {
                                enabled: !1,
                                replaceState: !1,
                                watchState: !1
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance51.exports;
            return __exports.data();
        })();
        const onHashChange = () => {
                (() => {
                    const __callInstance50 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                emit(lS(1, 286));
                            }
                        }
                    });
                    const __exports = __callInstance50.exports;
                    return __exports.data();
                })();
                const newHash = document.location.hash.replace(lS(1, 287), lS(1, 288)), activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr(lS(1, 289));
                if (newHash !== activeSlideHash) {
                    const newIndex = swiper.$wrapperEl.children(`.${ swiper.params.slideClass }[data-hash="${ newHash }"]`).index();
                    if (void 0 === newIndex)
                        return;
                    (() => {
                        const __callInstance49 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    swiper.slideTo(newIndex);
                                }
                            }
                        });
                        const __exports = __callInstance49.exports;
                        return __exports.data();
                    })();
                }
            }, setHash = () => {
                (() => {
                    const __ifInstance75 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                (() => {
                                    const __ifInstance76 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                window.history.replaceState(null, null, `#${ swiper.slides.eq(swiper.activeIndex).attr(lS(1, 290)) }` || lS(1, 291)), emit(lS(1, 292));
                                            },
                                            impFunc2: () => {
                                                {
                                                    const slide = swiper.slides.eq(swiper.activeIndex), hash = slide.attr(lS(1, 293)) || slide.attr(lS(1, 294));
                                                    document.location.hash = hash || lS(1, 295), emit(lS(1, 296));
                                                }
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance76.exports;
                                    return __exports.data(swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState ? 1 : 0);
                                })();
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance75.exports;
                    return __exports.data(initialized && swiper.params.hashNavigation.enabled ? 1 : 0);
                })();
            }, init = () => {
                if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled)
                    return;
                initialized = !0;
                const hash = document.location.hash.replace(lS(1, 297), lS(1, 298));
                (() => {
                    const __ifInstance77 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const speed = 0;
                                    (() => {
                                        let i = 0, length = swiper.slides.length;
                                        const __forInstance85 = new WebAssembly.Instance(__forWasmModule, {
                                            env: {
                                                test: () => {
                                                    return i < length ? 1 : 0;
                                                },
                                                update: () => {
                                                    i += 1;
                                                },
                                                body: () => {
                                                    {
                                                        const slide = swiper.slides.eq(i), slideHash = slide.attr(lS(1, 299)) || slide.attr(lS(1, 300));
                                                        (() => {
                                                            const __ifInstance78 = new WebAssembly.Instance(__ifWasmModule, {
                                                                env: {
                                                                    impFunc1: () => {
                                                                        {
                                                                            const index = slide.index();
                                                                            (() => {
                                                                                const __callInstance48 = new WebAssembly.Instance(__callWasmModule, {
                                                                                    env: {
                                                                                        impFunc: () => {
                                                                                            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, !0);
                                                                                        }
                                                                                    }
                                                                                });
                                                                                const __exports = __callInstance48.exports;
                                                                                return __exports.data();
                                                                            })();
                                                                        }
                                                                    },
                                                                    impFunc2: () => {
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __ifInstance78.exports;
                                                            return __exports.data(slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass) ? 1 : 0);
                                                        })();
                                                    }
                                                }
                                            }
                                        });
                                        const __exports = __forInstance85.exports;
                                        return __exports.data();
                                    })();
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance77.exports;
                    return __exports.data(hash ? 1 : 0);
                })();
                swiper.params.hashNavigation.watchState && $(window).on(lS(1, 301), onHashChange);
            }, destroy = () => {
                swiper.params.hashNavigation.watchState && $(window).off(lS(1, 302), onHashChange);
            };
        on(lS(1, 303), () => {
            swiper.params.hashNavigation.enabled && init();
        }), on(lS(1, 304), () => {
            swiper.params.hashNavigation.enabled && destroy();
        }), on(lS(1, 305), () => {
            initialized && setHash();
        }), on(lS(1, 306), () => {
            initialized && swiper.params.cssMode && setHash();
        });
    }
    function Autoplay(_ref) {
        let {
                swiper: swiper,
                extendParams: extendParams,
                on: on,
                emit: emit
            } = _ref, timeout;
        function run() {
            if (!swiper.size)
                return swiper.autoplay.running = !1, void (swiper.autoplay.paused = !1);
            const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            let delay = swiper.params.autoplay.delay;
            $activeSlideEl.attr(lS(1, 307)) && (delay = $activeSlideEl.attr(lS(1, 308)) || swiper.params.autoplay.delay), clearTimeout(timeout), timeout = nextTick(() => {
                let autoplayResult;
                swiper.params.autoplay.reverseDirection ? swiper.params.loop ? (swiper.loopFix(), autoplayResult = swiper.slidePrev(swiper.params.speed, !0, !0), emit(lS(1, 309))) : swiper.isBeginning ? swiper.params.autoplay.stopOnLastSlide ? stop() : (autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, !0, !0), emit(lS(1, 310))) : (autoplayResult = swiper.slidePrev(swiper.params.speed, !0, !0), emit(lS(1, 311))) : swiper.params.loop ? (swiper.loopFix(), autoplayResult = swiper.slideNext(swiper.params.speed, !0, !0), emit(lS(1, 312))) : swiper.isEnd ? swiper.params.autoplay.stopOnLastSlide ? stop() : (autoplayResult = swiper.slideTo(0, swiper.params.speed, !0, !0), emit(lS(1, 313))) : (autoplayResult = swiper.slideNext(swiper.params.speed, !0, !0), emit(lS(1, 314))), swiper.params.cssMode && swiper.autoplay.running ? run() : !1 === autoplayResult && run();
            }, delay);
        }
        function start() {
            return void 0 === timeout && (!swiper.autoplay.running && (swiper.autoplay.running = !0, emit(lS(1, 315)), run(), !0));
        }
        function stop() {
            return !!swiper.autoplay.running && (void 0 !== timeout && (timeout && (clearTimeout(timeout), timeout = void 0), swiper.autoplay.running = !1, emit(lS(1, 316)), !0));
        }
        function pause(speed) {
            swiper.autoplay.running && (swiper.autoplay.paused || (timeout && clearTimeout(timeout), swiper.autoplay.paused = !0, 0 !== speed && swiper.params.autoplay.waitForTransition ? [
                lS(1, 317),
                lS(1, 318)
            ].forEach(event => {
                (() => {
                    const __callInstance47 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
                            }
                        }
                    });
                    const __exports = __callInstance47.exports;
                    return __exports.data();
                })();
            }) : (swiper.autoplay.paused = !1, run())));
        }
        function onVisibilityChange() {
            const document = getDocument();
            lS(1, 319) === document.visibilityState && swiper.autoplay.running && pause(), lS(1, 320) === document.visibilityState && swiper.autoplay.paused && (run(), swiper.autoplay.paused = !1);
        }
        function onTransitionEnd(e) {
            swiper && !swiper.destroyed && swiper.$wrapperEl && e.target === swiper.$wrapperEl[0] && ([
                lS(1, 321),
                lS(1, 322)
            ].forEach(event => {
                (() => {
                    const __callInstance46 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
                            }
                        }
                    });
                    const __exports = __callInstance46.exports;
                    return __exports.data();
                })();
            }), swiper.autoplay.paused = !1, swiper.autoplay.running ? run() : stop());
        }
        function onMouseEnter() {
            swiper.params.autoplay.disableOnInteraction ? stop() : (emit(lS(1, 323)), pause()), [
                lS(1, 324),
                lS(1, 325)
            ].forEach(event => {
                (() => {
                    const __callInstance45 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
                            }
                        }
                    });
                    const __exports = __callInstance45.exports;
                    return __exports.data();
                })();
            });
        }
        function onMouseLeave() {
            swiper.params.autoplay.disableOnInteraction || (swiper.autoplay.paused = !1, emit(lS(1, 326)), run());
        }
        function attachMouseEvents() {
            swiper.params.autoplay.pauseOnMouseEnter && (swiper.$el.on(lS(1, 327), onMouseEnter), swiper.$el.on(lS(1, 328), onMouseLeave));
        }
        function detachMouseEvents() {
            swiper.$el.off(lS(1, 329), onMouseEnter), swiper.$el.off(lS(1, 330), onMouseLeave);
        }
        swiper.autoplay = {
            running: !1,
            paused: !1
        }, extendParams({
            autoplay: {
                enabled: !1,
                delay: 3000,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        }), on(lS(1, 331), () => {
            (() => {
                const __ifInstance79 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                (() => {
                                    const __callInstance44 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                start();
                                            }
                                        }
                                    });
                                    const __exports = __callInstance44.exports;
                                    return __exports.data();
                                })();
                                const document = getDocument();
                                document.addEventListener(lS(1, 332), onVisibilityChange), attachMouseEvents();
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance79.exports;
                return __exports.data(swiper.params.autoplay.enabled ? 1 : 0);
            })();
        }), on(lS(1, 333), (_s, speed, internal) => {
            swiper.autoplay.running && (internal || !swiper.params.autoplay.disableOnInteraction ? swiper.autoplay.pause(speed) : stop());
        }), on(lS(2, 0), () => {
            swiper.autoplay.running && (swiper.params.autoplay.disableOnInteraction ? stop() : pause());
        }), on(lS(2, 1), () => {
            swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction && run();
        }), on(lS(2, 2), () => {
            detachMouseEvents(), swiper.autoplay.running && stop();
            const document = getDocument();
            (() => {
                const __callInstance43 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            document.removeEventListener(lS(2, 3), onVisibilityChange);
                        }
                    }
                });
                const __exports = __callInstance43.exports;
                return __exports.data();
            })();
        }), Object.assign(swiper.autoplay, {
            pause: pause,
            run: run,
            start: start,
            stop: stop
        });
    }
    function Thumb(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance42 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            thumbs: {
                                swiper: null,
                                multipleActiveThumbs: !0,
                                autoScrollOffset: 0,
                                slideThumbActiveClass: 'swiper-slide-thumb-active',
                                thumbsContainerClass: 'swiper-thumbs'
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance42.exports;
            return __exports.data();
        })();
        let initialized = !1, swiperCreated = !1;
        function onThumbClick() {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed)
                return;
            const clickedIndex = thumbsSwiper.clickedIndex, clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass))
                return;
            if (null == clickedIndex)
                return;
            let slideToIndex;
            (() => {
                const __ifInstance80 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let currentIndex = swiper.activeIndex;
                                swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass) && (swiper.loopFix(), swiper._clientLeft = swiper.$wrapperEl[0].clientLeft, currentIndex = swiper.activeIndex);
                                const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${ slideToIndex }"]`).eq(0).index(), nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${ slideToIndex }"]`).eq(0).index();
                                slideToIndex = void 0 === prevIndex ? nextIndex : void 0 === nextIndex ? prevIndex : nextIndex - currentIndex < currentIndex - prevIndex ? nextIndex : prevIndex;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance80.exports;
                return __exports.data((slideToIndex = thumbsSwiper.params.loop ? parseInt($(thumbsSwiper.clickedSlide).attr(lS(2, 4)), 10) : clickedIndex, swiper.params.loop) ? 1 : 0);
            })();
            (() => {
                const __callInstance41 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            swiper.slideTo(slideToIndex);
                        }
                    }
                });
                const __exports = __callInstance41.exports;
                return __exports.data();
            })();
        }
        function init() {
            const {thumbs: thumbsParams} = swiper.params;
            if (initialized)
                return !1;
            initialized = !0;
            const SwiperClass = swiper.constructor;
            (() => {
                const __ifInstance81 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            swiper.thumbs.swiper = thumbsParams.swiper, Object.assign(swiper.thumbs.swiper.originalParams, {
                                watchSlidesProgress: !0,
                                slideToClickedSlide: !1
                            }), Object.assign(swiper.thumbs.swiper.params, {
                                watchSlidesProgress: !0,
                                slideToClickedSlide: !1
                            });
                        },
                        impFunc2: () => {
                            (() => {
                                const __ifInstance82 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                                                Object.assign(thumbsSwiperParams, {
                                                    watchSlidesProgress: !0,
                                                    slideToClickedSlide: !1
                                                }), swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams), swiperCreated = !0;
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance82.exports;
                                return __exports.data(isObject(thumbsParams.swiper) ? 1 : 0);
                            })();
                        }
                    }
                });
                const __exports = __ifInstance81.exports;
                return __exports.data(thumbsParams.swiper instanceof SwiperClass ? 1 : 0);
            })();
            return swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass), swiper.thumbs.swiper.on(lS(2, 5), onThumbClick), !0;
        }
        function update(initial) {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed)
                return;
            const slidesPerView = lS(2, 6) === thumbsSwiper.params.slidesPerView ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
            let thumbsToActivate = 1;
            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
            (() => {
                const __ifInstance83 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            for (let i = 0; i < thumbsToActivate; i += 1)
                                (() => {
                                    const __callInstance40 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${ swiper.realIndex + i }"]`).addClass(thumbActiveClass);
                                            }
                                        }
                                    });
                                    const __exports = __callInstance40.exports;
                                    return __exports.data();
                                })();
                        },
                        impFunc2: () => {
                            for (let i = 0; i < thumbsToActivate; i += 1)
                                (() => {
                                    const __callInstance39 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
                                            }
                                        }
                                    });
                                    const __exports = __callInstance39.exports;
                                    return __exports.data();
                                })();
                        }
                    }
                });
                const __exports = __ifInstance83.exports;
                return __exports.data((swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides && (thumbsToActivate = swiper.params.slidesPerView), swiper.params.thumbs.multipleActiveThumbs || (thumbsToActivate = 1), thumbsToActivate = Math.floor(thumbsToActivate), thumbsSwiper.slides.removeClass(thumbActiveClass), thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) ? 1 : 0);
            })();
            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset, useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
            (() => {
                const __ifInstance84 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                let currentThumbsIndex = thumbsSwiper.activeIndex, newThumbsIndex, direction;
                                (() => {
                                    const __ifInstance85 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass) && (thumbsSwiper.loopFix(), thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft, currentThumbsIndex = thumbsSwiper.activeIndex);
                                                    const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${ swiper.realIndex }"]`).eq(0).index(), nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${ swiper.realIndex }"]`).eq(0).index();
                                                    newThumbsIndex = void 0 === prevThumbsIndex ? nextThumbsIndex : void 0 === nextThumbsIndex ? prevThumbsIndex : nextThumbsIndex - currentThumbsIndex == currentThumbsIndex - prevThumbsIndex ? thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex : nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex ? nextThumbsIndex : prevThumbsIndex, direction = swiper.activeIndex > swiper.previousIndex ? lS(2, 7) : lS(2, 8);
                                                }
                                            },
                                            impFunc2: () => {
                                                newThumbsIndex = swiper.realIndex, direction = newThumbsIndex > swiper.previousIndex ? lS(2, 9) : lS(2, 10);
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance85.exports;
                                    return __exports.data(thumbsSwiper.params.loop ? 1 : 0);
                                })();
                                useOffset && (newThumbsIndex += lS(2, 11) === direction ? autoScrollOffset : -1 * autoScrollOffset), thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0 && (thumbsSwiper.params.centeredSlides ? newThumbsIndex = newThumbsIndex > currentThumbsIndex ? newThumbsIndex - Math.floor(slidesPerView / 2) + 1 : newThumbsIndex + Math.floor(slidesPerView / 2) - 1 : newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup, thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0));
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance84.exports;
                return __exports.data(swiper.realIndex !== thumbsSwiper.realIndex || useOffset ? 1 : 0);
            })();
        }
        swiper.thumbs = { swiper: null }, on(lS(2, 12), () => {
            const {thumbs: thumbs} = swiper.params;
            thumbs && thumbs.swiper && (init(), update(!0));
        }), on(lS(2, 13), () => {
            (() => {
                const __callInstance38 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            update();
                        }
                    }
                });
                const __exports = __callInstance38.exports;
                return __exports.data();
            })();
        }), on(lS(2, 14), (_s, duration) => {
            const thumbsSwiper = swiper.thumbs.swiper;
            thumbsSwiper && !thumbsSwiper.destroyed && thumbsSwiper.setTransition(duration);
        }), on(lS(2, 15), () => {
            const thumbsSwiper = swiper.thumbs.swiper;
            thumbsSwiper && !thumbsSwiper.destroyed && swiperCreated && thumbsSwiper.destroy();
        }), Object.assign(swiper.thumbs, {
            init: init,
            update: update
        });
    }
    function freeMode(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            emit: emit,
            once: once
        } = _ref;
        function onTouchStart() {
            const translate = swiper.getTranslate();
            swiper.setTranslate(translate), swiper.setTransition(0), swiper.touchEventsData.velocities.length = 0, swiper.freeMode.onTouchEnd({ currentPos: swiper.rtl ? swiper.translate : -swiper.translate });
        }
        function onTouchMove() {
            const {
                touchEventsData: data,
                touches: touches
            } = swiper;
            0 === data.velocities.length && data.velocities.push({
                position: touches[swiper.isHorizontal() ? lS(2, 16) : lS(2, 17)],
                time: data.touchStartTime
            }), data.velocities.push({
                position: touches[swiper.isHorizontal() ? lS(2, 18) : lS(2, 19)],
                time: now()
            });
        }
        function onTouchEnd(_ref2) {
            let {currentPos: currentPos} = _ref2;
            const {
                    params: params,
                    $wrapperEl: $wrapperEl,
                    rtlTranslate: rtl,
                    snapGrid: snapGrid,
                    touchEventsData: data
                } = swiper, touchEndTime = now(), timeDiff = touchEndTime - data.touchStartTime;
            if (currentPos < -swiper.minTranslate())
                (() => {
                    const __callInstance37 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.slideTo(swiper.activeIndex);
                            }
                        }
                    });
                    const __exports = __callInstance37.exports;
                    return __exports.data();
                })();
            else if (currentPos > -swiper.maxTranslate())
                swiper.slides.length < snapGrid.length ? swiper.slideTo(snapGrid.length - 1) : swiper.slideTo(swiper.slides.length - 1);
            else {
                if (params.freeMode.momentum) {
                    (() => {
                        const __ifInstance86 = new WebAssembly.Instance(__ifWasmModule, {
                            env: {
                                impFunc1: () => {
                                    {
                                        const lastMoveEvent = data.velocities.pop(), velocityEvent = data.velocities.pop(), distance = lastMoveEvent.position - velocityEvent.position, time = lastMoveEvent.time - velocityEvent.time;
                                        swiper.velocity = distance / time, swiper.velocity /= 2, Math.abs(swiper.velocity) < params.freeMode.minimumVelocity && (swiper.velocity = 0), (time > 150 || now() - lastMoveEvent.time > 300) && (swiper.velocity = 0);
                                    }
                                },
                                impFunc2: () => {
                                    swiper.velocity = 0;
                                }
                            }
                        });
                        const __exports = __ifInstance86.exports;
                        return __exports.data(data.velocities.length > 1 ? 1 : 0);
                    })();
                    swiper.velocity *= params.freeMode.momentumVelocityRatio, data.velocities.length = 0;
                    let momentumDuration = 1000 * params.freeMode.momentumRatio;
                    const momentumDistance = swiper.velocity * momentumDuration;
                    let newPosition = swiper.translate + momentumDistance;
                    rtl && (newPosition = -newPosition);
                    let doBounce = !1, afterBouncePosition;
                    const bounceAmount = 20 * Math.abs(swiper.velocity) * params.freeMode.momentumBounceRatio;
                    let needsLoopFix;
                    if (newPosition < swiper.maxTranslate())
                        params.freeMode.momentumBounce ? (newPosition + swiper.maxTranslate() < -bounceAmount && (newPosition = swiper.maxTranslate() - bounceAmount), afterBouncePosition = swiper.maxTranslate(), doBounce = !0, data.allowMomentumBounce = !0) : newPosition = swiper.maxTranslate(), params.loop && params.centeredSlides && (needsLoopFix = !0);
                    else if (newPosition > swiper.minTranslate())
                        params.freeMode.momentumBounce ? (newPosition - swiper.minTranslate() > bounceAmount && (newPosition = swiper.minTranslate() + bounceAmount), afterBouncePosition = swiper.minTranslate(), doBounce = !0, data.allowMomentumBounce = !0) : newPosition = swiper.minTranslate(), params.loop && params.centeredSlides && (needsLoopFix = !0);
                    else if (params.freeMode.sticky) {
                        let nextSlide;
                        for (let j = 0; j < snapGrid.length; j += 1)
                            if (snapGrid[j] > -newPosition) {
                                nextSlide = j;
                                break;
                            }
                        newPosition = Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || lS(2, 20) === swiper.swipeDirection ? snapGrid[nextSlide] : snapGrid[nextSlide - 1], newPosition = -newPosition;
                    }
                    if (needsLoopFix && once(lS(2, 21), () => {
                            (() => {
                                const __callInstance36 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            swiper.loopFix();
                                        }
                                    }
                                });
                                const __exports = __callInstance36.exports;
                                return __exports.data();
                            })();
                        }), 0 !== swiper.velocity) {
                        (() => {
                            const __ifInstance87 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate), currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                                            momentumDuration = moveDistance < currentSlideSize ? params.speed : moveDistance < 2 * currentSlideSize ? 1.5 * params.speed : 2.5 * params.speed;
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance87.exports;
                            return __exports.data((momentumDuration = rtl ? Math.abs((-newPosition - swiper.translate) / swiper.velocity) : Math.abs((newPosition - swiper.translate) / swiper.velocity), params.freeMode.sticky) ? 1 : 0);
                        })();
                    } else if (params.freeMode.sticky)
                        return void swiper.slideToClosest();
                    params.freeMode.momentumBounce && doBounce ? (swiper.updateProgress(afterBouncePosition), swiper.setTransition(momentumDuration), swiper.setTranslate(newPosition), swiper.transitionStart(!0, swiper.swipeDirection), swiper.animating = !0, $wrapperEl.transitionEnd(() => {
                        swiper && !swiper.destroyed && data.allowMomentumBounce && (emit(lS(2, 22)), swiper.setTransition(params.speed), setTimeout(() => {
                            swiper.setTranslate(afterBouncePosition), $wrapperEl.transitionEnd(() => {
                                swiper && !swiper.destroyed && swiper.transitionEnd();
                            });
                        }, 0));
                    })) : swiper.velocity ? (emit(lS(2, 23)), swiper.updateProgress(newPosition), swiper.setTransition(momentumDuration), swiper.setTranslate(newPosition), swiper.transitionStart(!0, swiper.swipeDirection), swiper.animating || (swiper.animating = !0, $wrapperEl.transitionEnd(() => {
                        swiper && !swiper.destroyed && swiper.transitionEnd();
                    }))) : swiper.updateProgress(newPosition), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
                } else {
                    if (params.freeMode.sticky)
                        return void swiper.slideToClosest();
                    params.freeMode && emit(lS(2, 24));
                }
                (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) && (swiper.updateProgress(), swiper.updateActiveIndex(), swiper.updateSlidesClasses());
            }
        }
        extendParams({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: 0.02
            }
        }), Object.assign(swiper, {
            freeMode: {
                onTouchStart: onTouchStart,
                onTouchMove: onTouchMove,
                onTouchEnd: onTouchEnd
            }
        });
    }
    function Grid(_ref) {
        let {
                swiper: swiper,
                extendParams: extendParams
            } = _ref, slidesNumberEvenToRows, slidesPerRow, numFullColumns;
        (() => {
            const __callInstance35 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            grid: {
                                rows: 1,
                                fill: 'column'
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance35.exports;
            return __exports.data();
        })();
        const initSlides = slidesLength => {
                const {slidesPerView: slidesPerView} = swiper.params, {
                        rows: rows,
                        fill: fill
                    } = swiper.params.grid;
                slidesPerRow = slidesNumberEvenToRows / rows, numFullColumns = Math.floor(slidesLength / rows), slidesNumberEvenToRows = Math.floor(slidesLength / rows) === slidesLength / rows ? slidesLength : Math.ceil(slidesLength / rows) * rows, lS(2, 25) !== slidesPerView && lS(2, 26) === fill && (slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows));
            }, updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
                const {
                        slidesPerGroup: slidesPerGroup,
                        spaceBetween: spaceBetween
                    } = swiper.params, {
                        rows: rows,
                        fill: fill
                    } = swiper.params.grid;
                let newSlideOrderIndex, column, row;
                (() => {
                    const __ifInstance88 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const groupIndex = Math.floor(i / (slidesPerGroup * rows)), slideIndexInGroup = i - rows * slidesPerGroup * groupIndex, columnsInGroup = 0 === groupIndex ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
                                    row = Math.floor(slideIndexInGroup / columnsInGroup), column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup, newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows, slide.css({
                                        '-webkit-order': newSlideOrderIndex,
                                        order: newSlideOrderIndex
                                    });
                                }
                            },
                            impFunc2: () => {
                                lS(2, 28) === fill ? (column = Math.floor(i / rows), row = i - column * rows, (column > numFullColumns || column === numFullColumns && row === rows - 1) && (row += 1, row >= rows && (row = 0, column += 1))) : (row = Math.floor(i / slidesPerRow), column = i - row * slidesPerRow);
                            }
                        }
                    });
                    const __exports = __ifInstance88.exports;
                    return __exports.data(lS(2, 27) === fill && slidesPerGroup > 1 ? 1 : 0);
                })();
                (() => {
                    const __callInstance34 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                slide.css(getDirectionLabel(lS(2, 29)), 0 !== row ? spaceBetween && `${ spaceBetween }px` : lS(2, 30));
                            }
                        }
                    });
                    const __exports = __callInstance34.exports;
                    return __exports.data();
                })();
            }, updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
                const {
                        spaceBetween: spaceBetween,
                        centeredSlides: centeredSlides,
                        roundLengths: roundLengths
                    } = swiper.params, {rows: rows} = swiper.params.grid;
                (() => {
                    const __ifInstance89 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    (() => {
                                        const __callInstance33 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    snapGrid.splice(0, snapGrid.length);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance33.exports;
                                        return __exports.data();
                                    })();
                                    const newSlidesGrid = [];
                                    (() => {
                                        let i = 0;
                                        const __forInstance88 = new WebAssembly.Instance(__forWasmModule, {
                                            env: {
                                                test: () => {
                                                    return i < snapGrid.length ? 1 : 0;
                                                },
                                                update: () => {
                                                    i += 1;
                                                },
                                                body: () => {
                                                    {
                                                        let slidesGridItem = snapGrid[i];
                                                        roundLengths && (slidesGridItem = Math.floor(slidesGridItem)), snapGrid[i] < swiper.virtualSize + snapGrid[0] && newSlidesGrid.push(slidesGridItem);
                                                    }
                                                }
                                            }
                                        });
                                        const __exports = __forInstance88.exports;
                                        return __exports.data();
                                    })();
                                    (() => {
                                        const __callInstance32 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    snapGrid.push(...newSlidesGrid);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance32.exports;
                                        return __exports.data();
                                    })();
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance89.exports;
                    return __exports.data((swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows, swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween, swiper.$wrapperEl.css({ [getDirectionLabel(lS(2, 31))]: `${ swiper.virtualSize + spaceBetween }px` }), centeredSlides) ? 1 : 0);
                })();
            };
        swiper.grid = {
            initSlides: initSlides,
            updateSlide: updateSlide,
            updateWrapperSize: updateWrapperSize
        };
    }
    function appendSlide(slides) {
        const swiper = this, {
                $wrapperEl: $wrapperEl,
                params: params
            } = swiper;
        (() => {
            const __ifInstance90 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        for (let i = 0; i < slides.length; i += 1)
                            slides[i] && $wrapperEl.append(slides[i]);
                    },
                    impFunc2: () => {
                        (() => {
                            const __callInstance31 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        $wrapperEl.append(slides);
                                    }
                                }
                            });
                            const __exports = __callInstance31.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __ifInstance90.exports;
            return __exports.data((params.loop && swiper.loopDestroy(), lS(2, 32) == typeof slides && lS(2, 33) in slides) ? 1 : 0);
        })();
        params.loop && swiper.loopCreate(), params.observer || swiper.update();
    }
    function prependSlide(slides) {
        const swiper = this, {
                params: params,
                $wrapperEl: $wrapperEl,
                activeIndex: activeIndex
            } = swiper;
        params.loop && swiper.loopDestroy();
        let newActiveIndex = activeIndex + 1;
        (() => {
            const __ifInstance91 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            (() => {
                                let i = 0;
                                const __forInstance90 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return i < slides.length ? 1 : 0;
                                        },
                                        update: () => {
                                            i += 1;
                                        },
                                        body: () => {
                                            slides[i] && $wrapperEl.prepend(slides[i]);
                                        }
                                    }
                                });
                                const __exports = __forInstance90.exports;
                                return __exports.data();
                            })();
                            newActiveIndex = activeIndex + slides.length;
                        }
                    },
                    impFunc2: () => {
                        (() => {
                            const __callInstance30 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        $wrapperEl.prepend(slides);
                                    }
                                }
                            });
                            const __exports = __callInstance30.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __ifInstance91.exports;
            return __exports.data(lS(2, 34) == typeof slides && lS(2, 35) in slides ? 1 : 0);
        })();
        params.loop && swiper.loopCreate(), params.observer || swiper.update(), swiper.slideTo(newActiveIndex, 0, !1);
    }
    function addSlide(index, slides) {
        const swiper = this, {
                $wrapperEl: $wrapperEl,
                params: params,
                activeIndex: activeIndex
            } = swiper;
        let activeIndexBuffer = activeIndex;
        params.loop && (activeIndexBuffer -= swiper.loopedSlides, swiper.loopDestroy(), swiper.slides = $wrapperEl.children(`.${ params.slideClass }`));
        const baseLength = swiper.slides.length;
        if (index <= 0)
            return void swiper.prependSlide(slides);
        if (index >= baseLength)
            return void swiper.appendSlide(slides);
        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        const slidesBuffer = [];
        (() => {
            let i = baseLength - 1;
            const __forInstance91 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i >= index ? 1 : 0;
                    },
                    update: () => {
                        i -= 1;
                    },
                    body: () => {
                        {
                            const currentSlide = swiper.slides.eq(i);
                            currentSlide.remove(), slidesBuffer.unshift(currentSlide);
                        }
                    }
                }
            });
            const __exports = __forInstance91.exports;
            return __exports.data();
        })();
        (() => {
            const __ifInstance92 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            (() => {
                                let i = 0;
                                const __forInstance92 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return i < slides.length ? 1 : 0;
                                        },
                                        update: () => {
                                            i += 1;
                                        },
                                        body: () => {
                                            slides[i] && $wrapperEl.append(slides[i]);
                                        }
                                    }
                                });
                                const __exports = __forInstance92.exports;
                                return __exports.data();
                            })();
                            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
                        }
                    },
                    impFunc2: () => {
                        (() => {
                            const __callInstance29 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        $wrapperEl.append(slides);
                                    }
                                }
                            });
                            const __exports = __callInstance29.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __ifInstance92.exports;
            return __exports.data(lS(2, 36) == typeof slides && lS(2, 37) in slides ? 1 : 0);
        })();
        (() => {
            let i = 0;
            const __forInstance93 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < slidesBuffer.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __callInstance28 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        $wrapperEl.append(slidesBuffer[i]);
                                    }
                                }
                            });
                            const __exports = __callInstance28.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __forInstance93.exports;
            return __exports.data();
        })();
        params.loop && swiper.loopCreate(), params.observer || swiper.update(), params.loop ? swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, !1) : swiper.slideTo(newActiveIndex, 0, !1);
    }
    function removeSlide(slidesIndexes) {
        const swiper = this, {
                params: params,
                $wrapperEl: $wrapperEl,
                activeIndex: activeIndex
            } = swiper;
        let activeIndexBuffer = activeIndex;
        params.loop && (activeIndexBuffer -= swiper.loopedSlides, swiper.loopDestroy(), swiper.slides = $wrapperEl.children(`.${ params.slideClass }`));
        let newActiveIndex = activeIndexBuffer, indexToRemove;
        (() => {
            const __ifInstance93 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            (() => {
                                let i = 0;
                                const __forInstance94 = new WebAssembly.Instance(__forWasmModule, {
                                    env: {
                                        test: () => {
                                            return i < slidesIndexes.length ? 1 : 0;
                                        },
                                        update: () => {
                                            i += 1;
                                        },
                                        body: () => {
                                            indexToRemove = slidesIndexes[i], swiper.slides[indexToRemove] && swiper.slides.eq(indexToRemove).remove(), indexToRemove < newActiveIndex && (newActiveIndex -= 1);
                                        }
                                    }
                                });
                                const __exports = __forInstance94.exports;
                                return __exports.data();
                            })();
                            newActiveIndex = Math.max(newActiveIndex, 0);
                        }
                    },
                    impFunc2: () => {
                        indexToRemove = slidesIndexes, swiper.slides[indexToRemove] && swiper.slides.eq(indexToRemove).remove(), indexToRemove < newActiveIndex && (newActiveIndex -= 1), newActiveIndex = Math.max(newActiveIndex, 0);
                    }
                }
            });
            const __exports = __ifInstance93.exports;
            return __exports.data(lS(2, 38) == typeof slidesIndexes && lS(2, 39) in slidesIndexes ? 1 : 0);
        })();
        params.loop && swiper.loopCreate(), params.observer || swiper.update(), params.loop ? swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, !1) : swiper.slideTo(newActiveIndex, 0, !1);
    }
    function removeAllSlides() {
        const swiper = this, slidesIndexes = [];
        (() => {
            let i = 0;
            const __forInstance95 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < swiper.slides.length ? 1 : 0;
                    },
                    update: () => {
                        i += 1;
                    },
                    body: () => {
                        (() => {
                            const __callInstance27 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        slidesIndexes.push(i);
                                    }
                                }
                            });
                            const __exports = __callInstance27.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __forInstance95.exports;
            return __exports.data();
        })();
        (() => {
            const __callInstance26 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        swiper.removeSlide(slidesIndexes);
                    }
                }
            });
            const __exports = __callInstance26.exports;
            return __exports.data();
        })();
    }
    function Manipulation(_ref) {
        let {swiper: swiper} = _ref;
        (() => {
            const __callInstance25 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.assign(swiper, {
                            appendSlide: appendSlide.bind(swiper),
                            prependSlide: prependSlide.bind(swiper),
                            addSlide: addSlide.bind(swiper),
                            removeSlide: removeSlide.bind(swiper),
                            removeAllSlides: removeAllSlides.bind(swiper)
                        });
                    }
                }
            });
            const __exports = __callInstance25.exports;
            return __exports.data();
        })();
    }
    function effectInit(params) {
        const {
            effect: effect,
            swiper: swiper,
            on: on,
            setTranslate: setTranslate,
            setTransition: setTransition,
            overwriteParams: overwriteParams,
            perspective: perspective,
            recreateShadows: recreateShadows,
            getEffectParams: getEffectParams
        } = params;
        let requireUpdateOnVirtual;
        on(lS(2, 40), () => {
            if (swiper.params.effect !== effect)
                return;
            swiper.classNames.push(`${ swiper.params.containerModifierClass }${ effect }`), perspective && perspective() && swiper.classNames.push(`${ swiper.params.containerModifierClass }3d`);
            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
            Object.assign(swiper.params, overwriteParamsResult), Object.assign(swiper.originalParams, overwriteParamsResult);
        }), on(lS(2, 41), () => {
            swiper.params.effect === effect && setTranslate();
        }), on(lS(2, 42), (_s, duration) => {
            swiper.params.effect === effect && setTransition(duration);
        }), on(lS(2, 43), () => {
            if (swiper.params.effect === effect && recreateShadows) {
                if (!getEffectParams || !getEffectParams().slideShadows)
                    return;
                swiper.slides.each(slideEl => {
                    const $slideEl = swiper.$(slideEl);
                    (() => {
                        const __callInstance24 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    $slideEl.find(lS(2, 44)).remove();
                                }
                            }
                        });
                        const __exports = __callInstance24.exports;
                        return __exports.data();
                    })();
                }), recreateShadows();
            }
        }), on(lS(2, 45), () => {
            swiper.params.effect === effect && (swiper.slides.length || (requireUpdateOnVirtual = !0), requestAnimationFrame(() => {
                requireUpdateOnVirtual && swiper.slides && swiper.slides.length && (setTranslate(), requireUpdateOnVirtual = !1);
            }));
        });
    }
    function effectTarget(effectParams, $slideEl) {
        return effectParams.transformEl ? $slideEl.find(effectParams.transformEl).css({
            'backface-visibility': 'hidden',
            '-webkit-backface-visibility': 'hidden'
        }) : $slideEl;
    }
    function effectVirtualTransitionEnd(_ref) {
        let {
            swiper: swiper,
            duration: duration,
            transformEl: transformEl,
            allSlides: allSlides
        } = _ref;
        const {
            slides: slides,
            activeIndex: activeIndex,
            $wrapperEl: $wrapperEl
        } = swiper;
        if (swiper.params.virtualTranslate && 0 !== duration) {
            let eventTriggered = !1, $transitionEndTarget;
            $transitionEndTarget = allSlides ? transformEl ? slides.find(transformEl) : slides : transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex), $transitionEndTarget.transitionEnd(() => {
                if (eventTriggered)
                    return;
                if (!swiper || swiper.destroyed)
                    return;
                eventTriggered = !0, swiper.animating = !1;
                const triggerEvents = [
                    lS(2, 46),
                    lS(2, 47)
                ];
                (() => {
                    let i = 0;
                    const __forInstance96 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < triggerEvents.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                (() => {
                                    const __callInstance23 = new WebAssembly.Instance(__callWasmModule, {
                                        env: {
                                            impFunc: () => {
                                                $wrapperEl.trigger(triggerEvents[i]);
                                            }
                                        }
                                    });
                                    const __exports = __callInstance23.exports;
                                    return __exports.data();
                                })();
                            }
                        }
                    });
                    const __exports = __forInstance96.exports;
                    return __exports.data();
                })();
            });
        }
    }
    function EffectFade(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance22 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            fadeEffect: {
                                crossFade: !1,
                                transformEl: null
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance22.exports;
            return __exports.data();
        })();
        const setTranslate = () => {
                const {slides: slides} = swiper, params = swiper.params.fadeEffect;
                (() => {
                    let i = 0;
                    const __forInstance97 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < slides.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                {
                                    const $slideEl = swiper.slides.eq(i), offset = $slideEl[0].swiperSlideOffset;
                                    let tx = -offset;
                                    swiper.params.virtualTranslate || (tx -= swiper.translate);
                                    let ty = 0;
                                    swiper.isHorizontal() || (ty = tx, tx = 0);
                                    const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0), $targetEl = effectTarget(params, $slideEl);
                                    (() => {
                                        const __callInstance21 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    $targetEl.css({ opacity: slideOpacity }).transform(`translate3d(${ tx }px, ${ ty }px, 0px)`);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance21.exports;
                                        return __exports.data();
                                    })();
                                }
                            }
                        }
                    });
                    const __exports = __forInstance97.exports;
                    return __exports.data();
                })();
            }, setTransition = duration => {
                const {transformEl: transformEl} = swiper.params.fadeEffect, $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                $transitionElements.transition(duration), effectVirtualTransitionEnd({
                    swiper: swiper,
                    duration: duration,
                    transformEl: transformEl,
                    allSlides: !0
                });
            };
        (() => {
            const __callInstance20 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        effectInit({
                            effect: 'fade',
                            swiper: swiper,
                            on: on,
                            setTranslate: setTranslate,
                            setTransition: setTransition,
                            overwriteParams: () => ({
                                slidesPerView: 1,
                                slidesPerGroup: 1,
                                watchSlidesProgress: !0,
                                spaceBetween: 0,
                                virtualTranslate: !swiper.params.cssMode
                            })
                        });
                    }
                }
            });
            const __exports = __callInstance20.exports;
            return __exports.data();
        })();
    }
    function EffectCube(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance19 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            cubeEffect: {
                                slideShadows: !0,
                                shadow: !0,
                                shadowOffset: 20,
                                shadowScale: 0.94
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance19.exports;
            return __exports.data();
        })();
        const createSlideShadows = ($slideEl, progress, isHorizontal) => {
                let shadowBefore = isHorizontal ? $slideEl.find(lS(2, 48)) : $slideEl.find(lS(2, 49)), shadowAfter = isHorizontal ? $slideEl.find(lS(2, 50)) : $slideEl.find(lS(2, 51));
                0 === shadowBefore.length && (shadowBefore = $(`<div class="swiper-slide-shadow-${ isHorizontal ? lS(2, 52) : lS(2, 53) }"></div>`), $slideEl.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $(`<div class="swiper-slide-shadow-${ isHorizontal ? lS(2, 54) : lS(2, 55) }"></div>`), $slideEl.append(shadowAfter)), shadowBefore.length && (shadowBefore[0].style.opacity = Math.max(-progress, 0)), shadowAfter.length && (shadowAfter[0].style.opacity = Math.max(progress, 0));
            }, recreateShadows = () => {
                const isHorizontal = swiper.isHorizontal();
                (() => {
                    const __callInstance18 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.slides.each(slideEl => {
                                    const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                                    (() => {
                                        const __callInstance17 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    createSlideShadows($(slideEl), progress, isHorizontal);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance17.exports;
                                        return __exports.data();
                                    })();
                                });
                            }
                        }
                    });
                    const __exports = __callInstance18.exports;
                    return __exports.data();
                })();
            }, setTranslate = () => {
                const {
                        $el: $el,
                        $wrapperEl: $wrapperEl,
                        slides: slides,
                        width: swiperWidth,
                        height: swiperHeight,
                        rtlTranslate: rtl,
                        size: swiperSize,
                        browser: browser
                    } = swiper, params = swiper.params.cubeEffect, isHorizontal = swiper.isHorizontal(), isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                let wrapperRotate = 0, $cubeShadowEl;
                params.shadow && (isHorizontal ? ($cubeShadowEl = $wrapperEl.find(lS(2, 56)), 0 === $cubeShadowEl.length && ($cubeShadowEl = $(lS(2, 57)), $wrapperEl.append($cubeShadowEl)), $cubeShadowEl.css({ height: `${ swiperWidth }px` })) : ($cubeShadowEl = $el.find(lS(2, 58)), 0 === $cubeShadowEl.length && ($cubeShadowEl = $(lS(2, 59)), $el.append($cubeShadowEl))));
                (() => {
                    let i = 0;
                    const __forInstance98 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < slides.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                {
                                    const $slideEl = slides.eq(i);
                                    let slideIndex = i;
                                    isVirtual && (slideIndex = parseInt($slideEl.attr(lS(2, 60)), 10));
                                    let slideAngle = 90 * slideIndex, round = Math.floor(slideAngle / 360);
                                    rtl && (slideAngle = -slideAngle, round = Math.floor(-slideAngle / 360));
                                    const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                                    let tx = 0, ty = 0, tz = 0;
                                    slideIndex % 4 == 0 ? (tx = 4 * -round * swiperSize, tz = 0) : (slideIndex - 1) % 4 == 0 ? (tx = 0, tz = 4 * -round * swiperSize) : (slideIndex - 2) % 4 == 0 ? (tx = swiperSize + 4 * round * swiperSize, tz = swiperSize) : (slideIndex - 3) % 4 == 0 && (tx = -swiperSize, tz = 3 * swiperSize + 4 * swiperSize * round), rtl && (tx = -tx), isHorizontal || (ty = tx, tx = 0);
                                    const transform = `rotateX(${ isHorizontal ? 0 : -slideAngle }deg) rotateY(${ isHorizontal ? slideAngle : 0 }deg) translate3d(${ tx }px, ${ ty }px, ${ tz }px)`;
                                    progress <= 1 && progress > -1 && (wrapperRotate = 90 * slideIndex + 90 * progress, rtl && (wrapperRotate = 90 * -slideIndex - 90 * progress)), $slideEl.transform(transform), params.slideShadows && createSlideShadows($slideEl, progress, isHorizontal);
                                }
                            }
                        }
                    });
                    const __exports = __forInstance98.exports;
                    return __exports.data();
                })();
                (() => {
                    const __ifInstance94 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                (() => {
                                    const __ifInstance95 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                (() => {
                                                    const __callInstance16 = new WebAssembly.Instance(__callWasmModule, {
                                                        env: {
                                                            impFunc: () => {
                                                                $cubeShadowEl.transform(`translate3d(0px, ${ swiperWidth / 2 + params.shadowOffset }px, ${ -swiperWidth / 2 }px) rotateX(90deg) rotateZ(0deg) scale(${ params.shadowScale })`);
                                                            }
                                                        }
                                                    });
                                                    const __exports = __callInstance16.exports;
                                                    return __exports.data();
                                                })();
                                            },
                                            impFunc2: () => {
                                                {
                                                    const shadowAngle = Math.abs(wrapperRotate) - 90 * Math.floor(Math.abs(wrapperRotate) / 90), multiplier = 1.5 - (Math.sin(2 * shadowAngle * Math.PI / 360) / 2 + Math.cos(2 * shadowAngle * Math.PI / 360) / 2), scale1 = params.shadowScale, scale2 = params.shadowScale / multiplier, offset = params.shadowOffset;
                                                    (() => {
                                                        const __callInstance15 = new WebAssembly.Instance(__callWasmModule, {
                                                            env: {
                                                                impFunc: () => {
                                                                    $cubeShadowEl.transform(`scale3d(${ scale1 }, 1, ${ scale2 }) translate3d(0px, ${ swiperHeight / 2 + offset }px, ${ -swiperHeight / 2 / scale2 }px) rotateX(-90deg)`);
                                                                }
                                                            }
                                                        });
                                                        const __exports = __callInstance15.exports;
                                                        return __exports.data();
                                                    })();
                                                }
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance95.exports;
                                    return __exports.data(isHorizontal ? 1 : 0);
                                })();
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance94.exports;
                    return __exports.data(($wrapperEl.css({
                        '-webkit-transform-origin': `50% 50% -${ swiperSize / 2 }px`,
                        'transform-origin': `50% 50% -${ swiperSize / 2 }px`
                    }), params.shadow) ? 1 : 0);
                })();
                const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
                $wrapperEl.transform(`translate3d(0px,0,${ zFactor }px) rotateX(${ swiper.isHorizontal() ? 0 : wrapperRotate }deg) rotateY(${ swiper.isHorizontal() ? -wrapperRotate : 0 }deg)`), $wrapperEl[0].style.setProperty(lS(2, 61), `${ zFactor }px`);
            }, setTransition = duration => {
                const {
                    $el: $el,
                    slides: slides
                } = swiper;
                slides.transition(duration).find(lS(2, 62)).transition(duration), swiper.params.cubeEffect.shadow && !swiper.isHorizontal() && $el.find(lS(2, 63)).transition(duration);
            };
        (() => {
            const __callInstance14 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        effectInit({
                            effect: 'cube',
                            swiper: swiper,
                            on: on,
                            setTranslate: setTranslate,
                            setTransition: setTransition,
                            recreateShadows: recreateShadows,
                            getEffectParams: () => swiper.params.cubeEffect,
                            perspective: () => !0,
                            overwriteParams: () => ({
                                slidesPerView: 1,
                                slidesPerGroup: 1,
                                watchSlidesProgress: !0,
                                resistanceRatio: 0,
                                spaceBetween: 0,
                                centeredSlides: !1,
                                virtualTranslate: !0
                            })
                        });
                    }
                }
            });
            const __exports = __callInstance14.exports;
            return __exports.data();
        })();
    }
    function createShadow(params, $slideEl, side) {
        const shadowClass = `swiper-slide-shadow${ side ? `-${ side }` : lS(2, 64) }`, $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
        let $shadowEl = $shadowContainer.children(`.${ shadowClass }`);
        return $shadowEl.length || ($shadowEl = $(`<div class="swiper-slide-shadow${ side ? `-${ side }` : lS(2, 65) }"></div>`), $shadowContainer.append($shadowEl)), $shadowEl;
    }
    function EffectFlip(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance13 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            flipEffect: {
                                slideShadows: !0,
                                limitRotation: !0,
                                transformEl: null
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance13.exports;
            return __exports.data();
        })();
        const createSlideShadows = ($slideEl, progress, params) => {
                let shadowBefore = swiper.isHorizontal() ? $slideEl.find(lS(2, 66)) : $slideEl.find(lS(2, 67)), shadowAfter = swiper.isHorizontal() ? $slideEl.find(lS(2, 68)) : $slideEl.find(lS(2, 69));
                0 === shadowBefore.length && (shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? lS(2, 70) : lS(2, 71))), 0 === shadowAfter.length && (shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? lS(2, 72) : lS(2, 73))), shadowBefore.length && (shadowBefore[0].style.opacity = Math.max(-progress, 0)), shadowAfter.length && (shadowAfter[0].style.opacity = Math.max(progress, 0));
            }, recreateShadows = () => {
                const params = swiper.params.flipEffect;
                (() => {
                    const __callInstance12 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                swiper.slides.each(slideEl => {
                                    const $slideEl = $(slideEl);
                                    let progress = $slideEl[0].progress;
                                    swiper.params.flipEffect.limitRotation && (progress = Math.max(Math.min(slideEl.progress, 1), -1)), createSlideShadows($slideEl, progress, params);
                                });
                            }
                        }
                    });
                    const __exports = __callInstance12.exports;
                    return __exports.data();
                })();
            }, setTranslate = () => {
                const {
                        slides: slides,
                        rtlTranslate: rtl
                    } = swiper, params = swiper.params.flipEffect;
                (() => {
                    let i = 0;
                    const __forInstance99 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < slides.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                {
                                    const $slideEl = slides.eq(i);
                                    let progress = $slideEl[0].progress;
                                    swiper.params.flipEffect.limitRotation && (progress = Math.max(Math.min($slideEl[0].progress, 1), -1));
                                    const offset = $slideEl[0].swiperSlideOffset, rotate = -180 * progress;
                                    let rotateY = rotate, rotateX = 0, tx = swiper.params.cssMode ? -offset - swiper.translate : -offset, ty = 0;
                                    swiper.isHorizontal() ? rtl && (rotateY = -rotateY) : (ty = tx, tx = 0, rotateX = -rotateY, rotateY = 0), $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length, params.slideShadows && createSlideShadows($slideEl, progress, params);
                                    const transform = `translate3d(${ tx }px, ${ ty }px, 0px) rotateX(${ rotateX }deg) rotateY(${ rotateY }deg)`, $targetEl = effectTarget(params, $slideEl);
                                    (() => {
                                        const __callInstance11 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    $targetEl.transform(transform);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance11.exports;
                                        return __exports.data();
                                    })();
                                }
                            }
                        }
                    });
                    const __exports = __forInstance99.exports;
                    return __exports.data();
                })();
            }, setTransition = duration => {
                const {transformEl: transformEl} = swiper.params.flipEffect, $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                $transitionElements.transition(duration).find(lS(2, 74)).transition(duration), effectVirtualTransitionEnd({
                    swiper: swiper,
                    duration: duration,
                    transformEl: transformEl
                });
            };
        (() => {
            const __callInstance10 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        effectInit({
                            effect: 'flip',
                            swiper: swiper,
                            on: on,
                            setTranslate: setTranslate,
                            setTransition: setTransition,
                            recreateShadows: recreateShadows,
                            getEffectParams: () => swiper.params.flipEffect,
                            perspective: () => !0,
                            overwriteParams: () => ({
                                slidesPerView: 1,
                                slidesPerGroup: 1,
                                watchSlidesProgress: !0,
                                spaceBetween: 0,
                                virtualTranslate: !swiper.params.cssMode
                            })
                        });
                    }
                }
            });
            const __exports = __callInstance10.exports;
            return __exports.data();
        })();
    }
    function EffectCoverflow(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance9 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            coverflowEffect: {
                                rotate: 50,
                                stretch: 0,
                                depth: 100,
                                scale: 1,
                                modifier: 1,
                                slideShadows: !0,
                                transformEl: null
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance9.exports;
            return __exports.data();
        })();
        const setTranslate = () => {
                const {
                        width: swiperWidth,
                        height: swiperHeight,
                        slides: slides,
                        slidesSizesGrid: slidesSizesGrid
                    } = swiper, params = swiper.params.coverflowEffect, isHorizontal = swiper.isHorizontal(), transform = swiper.translate, center = isHorizontal ? swiperWidth / 2 - transform : swiperHeight / 2 - transform, rotate = isHorizontal ? params.rotate : -params.rotate, translate = params.depth;
                (() => {
                    let i = 0, length = slides.length;
                    const __forInstance100 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                {
                                    const $slideEl = slides.eq(i), slideSize = slidesSizesGrid[i], slideOffset = $slideEl[0].swiperSlideOffset, centerOffset = (center - slideOffset - slideSize / 2) / slideSize, offsetMultiplier = lS(2, 75) == typeof params.modifier ? params.modifier(centerOffset) : centerOffset * params.modifier;
                                    let rotateY = isHorizontal ? rotate * offsetMultiplier : 0, rotateX = isHorizontal ? 0 : rotate * offsetMultiplier, translateZ = -translate * Math.abs(offsetMultiplier), stretch = params.stretch;
                                    lS(2, 76) == typeof stretch && -1 !== stretch.indexOf(lS(2, 77)) && (stretch = parseFloat(params.stretch) / 100 * slideSize);
                                    let translateY = isHorizontal ? 0 : stretch * offsetMultiplier, translateX = isHorizontal ? stretch * offsetMultiplier : 0, scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
                                    Math.abs(translateX) < 0.001 && (translateX = 0), Math.abs(translateY) < 0.001 && (translateY = 0), Math.abs(translateZ) < 0.001 && (translateZ = 0), Math.abs(rotateY) < 0.001 && (rotateY = 0), Math.abs(rotateX) < 0.001 && (rotateX = 0), Math.abs(scale) < 0.001 && (scale = 0);
                                    const slideTransform = `translate3d(${ translateX }px,${ translateY }px,${ translateZ }px)  rotateX(${ rotateX }deg) rotateY(${ rotateY }deg) scale(${ scale })`, $targetEl = effectTarget(params, $slideEl);
                                    (() => {
                                        const __ifInstance96 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        let $shadowBeforeEl = isHorizontal ? $slideEl.find(lS(2, 78)) : $slideEl.find(lS(2, 79)), $shadowAfterEl = isHorizontal ? $slideEl.find(lS(2, 80)) : $slideEl.find(lS(2, 81));
                                                        0 === $shadowBeforeEl.length && ($shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? lS(2, 82) : lS(2, 83))), 0 === $shadowAfterEl.length && ($shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? lS(2, 84) : lS(2, 85))), $shadowBeforeEl.length && ($shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0), $shadowAfterEl.length && ($shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0);
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance96.exports;
                                        return __exports.data(($targetEl.transform(slideTransform), $slideEl[0].style.zIndex = 1 - Math.abs(Math.round(offsetMultiplier)), params.slideShadows) ? 1 : 0);
                                    })();
                                }
                            }
                        }
                    });
                    const __exports = __forInstance100.exports;
                    return __exports.data();
                })();
            }, setTransition = duration => {
                const {transformEl: transformEl} = swiper.params.coverflowEffect, $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                (() => {
                    const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                $transitionElements.transition(duration).find(lS(2, 86)).transition(duration);
                            }
                        }
                    });
                    const __exports = __callInstance8.exports;
                    return __exports.data();
                })();
            };
        (() => {
            const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        effectInit({
                            effect: 'coverflow',
                            swiper: swiper,
                            on: on,
                            setTranslate: setTranslate,
                            setTransition: setTransition,
                            perspective: () => !0,
                            overwriteParams: () => ({ watchSlidesProgress: !0 })
                        });
                    }
                }
            });
            const __exports = __callInstance7.exports;
            return __exports.data();
        })();
    }
    function EffectCreative(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            creativeEffect: {
                                transformEl: null,
                                limitProgress: 1,
                                shadowPerProgress: !1,
                                progressMultiplier: 1,
                                perspective: !0,
                                prev: {
                                    translate: __lA(1, 20, 32),
                                    rotate: __lA(2, 32, 44),
                                    opacity: 1,
                                    scale: 1
                                },
                                next: {
                                    translate: __lA(3, 44, 56),
                                    rotate: __lA(4, 56, 68),
                                    opacity: 1,
                                    scale: 1
                                }
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance6.exports;
            return __exports.data();
        })();
        const getTranslateValue = value => lS(2, 87) == typeof value ? value : `${ value }px`, setTranslate = () => {
                const {
                        slides: slides,
                        $wrapperEl: $wrapperEl,
                        slidesSizesGrid: slidesSizesGrid
                    } = swiper, params = swiper.params.creativeEffect, {progressMultiplier: multiplier} = params, isCenteredSlides = swiper.params.centeredSlides;
                (() => {
                    const __ifInstance97 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                {
                                    const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                                    (() => {
                                        const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    $wrapperEl.transform(`translateX(calc(50% - ${ margin }px))`);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance5.exports;
                                        return __exports.data();
                                    })();
                                }
                            },
                            impFunc2: () => {
                            }
                        }
                    });
                    const __exports = __ifInstance97.exports;
                    return __exports.data(isCenteredSlides ? 1 : 0);
                })();
                (() => {
                    let i = 0;
                    const __forInstance101 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < slides.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                {
                                    const $slideEl = slides.eq(i), slideProgress = $slideEl[0].progress, progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
                                    let originalProgress = progress;
                                    isCenteredSlides || (originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress));
                                    const offset = $slideEl[0].swiperSlideOffset, t = [
                                            swiper.params.cssMode ? -offset - swiper.translate : -offset,
                                            0,
                                            0
                                        ], r = __lA(5, 68, 80);
                                    let custom = !1;
                                    swiper.isHorizontal() || (t[1] = t[0], t[0] = 0);
                                    let data = {
                                        translate: __lA(6, 80, 92),
                                        rotate: __lA(7, 92, 104),
                                        scale: 1,
                                        opacity: 1
                                    };
                                    progress < 0 ? (data = params.next, custom = !0) : progress > 0 && (data = params.prev, custom = !0), t.forEach((value, index) => {
                                        t[index] = `calc(${ value }px + (${ getTranslateValue(data.translate[index]) } * ${ Math.abs(progress * multiplier) }))`;
                                    }), r.forEach((value, index) => {
                                        r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                                    }), $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                                    const translateString = t.join(lS(2, 88)), rotateString = `rotateX(${ r[0] }deg) rotateY(${ r[1] }deg) rotateZ(${ r[2] }deg)`, scaleString = originalProgress < 0 ? `scale(${ 1 + (1 - data.scale) * originalProgress * multiplier })` : `scale(${ 1 - (1 - data.scale) * originalProgress * multiplier })`, opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier, transform = `translate3d(${ translateString }) ${ rotateString } ${ scaleString }`;
                                    (() => {
                                        const __ifInstance98 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        let $shadowEl = $slideEl.children(lS(2, 89));
                                                        (() => {
                                                            const __ifInstance99 = new WebAssembly.Instance(__ifWasmModule, {
                                                                env: {
                                                                    impFunc1: () => {
                                                                        {
                                                                            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                                                                            $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                                                                        }
                                                                    },
                                                                    impFunc2: () => {
                                                                    }
                                                                }
                                                            });
                                                            const __exports = __ifInstance99.exports;
                                                            return __exports.data((0 === $shadowEl.length && data.shadow && ($shadowEl = createShadow(params, $slideEl)), $shadowEl.length) ? 1 : 0);
                                                        })();
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance98.exports;
                                        return __exports.data(custom && data.shadow || !custom ? 1 : 0);
                                    })();
                                    const $targetEl = effectTarget(params, $slideEl);
                                    $targetEl.transform(transform).css({ opacity: opacityString }), data.origin && $targetEl.css(lS(2, 90), data.origin);
                                }
                            }
                        }
                    });
                    const __exports = __forInstance101.exports;
                    return __exports.data();
                })();
            }, setTransition = duration => {
                const {transformEl: transformEl} = swiper.params.creativeEffect, $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                $transitionElements.transition(duration).find(lS(2, 91)).transition(duration), effectVirtualTransitionEnd({
                    swiper: swiper,
                    duration: duration,
                    transformEl: transformEl,
                    allSlides: !0
                });
            };
        (() => {
            const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        effectInit({
                            effect: 'creative',
                            swiper: swiper,
                            on: on,
                            setTranslate: setTranslate,
                            setTransition: setTransition,
                            perspective: () => swiper.params.creativeEffect.perspective,
                            overwriteParams: () => ({
                                watchSlidesProgress: !0,
                                virtualTranslate: !swiper.params.cssMode
                            })
                        });
                    }
                }
            });
            const __exports = __callInstance4.exports;
            return __exports.data();
        })();
    }
    function EffectCards(_ref) {
        let {
            swiper: swiper,
            extendParams: extendParams,
            on: on
        } = _ref;
        (() => {
            const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        extendParams({
                            cardsEffect: {
                                slideShadows: !0,
                                transformEl: null,
                                rotate: !0,
                                perSlideRotate: 2,
                                perSlideOffset: 8
                            }
                        });
                    }
                }
            });
            const __exports = __callInstance3.exports;
            return __exports.data();
        })();
        const setTranslate = () => {
                const {
                        slides: slides,
                        activeIndex: activeIndex
                    } = swiper, params = swiper.params.cardsEffect, {
                        startTranslate: startTranslate,
                        isTouched: isTouched
                    } = swiper.touchEventsData, currentTranslate = swiper.translate;
                (() => {
                    let i = 0;
                    const __forInstance102 = new WebAssembly.Instance(__forWasmModule, {
                        env: {
                            test: () => {
                                return i < slides.length ? 1 : 0;
                            },
                            update: () => {
                                i += 1;
                            },
                            body: () => {
                                {
                                    const $slideEl = slides.eq(i), slideProgress = $slideEl[0].progress, progress = Math.min(Math.max(slideProgress, -4), 4);
                                    let offset = $slideEl[0].swiperSlideOffset;
                                    swiper.params.centeredSlides && !swiper.params.cssMode && swiper.$wrapperEl.transform(`translateX(${ swiper.minTranslate() }px)`), swiper.params.centeredSlides && swiper.params.cssMode && (offset -= slides[0].swiperSlideOffset);
                                    let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset, tY = 0;
                                    const tZ = -100 * Math.abs(progress);
                                    let scale = 1, rotate = -params.perSlideRotate * progress, tXAdd = params.perSlideOffset - 0.75 * Math.abs(progress);
                                    const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i, isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate, isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
                                    (() => {
                                        const __ifInstance100 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                                                        rotate += -28 * progress * subProgress, scale += -0.5 * subProgress, tXAdd += 96 * subProgress, tY = `${ -25 * subProgress * Math.abs(progress) }%`;
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance100.exports;
                                        return __exports.data(isSwipeToNext || isSwipeToPrev ? 1 : 0);
                                    })();
                                    (() => {
                                        const __ifInstance101 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        const prevY = tY;
                                                        tY = tX, tX = prevY;
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance101.exports;
                                        return __exports.data((tX = progress < 0 ? `calc(${ tX }px + (${ tXAdd * Math.abs(progress) }%))` : progress > 0 ? `calc(${ tX }px + (-${ tXAdd * Math.abs(progress) }%))` : `${ tX }px`, !swiper.isHorizontal()) ? 1 : 0);
                                    })();
                                    const scaleString = progress < 0 ? `${ 1 + (1 - scale) * progress }` : `${ 1 - (1 - scale) * progress }`, transform = `\n        translate3d(${ tX }, ${ tY }, ${ tZ }px)\n        rotateZ(${ params.rotate ? rotate : 0 }deg)\n        scale(${ scaleString })\n      `;
                                    (() => {
                                        const __ifInstance102 = new WebAssembly.Instance(__ifWasmModule, {
                                            env: {
                                                impFunc1: () => {
                                                    {
                                                        let $shadowEl = $slideEl.find(lS(2, 92));
                                                        0 === $shadowEl.length && ($shadowEl = createShadow(params, $slideEl)), $shadowEl.length && ($shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1));
                                                    }
                                                },
                                                impFunc2: () => {
                                                }
                                            }
                                        });
                                        const __exports = __ifInstance102.exports;
                                        return __exports.data(params.slideShadows ? 1 : 0);
                                    })();
                                    $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                                    const $targetEl = effectTarget(params, $slideEl);
                                    (() => {
                                        const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    $targetEl.transform(transform);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance2.exports;
                                        return __exports.data();
                                    })();
                                }
                            }
                        }
                    });
                    const __exports = __forInstance102.exports;
                    return __exports.data();
                })();
            }, setTransition = duration => {
                const {transformEl: transformEl} = swiper.params.cardsEffect, $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                $transitionElements.transition(duration).find(lS(2, 93)).transition(duration), effectVirtualTransitionEnd({
                    swiper: swiper,
                    duration: duration,
                    transformEl: transformEl
                });
            };
        (() => {
            const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        effectInit({
                            effect: 'cards',
                            swiper: swiper,
                            on: on,
                            setTranslate: setTranslate,
                            setTransition: setTransition,
                            perspective: () => !0,
                            overwriteParams: () => ({
                                watchSlidesProgress: !0,
                                virtualTranslate: !swiper.params.cssMode
                            })
                        });
                    }
                }
            });
            const __exports = __callInstance1.exports;
            return __exports.data();
        })();
    }
    Object.keys(prototypes).forEach(prototypeGroup => {
        (() => {
            const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
                            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
                        });
                    }
                }
            });
            const __exports = __callInstance0.exports;
            return __exports.data();
        })();
    }), Swiper.use([
        Resize,
        Observer
    ]);
    const modules = [
        Virtual,
        Keyboard,
        Mousewheel,
        Navigation,
        Pagination,
        Scrollbar,
        Parallax,
        Zoom,
        Lazy,
        Controller,
        A11y,
        History,
        HashNavigation,
        Autoplay,
        Thumb,
        freeMode,
        Grid,
        Manipulation,
        EffectFade,
        EffectCube,
        EffectFlip,
        EffectCoverflow,
        EffectCreative,
        EffectCards
    ];
    return Swiper.use(modules), Swiper;
});</script>
</body>
</html>
