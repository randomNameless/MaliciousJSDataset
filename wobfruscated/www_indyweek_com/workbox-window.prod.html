<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>workbox-window.prod.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEG5ICAgAARfwBBAQt/AEEcC38AQTQLfwBBwgALfwBB0AALfwBB3AALfwBB6AALfwBB8gALfwBB/gALfwBBjAELfwBBlgELfwBBoAELfwBBqgELfwBBsAELfwBBvgELfwBByAELfwBB1gELB5mBgIAAEgZtZW1vcnkCAAVkYXRhMAMABWRhdGExAwEFZGF0YTIDAgVkYXRhMwMDBWRhdGE0AwQFZGF0YTUDBQVkYXRhNgMGBWRhdGE3AwcFZGF0YTgDCAVkYXRhOQMJBmRhdGExMAMKBmRhdGExMQMLBmRhdGExMgMMBmRhdGExMwMNBmRhdGExNAMOBmRhdGExNQMPBmRhdGExNgMQC66CgIAAEQBBAQsZd29ya2JveCUzQXdpbmRvdyUzQTcuMi4wAABBHAsXd29ya2JveCUzQWNvcmUlM0E3LjIuMAAAQTQLDHVwZGF0ZWZvdW5kAABBwgALDHN0YXRlY2hhbmdlAABB0AALCmluc3RhbGxlZAAAQdwACwppbnN0YWxsZWQAAEHoAAsId2FpdGluZwAAQfIACwthY3RpdmF0aW5nAABB/gALDGNvbnRyb2xsaW5nAABBjAELCG1lc3NhZ2UAAEGWAQsIbWVzc2FnZQAAQaABCwljb21wbGV0ZQAAQaoBCwVsb2FkAABBsAELDHN0YXRlY2hhbmdlAABBvgELCHdhaXRpbmcAAEHIAQsMdXBkYXRlZm91bmQAAEHWAQsRY29udHJvbGxlcmNoYW5nZQA='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
try {
    self[lS(0, 0)] && _();
} catch (t) {
}
function t(t, s) {
    return new Promise(i => {
        const e = new MessageChannel();
        e.port1.onmessage = t => {
            (() => {
                const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            i(t.data);
                        }
                    }
                });
                const __exports = __callInstance4.exports;
                return __exports.data();
            })();
        }, t.postMessage(s, [e.port2]);
    });
}
try {
    self[lS(0, 1)] && _();
} catch (t) {
}
class s {
    constructor() {
        this.promise = new Promise((t, s) => {
            this.resolve = t, this.reject = s;
        });
    }
}
class i {
    constructor() {
        this.Lt = new Map();
    }
    addEventListener(t, s) {
        (() => {
            const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        this.It(t).add(s);
                    }
                }
            });
            const __exports = __callInstance3.exports;
            return __exports.data();
        })();
    }
    removeEventListener(t, s) {
        (() => {
            const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        this.It(t).delete(s);
                    }
                }
            });
            const __exports = __callInstance2.exports;
            return __exports.data();
        })();
    }
    dispatchEvent(t) {
        t.target = this;
        const s = this.It(t.type);
        for (const i of s)
            (() => {
                const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            i(t);
                        }
                    }
                });
                const __exports = __callInstance1.exports;
                return __exports.data();
            })();
    }
    It(t) {
        return this.Lt.has(t) || this.Lt.set(t, new Set()), this.Lt.get(t);
    }
}
function e(t, s) {
    const {href: i} = location;
    return new URL(t, i).href === new URL(s, i).href;
}
class h {
    constructor(t, s) {
        this.type = t, Object.assign(this, s);
    }
}
const n = { type: 'SKIP_WAITING' };
class a extends i {
    constructor(t, i = {}) {
        super(), this.Bt = {}, this.Tt = 0, this.Mt = new s(), this.At = new s(), this.Gt = new s(), this.Kt = 0, this.Nt = new Set(), this.zt = () => {
            const t = this.Dt, s = t.installing;
            this.Tt > 0 || !e(s.scriptURL, this.Ft.toString()) || performance.now() > this.Kt + 60000 ? (this.Ht = s, t.removeEventListener(lS(0, 2), this.zt)) : (this.Jt = s, this.Nt.add(s), this.Mt.resolve(s)), ++this.Tt, s.addEventListener(lS(0, 3), this.Qt);
        }, this.Qt = t => {
            const s = this.Dt, i = t.target, {state: e} = i, n = i === this.Ht, a = {
                    sw: i,
                    isExternal: n,
                    originalEvent: t
                };
            !n && this.Vt && (a.isUpdate = !0), this.dispatchEvent(new h(e, a)), lS(0, 4) === e ? this.Xt = self.setTimeout(() => {
                lS(0, 5) === e && s.waiting === i && this.dispatchEvent(new h(lS(0, 6), a));
            }, 200) : lS(0, 7) === e && (clearTimeout(this.Xt), n || this.At.resolve(i));
        }, this.Yt = t => {
            const s = this.Jt, i = s !== navigator.serviceWorker.controller;
            this.dispatchEvent(new h(lS(0, 8), {
                isExternal: i,
                originalEvent: t,
                sw: s,
                isUpdate: this.Vt
            })), i || this.Gt.resolve(s);
        }, this.Zt = async t => {
            const {
                data: s,
                ports: i,
                source: e
            } = t;
            await this.getSW(), this.Nt.has(e) && this.dispatchEvent(new h(lS(0, 9), {
                data: s,
                originalEvent: t,
                ports: i,
                sw: e
            }));
        }, this.Ft = t, this.Bt = i, navigator.serviceWorker.addEventListener(lS(0, 10), this.Zt);
    }
    async register({
        immediate: t = !1
    } = {}) {
        t || lS(0, 11) === document.readyState || await new Promise(t => window.addEventListener(lS(0, 12), t)), this.Vt = Boolean(navigator.serviceWorker.controller), this.ts = this.ss(), this.Dt = await this.es(), this.ts && (this.Jt = this.ts, this.At.resolve(this.ts), this.Gt.resolve(this.ts), this.ts.addEventListener(lS(0, 13), this.Qt, { once: !0 }));
        const s = this.Dt.waiting;
        return s && e(s.scriptURL, this.Ft.toString()) && (this.Jt = s, Promise.resolve().then(() => {
            (() => {
                const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            this.dispatchEvent(new h(lS(0, 14), {
                                sw: s,
                                wasWaitingBeforeRegister: !0
                            }));
                        }
                    }
                });
                const __exports = __callInstance0.exports;
                return __exports.data();
            })();
        }).then(() => {
        })), this.Jt && (this.Mt.resolve(this.Jt), this.Nt.add(this.Jt)), this.Dt.addEventListener(lS(0, 15), this.zt), navigator.serviceWorker.addEventListener(lS(0, 16), this.Yt), this.Dt;
    }
    async update() {
        this.Dt && await this.Dt.update();
    }
    get active() {
        return this.At.promise;
    }
    get controlling() {
        return this.Gt.promise;
    }
    getSW() {
        return void 0 !== this.Jt ? Promise.resolve(this.Jt) : this.Mt.promise;
    }
    async messageSW(s) {
        return t(await this.getSW(), s);
    }
    messageSkipWaiting() {
        this.Dt && this.Dt.waiting && t(this.Dt.waiting, n);
    }
    ss() {
        const t = navigator.serviceWorker.controller;
        return t && e(t.scriptURL, this.Ft.toString()) ? t : void 0;
    }
    async es() {
        try {
            const t = await navigator.serviceWorker.register(this.Ft, this.Bt);
            return this.Kt = performance.now(), t;
        } catch (t) {
            throw t;
        }
    }
}
export {
    a as Workbox,
    h as WorkboxEvent,
    t as messageSW
};</script>
</body>
</html>
