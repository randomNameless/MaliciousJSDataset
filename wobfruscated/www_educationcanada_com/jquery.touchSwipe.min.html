<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>jquery.touchSwipe.min.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEGsIOAgABJfwBBAQt/AEEMC38AQRQLfwBBIAt/AEEuC38AQTYLfwBBPAt/AEHKAAt/AEHSAAt/AEHeAAt/AEHqAAt/AEH0AAt/AEGAAQt/AEGOAQt/AEGYAQt/AEGiAQt/AEGoAQt/AEGuAQt/AEG6AQt/AEHEAQt/AEHOAQt/AEHYAQt/AEHoAQt/AEH2AQt/AEGCAgt/AEGOAgt/AEGeAgt/AEGsAgt/AEG4Agt/AEHEAgt/AEHSAgt/AEHeAgt/AEHoAgt/AEHyAgt/AEH+Agt/AEGKAwt/AEGcAwt/AEGsAwt/AEG6Awt/AEHCAwt/AEHgAwt/AEHmAwt/AEH8Awt/AEGEBAt/AEGQBAt/AEHEBAt/AEHMBAt/AEHSBAt/AEHaBAt/AEHeBAt/AEHkBAt/AEHoBAt/AEHuBAt/AEH0BAt/AEH6BAt/AEGCBQt/AEGKBQt/AEGQBQt/AEGcBQt/AEGmBQt/AEGyBQt/AEG8BQt/AEHCBQt/AEHKBQt/AEHQBQt/AEHWBQt/AEHeBQt/AEHsBQt/AEH4BQt/AEGABgt/AEGMBgt/AEG4Bgt/AEHABgsHkYWAgABKBm1lbW9yeQIABWRhdGEwAwAFZGF0YTEDAQVkYXRhMgMCBWRhdGEzAwMFZGF0YTQDBAVkYXRhNQMFBWRhdGE2AwYFZGF0YTcDBwVkYXRhOAMIBWRhdGE5AwkGZGF0YTEwAwoGZGF0YTExAwsGZGF0YTEyAwwGZGF0YTEzAw0GZGF0YTE0Aw4GZGF0YTE1Aw8GZGF0YTE2AxAGZGF0YTE3AxEGZGF0YTE4AxIGZGF0YTE5AxMGZGF0YTIwAxQGZGF0YTIxAxUGZGF0YTIyAxYGZGF0YTIzAxcGZGF0YTI0AxgGZGF0YTI1AxkGZGF0YTI2AxoGZGF0YTI3AxsGZGF0YTI4AxwGZGF0YTI5Ax0GZGF0YTMwAx4GZGF0YTMxAx8GZGF0YTMyAyAGZGF0YTMzAyEGZGF0YTM0AyIGZGF0YTM1AyMGZGF0YTM2AyQGZGF0YTM3AyUGZGF0YTM4AyYGZGF0YTM5AycGZGF0YTQwAygGZGF0YTQxAykGZGF0YTQyAyoGZGF0YTQzAysGZGF0YTQ0AywGZGF0YTQ1Ay0GZGF0YTQ2Ay4GZGF0YTQ3Ay8GZGF0YTQ4AzAGZGF0YTQ5AzEGZGF0YTUwAzIGZGF0YTUxAzMGZGF0YTUyAzQGZGF0YTUzAzUGZGF0YTU0AzYGZGF0YTU1AzcGZGF0YTU2AzgGZGF0YTU3AzkGZGF0YTU4AzoGZGF0YTU5AzsGZGF0YTYwAzwGZGF0YTYxAz0GZGF0YTYyAz4GZGF0YTYzAz8GZGF0YTY0A0AGZGF0YTY1A0EGZGF0YTY2A0IGZGF0YTY3A0MGZGF0YTY4A0QGZGF0YTY5A0UGZGF0YTcwA0YGZGF0YTcxA0cGZGF0YTcyA0gLgomAgABJAEEBCwlmdW5jdGlvbgAAQQwLB2pxdWVyeQAAQRQLCnVuZGVmaW5lZAAAQSALDXVzZSUyMHN0cmljdAAAQS4LBm1vdXNlAABBNgsFaG9sZAAAQTwLDHN3aXBlU3RhdHVzAABBygALBnN3aXBlAABB0gALCnN3aXBlTGVmdAAAQd4ACwtzd2lwZVJpZ2h0AABB6gALCHN3aXBlVXAAAEH0AAsKc3dpcGVEb3duAABBgAELDHBpbmNoU3RhdHVzAABBjgELCHBpbmNoSW4AAEGYAQsJcGluY2hPdXQAAEGiAQsEdGFwAABBqAELBHRhcAAAQa4BCwpkb3VibGV0YXAAAEG6AQsIbG9uZ3RhcAAAQcQBCwlfaW50b3VjaAAAQc4BCwlfaW50b3VjaAAAQdgBCw5NU1BvaW50ZXJEb3duAABB6AELDHBvaW50ZXJkb3duAABB9gELC3RvdWNoc3RhcnQAAEGCAgsKbW91c2Vkb3duAABBjgILDk1TUG9pbnRlck1vdmUAAEGeAgsMcG9pbnRlcm1vdmUAAEGsAgsKdG91Y2htb3ZlAABBuAILCm1vdXNlbW92ZQAAQcQCCwxNU1BvaW50ZXJVcAAAQdICCwpwb2ludGVydXAAAEHeAgsJdG91Y2hlbmQAAEHoAgsIbW91c2V1cAAAQfICCwttb3VzZWxlYXZlAABB/gILC21vdXNlbGVhdmUAAEGKAwsQTVNQb2ludGVyQ2FuY2VsAABBnAMLDnBvaW50ZXJjYW5jZWwAAEGsAwsMdG91Y2hjYW5jZWwAAEG6AwsGc3RhcnQAAEHCAwscZXZlbnRzJTIwbm90JTIwc3VwcG9ydGVkJTIwAABB4AMLBCUyQwAAQeYDCxUlMjBvbiUyMGpRdWVyeS5zd2lwZQAAQfwDCwdvYmplY3QAAEGEBAsKT3B0aW9uJTIwAABBkAQLMiUyMGRvZXMlMjBub3QlMjBleGlzdCUyMG9uJTIwalF1ZXJ5LnN3aXBlLm9wdGlvbnMAAEHEBAsHMS42LjE4AABBzAQLBWxlZnQAAEHSBAsGcmlnaHQAAEHaBAsDdXAAAEHeBAsFZG93bgAAQeQECwNpbgAAQegECwRvdXQAAEHuBAsFbm9uZQAAQfQECwVhdXRvAABB+gQLBnN3aXBlAABBggULBnBpbmNoAABBigULBHRhcAAAQZAFCwpkb3VibGV0YXAAAEGcBQsIbG9uZ3RhcAAAQaYFCwtob3Jpem9udGFsAABBsgULCXZlcnRpY2FsAABBvAULBGFsbAAAQcIFCwZzdGFydAAAQcoFCwVtb3ZlAABB0AULBGVuZAAAQdYFCwdjYW5jZWwAAEHeBQsNb250b3VjaHN0YXJ0AABB7AULC1RvdWNoU3dpcGUAAEH4BQsHc3RyaW5nAABBgAYLCk1ldGhvZCUyMAAAQYwGCyolMjBkb2VzJTIwbm90JTIwZXhpc3QlMjBvbiUyMGpRdWVyeS5zd2lwZQAAQbgGCwdvYmplY3QAAEHABgsHb2JqZWN0AA=='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
!function (factory) {
    lS(0, 0) == typeof define && define.amd && define.amd.jQuery ? define([lS(0, 1)], factory) : factory(lS(0, 2) != typeof module && module.exports ? require('jquery') : jQuery);
}(function ($) {
    lS(0, 3);
    function init(options) {
        return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function () {
            var $this = $(this), plugin = $this.data(PLUGIN_NS);
            plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin));
        });
    }
    function TouchSwipe(element, options) {
        function touchStart(jqEvent) {
            if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
                var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
                if (!event.pointerType || lS(0, 4) != event.pointerType || 0 != options.fallbackToMouseEvents) {
                    var ret, touches = event.touches, evt = touches ? touches[0] : event;
                    return phase = PHASE_START, touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), distance = 0, direction = null, currentDirection = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), createFingerData(0, evt), !touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (options.hold && (holdTimeout = setTimeout($.proxy(function () {
                        $element.trigger(lS(0, 5), [event.target]), options.hold && (ret = options.hold.call($element, event, event.target));
                    }, this), options.longTapThreshold)), setTouchInProgress(!0), null);
                }
            }
        }
        function touchMove(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            (() => {
                const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                var ret, touches = event.touches, evt = touches ? touches[0] : event, currentFinger = updateFingerData(evt);
                                (() => {
                                    const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    (() => {
                                                        const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                                                            env: {
                                                                impFunc1: () => {
                                                                    {
                                                                        var inBounds = !0;
                                                                        (() => {
                                                                            const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
                                                                                env: {
                                                                                    impFunc1: () => {
                                                                                        {
                                                                                            var bounds = getbounds(this);
                                                                                            inBounds = isInBounds(currentFinger.end, bounds);
                                                                                        }
                                                                                    },
                                                                                    impFunc2: () => {
                                                                                    }
                                                                                }
                                                                            });
                                                                            const __exports = __ifInstance3.exports;
                                                                            return __exports.data(options.triggerOnTouchLeave ? 1 : 0);
                                                                        })();
                                                                        !options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), phase != PHASE_CANCEL && phase != PHASE_END || triggerHandler(event, phase);
                                                                    }
                                                                },
                                                                impFunc2: () => {
                                                                }
                                                            }
                                                        });
                                                        const __exports = __ifInstance2.exports;
                                                        return __exports.data((direction = calculateDirection(currentFinger.start, currentFinger.end), currentDirection = calculateDirection(currentFinger.last, currentFinger.end), validateDefaultEvent(jqEvent, currentDirection), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), ret = triggerHandler(event, phase), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) ? 1 : 0);
                                                    })();
                                                }
                                            },
                                            impFunc2: () => {
                                                phase = PHASE_CANCEL, triggerHandler(event, phase);
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance1.exports;
                                    return __exports.data((endTime = getTimeStamp(), touches && (fingerCount = touches.length), options.hold && clearTimeout(holdTimeout), phase = PHASE_MOVE, 2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) ? 1 : 0);
                                })();
                                ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase));
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance0.exports;
                return __exports.data(phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease() ? 1 : 0);
            })();
        }
        function touchEnd(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent, touches = event.touches;
            if (touches) {
                if (touches.length && !inMultiFingerRelease())
                    return startMultiFingerRelease(event), !0;
                if (touches.length && inMultiFingerRelease())
                    return !0;
            }
            return inMultiFingerRelease() && (fingerCount = fingerCountAtRelease), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() || !validateSwipeDistance() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || options.triggerOnTouchEnd === !1 && phase === PHASE_MOVE ? (options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null;
        }
        function touchCancel() {
            fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1);
        }
        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase));
        }
        function removeListeners() {
            $element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1);
        }
        function getNextPhase(currentPhase) {
            var nextPhase = currentPhase, validTime = validateSwipeTime(), validDistance = validateSwipeDistance(), didCancel = didSwipeBackToCancel();
            return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase;
        }
        function triggerHandler(event, phase) {
            var ret, touches = event.touches;
            return (didSwipe() || hasSwipes()) && (ret = triggerHandlerForGesture(event, phase, SWIPE)), (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)), ret;
        }
        function triggerHandlerForGesture(event, phase, gesture) {
            var ret;
            if (gesture == SWIPE) {
                if ($element.trigger(lS(0, 6), [
                        phase,
                        direction || null,
                        distance || 0,
                        duration || 0,
                        fingerCount,
                        fingerData,
                        currentDirection
                    ]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection), ret === !1))
                    return !1;
                if (phase == PHASE_END && validateSwipe()) {
                    if (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), $element.trigger(lS(0, 7), [
                            direction,
                            distance,
                            duration,
                            fingerCount,
                            fingerData,
                            currentDirection
                        ]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection), ret === !1))
                        return !1;
                    switch (direction) {
                    case LEFT:
                        $element.trigger(lS(0, 8), [
                            direction,
                            distance,
                            duration,
                            fingerCount,
                            fingerData,
                            currentDirection
                        ]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                        break;
                    case RIGHT:
                        $element.trigger(lS(0, 9), [
                            direction,
                            distance,
                            duration,
                            fingerCount,
                            fingerData,
                            currentDirection
                        ]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                        break;
                    case UP:
                        $element.trigger(lS(0, 10), [
                            direction,
                            distance,
                            duration,
                            fingerCount,
                            fingerData,
                            currentDirection
                        ]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                        break;
                    case DOWN:
                        $element.trigger(lS(0, 11), [
                            direction,
                            distance,
                            duration,
                            fingerCount,
                            fingerData,
                            currentDirection
                        ]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                    }
                }
            }
            if (gesture == PINCH) {
                if ($element.trigger(lS(0, 12), [
                        phase,
                        pinchDirection || null,
                        pinchDistance || 0,
                        duration || 0,
                        fingerCount,
                        pinchZoom,
                        fingerData
                    ]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData), ret === !1))
                    return !1;
                if (phase == PHASE_END && validatePinch())
                    switch (pinchDirection) {
                    case IN:
                        $element.trigger(lS(0, 13), [
                            pinchDirection || null,
                            pinchDistance || 0,
                            duration || 0,
                            fingerCount,
                            pinchZoom,
                            fingerData
                        ]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
                        break;
                    case OUT:
                        $element.trigger(lS(0, 14), [
                            pinchDirection || null,
                            pinchDistance || 0,
                            duration || 0,
                            fingerCount,
                            pinchZoom,
                            fingerData
                        ]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
                    }
            }
            return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function () {
                doubleTapStartTime = null, $element.trigger(lS(0, 15), [event.target]), options.tap && (ret = options.tap.call($element, event, event.target));
            }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger(lS(0, 16), [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), doubleTapStartTime = null, $element.trigger(lS(0, 17), [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger(lS(0, 18), [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target)))), ret;
        }
        function validateSwipeDistance() {
            var valid = !0;
            return null !== options.threshold && (valid = distance >= options.threshold), valid;
        }
        function didSwipeBackToCancel() {
            var cancelled = !1;
            return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled;
        }
        function validatePinchDistance() {
            return null !== options.pinchThreshold ? pinchDistance >= options.pinchThreshold : !0;
        }
        function validateSwipeTime() {
            var result;
            return result = options.maxTimeThreshold ? !(duration >= options.maxTimeThreshold) : !0;
        }
        function validateDefaultEvent(jqEvent, direction) {
            if (options.preventDefaultEvents !== !1)
                if (options.allowPageScroll === NONE)
                    (() => {
                        const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    jqEvent.preventDefault();
                                }
                            }
                        });
                        const __exports = __callInstance4.exports;
                        return __exports.data();
                    })();
                else {
                    var auto = options.allowPageScroll === AUTO;
                    switch (direction) {
                    case LEFT:
                        (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                        break;
                    case RIGHT:
                        (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                        break;
                    case UP:
                        (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                        break;
                    case DOWN:
                        (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                        break;
                    case NONE:
                    }
                }
        }
        function validatePinch() {
            var hasCorrectFingerCount = validateFingers(), hasEndPoint = validateEndPoint(), hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
        }
        function hasPinches() {
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
        }
        function didPinch() {
            return !(!validatePinch() || !hasPinches());
        }
        function validateSwipe() {
            var hasValidTime = validateSwipeTime(), hasValidDistance = validateSwipeDistance(), hasCorrectFingerCount = validateFingers(), hasEndPoint = validateEndPoint(), didCancel = didSwipeBackToCancel(), valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
            return valid;
        }
        function hasSwipes() {
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
        }
        function didSwipe() {
            return !(!validateSwipe() || !hasSwipes());
        }
        function validateFingers() {
            return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH;
        }
        function validateEndPoint() {
            return 0 !== fingerData[0].end.x;
        }
        function hasTap() {
            return !!options.tap;
        }
        function hasDoubleTap() {
            return !!options.doubleTap;
        }
        function hasLongTap() {
            return !!options.longTap;
        }
        function validateDoubleTap() {
            if (null == doubleTapStartTime)
                return !1;
            var now = getTimeStamp();
            return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold;
        }
        function inDoubleTap() {
            return validateDoubleTap();
        }
        function validateTap() {
            return (1 === fingerCount || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold);
        }
        function validateLongTap() {
            return duration > options.longTapThreshold && DOUBLE_TAP_THRESHOLD > distance;
        }
        function didTap() {
            return !(!validateTap() || !hasTap());
        }
        function didDoubleTap() {
            return !(!validateDoubleTap() || !hasDoubleTap());
        }
        function didLongTap() {
            return !(!validateLongTap() || !hasLongTap());
        }
        function startMultiFingerRelease(event) {
            previousTouchEndTime = getTimeStamp(), fingerCountAtRelease = event.touches.length + 1;
        }
        function cancelMultiFingerRelease() {
            previousTouchEndTime = 0, fingerCountAtRelease = 0;
        }
        function inMultiFingerRelease() {
            var withinThreshold = !1;
            (() => {
                const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                var diff = getTimeStamp() - previousTouchEndTime;
                                diff <= options.fingerReleaseThreshold && (withinThreshold = !0);
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance4.exports;
                return __exports.data(previousTouchEndTime ? 1 : 0);
            })();
            return withinThreshold;
        }
        function getTouchInProgress() {
            return !($element.data(PLUGIN_NS + lS(0, 19)) !== !0);
        }
        function setTouchInProgress(val) {
            $element && (val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), $element.unbind(END_EV, touchEnd, !1), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), $element.data(PLUGIN_NS + lS(0, 20), val === !0));
        }
        function createFingerData(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            return f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX, f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY, fingerData[id] = f, f;
        }
        function updateFingerData(evt) {
            var id = void 0 !== evt.identifier ? evt.identifier : 0, f = getFingerData(id);
            return null === f && (f = createFingerData(id, evt)), f.last.x = f.end.x, f.last.y = f.end.y, f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f;
        }
        function getFingerData(id) {
            return fingerData[id] || null;
        }
        function setMaxDistance(direction, distance) {
            direction != NONE && (distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance);
        }
        function getMaxDistance(direction) {
            return maximumsMap[direction] ? maximumsMap[direction].distance : void 0;
        }
        function createMaximumsData() {
            var maxData = {};
            return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData;
        }
        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            };
        }
        function calculateDuration() {
            return endTime - startTime;
        }
        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX = Math.abs(startPoint.x - endPoint.x), diffY = Math.abs(startPoint.y - endPoint.y);
            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        }
        function calculatePinchZoom(startDistance, endDistance) {
            var percent = endDistance / startDistance * 1;
            return percent.toFixed(2);
        }
        function calculatePinchDirection() {
            return 1 > pinchZoom ? OUT : IN;
        }
        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        }
        function calculateAngle(startPoint, endPoint) {
            var x = startPoint.x - endPoint.x, y = endPoint.y - startPoint.y, r = Math.atan2(y, x), angle = Math.round(180 * r / Math.PI);
            return 0 > angle && (angle = 360 - Math.abs(angle)), angle;
        }
        function calculateDirection(startPoint, endPoint) {
            if (comparePoints(startPoint, endPoint))
                return NONE;
            var angle = calculateAngle(startPoint, endPoint);
            return 45 >= angle && angle >= 0 ? LEFT : 360 >= angle && angle >= 315 ? LEFT : angle >= 135 && 225 >= angle ? RIGHT : angle > 45 && 135 > angle ? DOWN : UP;
        }
        function getTimeStamp() {
            var now = new Date();
            return now.getTime();
        }
        function getbounds(el) {
            el = $(el);
            var offset = el.offset(), bounds = {
                    left: offset.left,
                    right: offset.left + el.outerWidth(),
                    top: offset.top,
                    bottom: offset.top + el.outerHeight()
                };
            return bounds;
        }
        function isInBounds(point, bounds) {
            return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom;
        }
        function comparePoints(pointA, pointB) {
            return pointA.x == pointB.x && pointA.y == pointB.y;
        }
        var options = $.extend({}, options), useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents, START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? lS(0, 21) : lS(0, 22) : lS(0, 23) : lS(0, 24), MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? lS(0, 25) : lS(0, 26) : lS(0, 27) : lS(0, 28), END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? lS(0, 29) : lS(0, 30) : lS(0, 31) : lS(0, 32), LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? lS(0, 33) : null : lS(0, 34), CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? lS(0, 35) : lS(0, 36) : lS(0, 37), distance = 0, direction = null, currentDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, pinchDirection = 0, maximumsMap = null, $element = $(element), phase = lS(0, 38), fingerCount = 0, fingerData = {}, startTime = 0, endTime = 0, previousTouchEndTime = 0, fingerCountAtRelease = 0, doubleTapStartTime = 0, singleTapTimeout = null, holdTimeout = null;
        try {
            $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel);
        } catch (e) {
            (() => {
                const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $.error(lS(0, 39) + START_EV + lS(0, 40) + CANCEL_EV + lS(0, 41));
                        }
                    }
                });
                const __exports = __callInstance3.exports;
                return __exports.data();
            })();
        }
        this.enable = function () {
            return this.disable(), $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), $element;
        }, this.disable = function () {
            return removeListeners(), $element;
        }, this.destroy = function () {
            removeListeners(), $element.data(PLUGIN_NS, null), $element = null;
        }, this.option = function (property, value) {
            if (lS(0, 42) == typeof property)
                options = $.extend(options, property);
            else if (void 0 !== options[property]) {
                if (void 0 === value)
                    return options[property];
                options[property] = value;
            } else {
                if (!property)
                    return options;
                (() => {
                    const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                        env: {
                            impFunc: () => {
                                $.error(lS(0, 43) + property + lS(0, 44));
                            }
                        }
                    });
                    const __exports = __callInstance2.exports;
                    return __exports.data();
                })();
            }
            return null;
        };
    }
    var VERSION = lS(0, 45), LEFT = lS(0, 46), RIGHT = lS(0, 47), UP = lS(0, 48), DOWN = lS(0, 49), IN = lS(0, 50), OUT = lS(0, 51), NONE = lS(0, 52), AUTO = lS(0, 53), SWIPE = lS(0, 54), PINCH = lS(0, 55), TAP = lS(0, 56), DOUBLE_TAP = lS(0, 57), LONG_TAP = lS(0, 58), HORIZONTAL = lS(0, 59), VERTICAL = lS(0, 60), ALL_FINGERS = lS(0, 61), DOUBLE_TAP_THRESHOLD = 10, PHASE_START = lS(0, 62), PHASE_MOVE = lS(0, 63), PHASE_END = lS(0, 64), PHASE_CANCEL = lS(0, 65), SUPPORTS_TOUCH = lS(0, 66) in window, SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH, SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH, PLUGIN_NS = lS(0, 67), defaults = {
            fingers: 1,
            threshold: 75,
            cancelThreshold: null,
            pinchThreshold: 20,
            maxTimeThreshold: null,
            fingerReleaseThreshold: 250,
            longTapThreshold: 500,
            doubleTapThreshold: 200,
            swipe: null,
            swipeLeft: null,
            swipeRight: null,
            swipeUp: null,
            swipeDown: null,
            swipeStatus: null,
            pinchIn: null,
            pinchOut: null,
            pinchStatus: null,
            click: null,
            tap: null,
            doubleTap: null,
            longTap: null,
            hold: null,
            triggerOnTouchEnd: !0,
            triggerOnTouchLeave: !1,
            allowPageScroll: 'auto',
            fallbackToMouseEvents: !0,
            excludedElements: '.noSwipe',
            preventDefaultEvents: !0
        };
    $.fn.swipe = function (method) {
        var $this = $(this), plugin = $this.data(PLUGIN_NS);
        if (plugin && lS(0, 68) == typeof method) {
            if (plugin[method])
                return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
            (() => {
                const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            $.error(lS(0, 69) + method + lS(0, 70));
                        }
                    }
                });
                const __exports = __callInstance1.exports;
                return __exports.data();
            })();
        } else if (plugin && lS(0, 71) == typeof method)
            (() => {
                const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            plugin.option.apply(plugin, arguments);
                        }
                    }
                });
                const __exports = __callInstance0.exports;
                return __exports.data();
            })();
        else if (!(plugin || lS(0, 72) != typeof method && method))
            return init.apply(this, arguments);
        return $this;
    }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    }, $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    }, $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    }, $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        FOUR: 4,
        FIVE: 5,
        ALL: ALL_FINGERS
    };
});</script>
</body>
</html>
