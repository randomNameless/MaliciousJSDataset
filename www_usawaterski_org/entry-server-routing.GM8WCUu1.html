<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>entry-server-routing.GM8WCUu1.html</title>
</head>
<body>

<script>
const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/entries/pages_catch-all.Gg1t_S6m.js","assets/chunks/chunk-DYV2SmuH.js","assets/chunks/chunk-D-_ZChfU.js","assets/static/-nl-35769791.D8ovJrgK.css","assets/chunks/chunk-DjuQUEJZ.js","assets/static/components_Notifications_NotificationBar.CKBiFYBa.css","assets/chunks/chunk-C6WsoVAM.js","assets/static/components_Navigation_Sidebar_drawer-header.BJVbE99F.css","assets/chunks/chunk-Dnbbb0B9.js","assets/static/components_Carousel_carousel.B7juL1K2.css","assets/static/styles_globals-d1531aed.jR8RehMI.css","assets/static/styles_photoCredit-3ff226bf.C0UpKzNW.css"])))=>i.map(i=>d[i]);
import{_ as __vitePreload}from"../chunks/chunk-DYV2SmuH.js";function unique(arr){return Array.from(new Set(arr))}const PROJECT_VERSION="0.4.195",projectInfo={projectName:"Vike",projectVersion:PROJECT_VERSION},projectKey=`_${projectInfo.projectName.toLowerCase()}`;function getGlobalObject(key,defaultValue){const globalObjects=getGlobalObjects();return globalObjects[key]=globalObjects[key]||defaultValue}function getGlobalObjects(){return globalThis[projectKey]=globalThis[projectKey]||{}}const pc=new Proxy({},{get:(_,p)=>s=>p==="code"?`\`${s}\``:p==="string"?`'${s}'`:s}),globalObject$5=getGlobalObject("assertSingleInstance.ts",{instances:[],alreadyLogged:new Set}),clientRuntimesClonflict="Client runtime of both Server Routing and Client Routing loaded https://vike.dev/client-runtimes-conflict",clientNotSingleInstance="Client runtime loaded twice https://vike.dev/client-runtime-duplicated";function assertSingleInstance(){{const versions=unique(globalObject$5.instances);assertUsage$1(versions.length<=1,`vike@${pc.bold(versions[0])} and vike@${pc.bold(versions[1])} loaded but only one version should be loaded`)}globalObject$5.checkSingleInstance&&globalObject$5.instances.length>1&&assertWarning$1(!1,clientNotSingleInstance,{onlyOnce:!0,showStackTrace:!0})}function assertSingleInstance_onClientEntryServerRouting(isProduction){assertWarning$1(globalObject$5.isClientRouting!==!0,clientRuntimesClonflict,{onlyOnce:!0,showStackTrace:!0}),assertWarning$1(globalObject$5.isClientRouting===void 0,clientNotSingleInstance,{onlyOnce:!0,showStackTrace:!0}),globalObject$5.isClientRouting=!1,globalObject$5.checkSingleInstance=!0,assertSingleInstance()}function assertSingleInstance_onAssertModuleLoad(){globalObject$5.instances.push(projectInfo.projectVersion),assertSingleInstance()}function assertUsage$1(condition,errorMessage){if(condition)return;const errMsg=`[vike][Wrong Usage] ${errorMessage}`;throw new Error(errMsg)}function assertWarning$1(condition,errorMessage,{onlyOnce,showStackTrace}){if(condition)return;const msg=`[vike][Warning] ${errorMessage}`;if(onlyOnce){const{alreadyLogged}=globalObject$5,key=onlyOnce===!0?msg:onlyOnce;if(alreadyLogged.has(key))return;alreadyLogged.add(key)}console.warn(showStackTrace?new Error(msg):msg)}function isNodeJS(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function createErrorWithCleanStackTrace(errorMessage,numberOfStackTraceLinesToRemove2){const err=new Error(errorMessage);return isNodeJS()&&(err.stack=clean(err.stack,numberOfStackTraceLinesToRemove2)),err}function clean(errStack,numberOfStackTraceLinesToRemove2){if(!errStack)return errStack;const stackLines=splitByLine(errStack);let linesRemoved=0;return stackLines.filter(line=>line.includes(" (internal/")||line.includes(" (node:internal")?!1:linesRemoved<numberOfStackTraceLinesToRemove2&&isStackTraceLine(line)?(linesRemoved++,!1):!0).join(`
`)}function isStackTraceLine(line){return line.startsWith("    at ")}function splitByLine(str){return str.split(/\r?\n/)}function isObject(value){return typeof value=="object"&&value!==null}const globalObject$4=getGlobalObject("utils/assert.ts",{alreadyLogged:new Set,logger(msg,logType){logType==="info"?console.log(msg):console.warn(msg)},showStackTraceList:new WeakSet});assertSingleInstance_onAssertModuleLoad();const projectTag="[vike]",projectTagWithVersion=`[vike@${projectInfo.projectVersion}]`,numberOfStackTraceLinesToRemove=2;function assert(condition,debugInfo){var _a;if(condition)return;const debugStr=(()=>{if(!debugInfo)return null;const debugInfoSerialized=typeof debugInfo=="string"?debugInfo:JSON.stringify(debugInfo);return pc.dim(`Debug info (for Vike maintainers; you can ignore this): ${debugInfoSerialized}`)})();let errMsg=[`You stumbled upon a Vike bug. Go to ${pc.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,debugStr].filter(Boolean).join(" ");errMsg=addWhitespace(errMsg),errMsg=addPrefixAssertType(errMsg,"Bug"),errMsg=addPrefixProjctName(errMsg,!0);const internalError=createErrorWithCleanStackTrace(errMsg,numberOfStackTraceLinesToRemove);throw(_a=globalObject$4.onBeforeLog)==null||_a.call(globalObject$4),internalError}function assertUsage(condition,errMsg,{showStackTrace}={}){var _a;if(condition)return;showStackTrace=showStackTrace||globalObject$4.alwaysShowStackTrace,errMsg=addWhitespace(errMsg),errMsg=addPrefixAssertType(errMsg,"Wrong Usage"),errMsg=addPrefixProjctName(errMsg);const usageError=createErrorWithCleanStackTrace(errMsg,numberOfStackTraceLinesToRemove);throw showStackTrace&&globalObject$4.showStackTraceList.add(usageError),(_a=globalObject$4.onBeforeLog)==null||_a.call(globalObject$4),usageError}function getProjectError(errMsg){return errMsg=addWhitespace(errMsg),errMsg=addPrefixAssertType(errMsg,"Error"),errMsg=addPrefixProjctName(errMsg),createErrorWithCleanStackTrace(errMsg,numberOfStackTraceLinesToRemove)}function assertWarning(condition,msg,{onlyOnce,showStackTrace}){var _a;if(!condition){if(showStackTrace=showStackTrace||globalObject$4.alwaysShowStackTrace,msg=addWhitespace(msg),msg=addPrefixAssertType(msg,"Warning"),msg=addPrefixProjctName(msg),onlyOnce){const{alreadyLogged}=globalObject$4,key=onlyOnce===!0?msg:onlyOnce;if(alreadyLogged.has(key))return;alreadyLogged.add(key)}if((_a=globalObject$4.onBeforeLog)==null||_a.call(globalObject$4),showStackTrace){const err=createErrorWithCleanStackTrace(msg,numberOfStackTraceLinesToRemove);globalObject$4.showStackTraceList.add(err),globalObject$4.logger(err,"warn")}else globalObject$4.logger(msg,"warn")}}function addPrefixAssertType(msg,tag){let prefix=`[${tag}]`;const color=tag==="Warning"?"yellow":"red";return prefix=pc.bold(pc[color](prefix)),`${prefix}${msg}`}function addWhitespace(msg){return msg.startsWith("[")?msg:` ${msg}`}function addPrefixProjctName(msg,showProjectVersion=!1){return`${showProjectVersion?projectTagWithVersion:projectTag}${msg}`}function isBrowser(){return typeof window<"u"&&typeof window.scrollY=="number"}const state=getGlobalObject("utils/assertRouterType.ts",{});function assertServerRouting(){assertNoContradiction(state.isClientRouting!==!0),state.isClientRouting=!1}function assertNoContradiction(noContradiction){assertUsage(isBrowser(),`${pc.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),assertWarning(noContradiction,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function slice(thing,from,to){return typeof thing=="string"?sliceArray(thing.split(""),from,to).join(""):sliceArray(thing,from,to)}function sliceArray(list,from,to){const listSlice=[];let start=from;assert(start>=0&&start<=list.length);let end=list.length+to;for(assert(end>=0&&end<=list.length);!(start===end||(start===list.length&&(start=0),start===end));){const el=list[start];assert(el!==void 0),listSlice.push(el),start++}return listSlice}function parseUrl(url,baseServer){assert(isUrl(url),url),assert(baseServer.startsWith("/"));const[urlWithoutHash,...hashList]=url.split("#");assert(urlWithoutHash!==void 0);const hashOriginal=["",...hashList].join("#")||null;assert(hashOriginal===null||hashOriginal.startsWith("#"));const hash=hashOriginal===null?"":decodeSafe(hashOriginal.slice(1)),[urlWithoutHashNorSearch,...searchList]=urlWithoutHash.split("?");assert(urlWithoutHashNorSearch!==void 0);const searchOriginal=["",...searchList].join("?")||null;assert(searchOriginal===null||searchOriginal.startsWith("?"));const search={},searchAll={};Array.from(new URLSearchParams(searchOriginal||"")).forEach(([key,val])=>{search[key]=val,searchAll[key]=[...searchAll.hasOwnProperty(key)?searchAll[key]:[],val]});let{protocol,origin,pathnameAbsoluteWithBase}=getPathnameAbsoluteWithBase(urlWithoutHashNorSearch,baseServer);const pathnameOriginal=urlWithoutHashNorSearch.slice((origin||"").length);assertUrlComponents(url,origin,pathnameOriginal,searchOriginal,hashOriginal);let{pathname,hasBaseServer}=removeBaseServer(pathnameAbsoluteWithBase,baseServer);const href=createUrlFromComponents(origin,pathname,searchOriginal,hashOriginal),host=origin?origin.slice(protocol.length):null,{hostname,port}=parseHost(host,url);return pathname=decodePathname(pathname),assert(pathname.startsWith("/")),{href,protocol,hostname,port,origin,pathname,pathnameOriginal,hasBaseServer,search,searchAll,searchOriginal,hash,hashOriginal}}function decodeSafe(urlComponent){try{return decodeURIComponent(urlComponent)}catch{}try{return decodeURI(urlComponent)}catch{}return urlComponent}function decodePathname(urlPathname){return urlPathname=urlPathname.replace(/\s+$/,""),urlPathname=urlPathname.split("/").map(dir=>decodeSafe(dir).split("/").join("%2F")).join("/"),urlPathname}function getPathnameAbsoluteWithBase(url,baseServer){var _a;assert(!url.includes("?")&&!url.includes("#"));{const{protocol,origin,pathname}=parseOrigin(url);if(origin)return{protocol,origin,pathnameAbsoluteWithBase:pathname};assert(pathname===url)}if(url.startsWith("/"))return{protocol:null,origin:null,pathnameAbsoluteWithBase:url};{const baseURI=typeof window<"u"?(_a=window==null?void 0:window.document)==null?void 0:_a.baseURI:void 0;let base;return baseURI?base=parseOrigin(baseURI.split("?")[0]).pathname:base=baseServer,{protocol:null,origin:null,pathnameAbsoluteWithBase:resolveUrlPathnameRelative(url,base)}}}function parseOrigin(url){if(isUrlWithProtocol(url)){const{protocol,uriWithoutProtocol}=parseProtocol(url);assert(protocol);const[host,...rest]=uriWithoutProtocol.split("/"),origin=protocol+host;return{pathname:"/"+rest.join("/"),origin,protocol}}else return{pathname:url,origin:null,protocol:null}}function parseHost(host,url){const ret={hostname:null,port:null};if(!host)return ret;const parts=host.split(":");if(parts.length>1){const port=parseInt(parts.pop(),10);assert(port||port===0,url),ret.port=port}return ret.hostname=parts.join(":"),ret}function parseProtocol(uri){const SEP=":",[before,...after]=uri.split(SEP);if(after.length===0||!/^[a-z][a-z0-9\+\-]*$/i.test(before))return{protocol:null,uriWithoutProtocol:uri};let protocol=before+SEP,uriWithoutProtocol=after.join(SEP);const SEP2="//";return uriWithoutProtocol.startsWith(SEP2)&&(protocol=protocol+SEP2,uriWithoutProtocol=uriWithoutProtocol.slice(SEP2.length)),{protocol,uriWithoutProtocol}}function isUrlProtocol(protocol){return["ipfs://","ipns://"].includes(protocol)?!1:protocol.endsWith("://")}function resolveUrlPathnameRelative(pathnameRelative,base){const stack=base.split("/"),parts=pathnameRelative.split("/");let baseRestoreTrailingSlash=base.endsWith("/");pathnameRelative.startsWith(".")&&stack.pop();for(const i in parts){const p=parts[i];p==""&&i==="0"||p!="."&&(p==".."?stack.pop():(baseRestoreTrailingSlash=!1,stack.push(p)))}let pathnameAbsolute=stack.join("/");return baseRestoreTrailingSlash&&!pathnameAbsolute.endsWith("/")&&(pathnameAbsolute+="/"),pathnameAbsolute.startsWith("/")||(pathnameAbsolute="/"+pathnameAbsolute),pathnameAbsolute}function removeBaseServer(pathnameAbsoluteWithBase,baseServer){return assert(pathnameAbsoluteWithBase.startsWith("/")),assert(isBaseServer(baseServer)),assert(pathnameAbsoluteWithBase.startsWith("/")),assert(baseServer.startsWith("/")),{pathname:pathnameAbsoluteWithBase,hasBaseServer:!0}}function isBaseServer(baseServer){return baseServer.startsWith("/")}function assertUrlComponents(url,origin,pathnameOriginal,searchOriginal,hashOriginal){const urlRecreated=createUrlFromComponents(origin,pathnameOriginal,searchOriginal,hashOriginal);assert(url===urlRecreated)}function createUrlFromComponents(origin,pathname,search,hash){return`${origin||""}${pathname}${search||""}${hash||""}`}function isUrl(url){return isUrlWithProtocol(url)||url.startsWith("/")||isUrlPathnameRelative(url)}function isUrlPathnameRelative(url){return[".","?","#"].some(c=>url.startsWith(c))||url===""}function isUrlWithProtocol(url){const{protocol}=parseProtocol(url);return!!protocol&&isUrlProtocol(protocol)}function objectAssign(obj,objAddendum){objAddendum&&(assert(!("_isPageContextObject"in objAddendum)),Object.defineProperties(obj,Object.getOwnPropertyDescriptors(objAddendum)))}function isCallable(thing){return thing instanceof Function||typeof thing=="function"}function makeFirst(getValue){return(element1,element2)=>{const val1=getValue(element1),val2=getValue(element2);if(assert([!0,!1,null].includes(val1)),assert([!0,!1,null].includes(val2)),val1===val2)return 0;if(val1===!0||val2===!1)return-1;if(val2===!0||val1===!1)return 1;assert(!1)}}function makeLast(getValue){return makeFirst(element=>{const val=getValue(element);return val===null?null:!val})}function isArray(value){return Array.isArray(value)}function isArrayOfStrings(val){return isArray(val)&&val.every(v=>typeof v=="string")}function isObjectOfStrings(val){return isObject(val)&&Object.values(val).every(v=>typeof v=="string")}function hasProp(obj,prop,type){if(!isObject(obj))return!1;if(!(prop in obj))return type==="undefined";if(type===void 0)return!0;const propValue=obj[prop];return type==="undefined"?propValue===void 0:type==="array"?isArray(propValue):type==="object"?isObject(propValue):type==="string[]"?isArrayOfStrings(propValue):type==="string{}"?isObjectOfStrings(propValue):type==="function"?isCallable(propValue):isArray(type)?typeof propValue=="string"&&type.includes(propValue):type==="null"?propValue===null:type==="true"?propValue===!0:type==="false"?propValue===!1:typeof propValue===type}function compareString(str1,str2){return str1.toLowerCase()<str2.toLowerCase()?-1:str1.toLowerCase()>str2.toLowerCase()?1:0}const isNotNullish=p=>p!=null;function assertPosixPath(path){const errMsg=msg=>`Not a posix path: ${msg}`;assert(path!==null,errMsg("null")),assert(typeof path=="string",errMsg(`typeof path === ${JSON.stringify(typeof path)}`)),assert(path!=="",errMsg("(empty string)")),assert(path),assert(!path.includes("\\"),errMsg(path))}const enforceTrue=["clientRouting"];function assertExportValues(pageFile){enforceTrue.forEach(exportName=>{if(assert(pageFile.fileExports),!(exportName in pageFile.fileExports))return;const explainer=`The value of \`${exportName}\` is only allowed to be \`true\`.`;assertUsage(pageFile.fileExports[exportName]!==!1,`${pageFile.filePath} has \`export { ${exportName} }\` with the value \`false\` which is prohibited: remove \`export { ${exportName} }\` instead. (${explainer})`),assertUsage(pageFile.fileExports[exportName]===!0,`${pageFile.filePath} has \`export { ${exportName} }\` with a forbidden value. ${explainer}`)})}const forbiddenDefaultExports=["render","clientRouting","prerender","doNotPrerender"];function assertDefaultExports(defaultExportName,filePath){assertUsage(!forbiddenDefaultExports.includes(defaultExportName),`${filePath} has \`export default { ${defaultExportName} }\` which is prohibited, use \`export { ${defaultExportName} }\` instead.`)}function determinePageIdOld(filePath){const pageSuffix=".page.",pageId=slice(filePath.split(pageSuffix),0,-1).join(pageSuffix);return assert(!pageId.includes("\\")),pageId}function assertPageFilePath(filePath){assertPosixPath(filePath)}function isErrorPageId(pageId,_isV1Design){return assert(!pageId.includes("\\")),pageId.includes("/_error")}function isErrorPage(pageId,pageConfigs){if(pageConfigs.length>0){const pageConfig=pageConfigs.find(p=>p.pageId===pageId);return assert(pageConfig),!!pageConfig.isErrorPage}else return isErrorPageId(pageId)}const extJavaScript=["js","ts","cjs","cts","mjs","mts"],extJsx=["jsx","tsx","cjsx","ctsx","mjsx","mtsx"],extTemplates=["vue","svelte","marko","md","mdx"],scriptFileExtensionList=[...extJavaScript,...extJsx,...extTemplates];function isScriptFile(filePath){const yes=scriptFileExtensionList.some(ext=>filePath.endsWith("."+ext));return isJavaScriptFile(filePath)&&assert(yes),yes}function isJavaScriptFile(filePath){const yes1=/\.(c|m)?(j|t)s$/.test(filePath),yes2=extJavaScript.some(ext=>filePath.endsWith("."+ext));return assert(yes1===yes2),yes1}function isTemplateFile(filePath){return extTemplates.some(ext=>filePath.endsWith("."+ext))}const fileTypes=[".page",".page.server",".page.route",".page.client",".css"];function determineFileType(filePath){if(assertPosixPath(filePath),filePath.endsWith(".css"))return".css";assert(isScriptFile(filePath),filePath);const parts=filePath.split("/").slice(-1)[0].split("."),suffix1=parts.slice(-3)[0],suffix2=parts.slice(-2)[0];if(suffix2==="page")return".page";if(assert(suffix1==="page",filePath),suffix2==="server")return".page.server";if(suffix2==="client")return".page.client";if(suffix2==="route")return".page.route";assert(!1,filePath)}function getPageFileObject(filePath){const isRelevant=pageId=>pageFile.pageId===pageId||pageFile.isDefaultPageFile&&(isRendererFilePath(pageFile.filePath)||isAncestorDefaultPage(pageId,pageFile.filePath)),fileType=determineFileType(filePath),pageFile={filePath,fileType,isEnv:env=>{if(assert(fileType!==".page.route"),env==="CLIENT_ONLY")return fileType===".page.client"||fileType===".css";if(env==="SERVER_ONLY")return fileType===".page.server";if(env==="CLIENT_AND_SERVER")return fileType===".page";assert(!1)},isRelevant,isDefaultPageFile:isDefaultFilePath(filePath),isRendererPageFile:fileType!==".css"&&isDefaultFilePath(filePath)&&isRendererFilePath(filePath),isErrorPageFile:isErrorPageId(filePath),pageId:determinePageIdOld(filePath)};return pageFile}function isDefaultFilePath(filePath){return assertPageFilePath(filePath),isErrorPageId(filePath)?!1:filePath.includes("/_default")}function isRendererFilePath(filePath){return assertPageFilePath(filePath),filePath.includes("/renderer/")}function isAncestorDefaultPage(pageId,defaultPageFilePath){assertPageFilePath(pageId),assertPageFilePath(defaultPageFilePath),assert(!pageId.endsWith("/")),assert(!defaultPageFilePath.endsWith("/")),assert(isDefaultFilePath(defaultPageFilePath));const defaultPageDir=slice(defaultPageFilePath.split("/"),0,-1).filter(filePathSegment=>filePathSegment!=="_default").join("/");return pageId.startsWith(defaultPageDir)}function getExportPath(fileExportPathToShowToUser,configName){if(!fileExportPathToShowToUser)return null;let[exportName,...exportObjectPath]=fileExportPathToShowToUser;if(!exportName||exportObjectPath.length===0&&["*","default",configName].includes(exportName))return null;assert(exportName!=="*");let prefix="",suffix="";return exportName==="default"?prefix="export default":(prefix="export",exportObjectPath=[exportName,...exportObjectPath]),exportObjectPath.forEach(prop=>{prefix=`${prefix} { ${prop}`,suffix=` }${suffix}`}),prefix+suffix}function getConfigDefinedAt(sentenceBegin,configName,definedAtData){return`${begin(sentenceBegin,configName)} at ${getDefinedAtString(definedAtData,configName)}`}function getConfigDefinedAtOptional(sentenceBegin,configName,definedAtData){return definedAtData?`${begin(sentenceBegin,configName)} at ${getDefinedAtString(definedAtData,configName)}`:`${begin(sentenceBegin,configName)} internally`}function begin(sentenceBegin,configName){return`${sentenceBegin} ${pc.cyan(configName)} defined`}function getDefinedAtString(definedAtData,configName){let files;return isArray(definedAtData)?files=definedAtData:files=[definedAtData],assert(files.length>=1),files.map(source=>{const{filePathToShowToUser,fileExportPathToShowToUser}=source;let s=filePathToShowToUser;const exportPath=getExportPath(fileExportPathToShowToUser,configName);return exportPath&&(s=`${s} > ${pc.cyan(exportPath)}`),s}).join(" / ")}const types=[{is:val=>val===void 0,match:str=>str==="!undefined",serialize:()=>"!undefined",deserialize:()=>{}},{is:val=>val===1/0,match:str=>str==="!Infinity",serialize:()=>"!Infinity",deserialize:()=>1/0},{is:val=>val===-1/0,match:str=>str==="!-Infinity",serialize:()=>"!-Infinity",deserialize:()=>-1/0},{is:val=>typeof val=="number"&&isNaN(val),match:str=>str==="!NaN",serialize:()=>"!NaN",deserialize:()=>NaN},{is:val=>val instanceof Date,match:str=>str.startsWith("!Date:"),serialize:val=>"!Date:"+val.toISOString(),deserialize:str=>new Date(str.slice(6))},{is:val=>typeof val=="bigint",match:str=>str.startsWith("!BigInt:"),serialize:val=>"!BigInt:"+val.toString(),deserialize:str=>{if(typeof BigInt>"u")throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");return BigInt(str.slice(8))}},{is:val=>val instanceof RegExp,match:str=>str.startsWith("!RegExp:"),serialize:val=>"!RegExp:"+val.toString(),deserialize:str=>{str=str.slice(8);const args=str.match(/\/(.*)\/(.*)?/),pattern=args[1],flags=args[2];return new RegExp(pattern,flags)}},{is:val=>val instanceof Map,match:str=>str.startsWith("!Map:"),serialize:(val,serializer)=>"!Map:"+serializer(Array.from(val.entries())),deserialize:(str,deserializer)=>new Map(deserializer(str.slice(5)))},{is:val=>val instanceof Set,match:str=>str.startsWith("!Set:"),serialize:(val,serializer)=>"!Set:"+serializer(Array.from(val.values())),deserialize:(str,deserializer)=>new Set(deserializer(str.slice(5)))},{is:val=>typeof val=="string"&&val.startsWith("!"),match:str=>str.startsWith("!"),serialize:val=>"!"+val,deserialize:str=>str.slice(1)}];function parse(str){const value=JSON.parse(str);return parseTransform(value)}function parseTransform(value){return typeof value=="string"?reviver(value):(typeof value=="object"&&value!==null&&Object.entries(value).forEach(([key,val])=>{value[key]=parseTransform(val)}),value)}function reviver(value){for(const{match,deserialize}of types)if(match(value))return deserialize(value,parse);return value}const EXPORTS_IGNORE=["$$registrations","_rerender_only"],TOLERATE_SIDE_EXPORTS=[".md",".mdx"];function assertPlusFileExport(fileExports,filePathToShowToUser,configName){const exportNames=Object.keys(fileExports).filter(exportName=>!EXPORTS_IGNORE.includes(exportName)),isValid=exportName=>exportName==="default"||exportName===configName,exportNamesValid=exportNames.filter(isValid),exportNamesInvalid=exportNames.filter(e=>!isValid(e));if(exportNamesValid.length===1&&exportNamesInvalid.length===0)return;const exportDefault=pc.code("export default"),exportNamed=pc.code(`export { ${configName} }`);assert(exportNamesValid.length<=2),exportNamesValid.length===0&&assertUsage(!1,`${filePathToShowToUser} should have a ${exportNamed} or ${exportDefault}`),exportNamesValid.length===2&&assertWarning(!1,`${filePathToShowToUser} is ambiguous: remove ${exportDefault} or ${exportNamed}`,{onlyOnce:!0}),TOLERATE_SIDE_EXPORTS.some(ext=>filePathToShowToUser.endsWith(ext))||exportNamesInvalid.forEach(exportInvalid=>{assertWarning(!1,`${filePathToShowToUser} unexpected ${pc.cyan(`export { ${exportInvalid} }`)}`,{onlyOnce:!0})})}function parseConfigValuesSerialized(configValuesSerialized){return parseConfigValuesSerialized_tmp(configValuesSerialized)}function parsePageConfigs(pageConfigsSerialized2,pageConfigGlobalSerialized2){const pageConfigs=pageConfigsSerialized2.map(pageConfigSerialized=>{const configValues=parseConfigValuesSerialized(pageConfigSerialized.configValuesSerialized),{pageId,isErrorPage:isErrorPage2,routeFilesystem,loadConfigValuesAll}=pageConfigSerialized;return assertRouteConfigValue(configValues),{pageId,isErrorPage:isErrorPage2,routeFilesystem,configValues,loadConfigValuesAll}}),pageConfigGlobal={configValues:{}};{const configValues=parseConfigValuesSerialized(pageConfigGlobalSerialized2.configValuesSerialized);Object.assign(pageConfigGlobal.configValues,configValues)}return{pageConfigs,pageConfigGlobal}}function assertRouteConfigValue(configValues){const configName="route",configValue=configValues[configName];if(!configValue)return;const{value,definedAtData}=configValue,configValueType=typeof value;assert(definedAtData);const configDefinedAt=getConfigDefinedAt("Config",configName,definedAtData);assertUsage(configValueType==="string"||isCallable(value),`${configDefinedAt} has an invalid type '${configValueType}': it should be a string or a function instead, see https://vike.dev/route`)}function parseConfigValuesSerialized_tmp(configValuesSerialized){const configValues={};return Object.entries(configValuesSerialized).forEach(([configName,configValueSeriliazed])=>{let configValue;if(configValueSeriliazed.type==="cumulative"){const{valueSerialized,...common}=configValueSeriliazed;configValue={value:valueSerialized.map((valueSerializedElement,i)=>{const{value:value2,sideExports}=parseValueSerialized(valueSerializedElement,configName,()=>{const definedAtFile=configValueSeriliazed.definedAtData[i];return assert(definedAtFile),definedAtFile});return addSideExports(sideExports),value2}),...common}}else{const{valueSerialized,...common}=configValueSeriliazed,{value,sideExports}=parseValueSerialized(valueSerialized,configName,()=>(assert(configValueSeriliazed.type!=="computed"),configValueSeriliazed.definedAtData));addSideExports(sideExports),configValue={value,...common}}configValues[configName]=configValue}),configValues;function addSideExports(sideExports){sideExports.forEach(sideExport=>{const{configName,configValue}=sideExport;configValues[configName]||(configValues[configName]=configValue)})}}function parseValueSerialized(valueSerialized,configName,getDefinedAtFile){if(valueSerialized.type==="js-serialized"){let{value}=valueSerialized;return value=parseTransform(value),{value,sideExports:[]}}if(valueSerialized.type==="pointer-import"){const{value}=valueSerialized;return{value,sideExports:[]}}if(valueSerialized.type==="plus-file"){const definedAtFile=getDefinedAtFile(),{exportValues}=valueSerialized;assertPlusFileExport(exportValues,definedAtFile.filePathToShowToUser,configName);let value,valueWasFound=!1;const sideExports=[];return Object.entries(exportValues).forEach(([exportName,exportValue])=>{exportName!=="default"&&exportName!==configName?sideExports.push({configName:exportName,configValue:{type:"standard",value:exportValue,definedAtData:{filePathToShowToUser:definedAtFile.filePathToShowToUser,fileExportPathToShowToUser:[exportName]}}}):(value=exportValue,assert(!valueWasFound),valueWasFound=!0)}),assert(valueWasFound),{value,sideExports}}assert(!1)}function parseGlobResults(pageFilesExports2){assert(hasProp(pageFilesExports2,"pageFilesLazy","object")),assert(hasProp(pageFilesExports2,"pageFilesEager","object")),assert(hasProp(pageFilesExports2,"pageFilesExportNamesLazy","object")),assert(hasProp(pageFilesExports2,"pageFilesExportNamesEager","object")),assert(hasProp(pageFilesExports2.pageFilesLazy,".page")),assert(hasProp(pageFilesExports2.pageFilesLazy,".page.client")||hasProp(pageFilesExports2.pageFilesLazy,".page.server")),assert(hasProp(pageFilesExports2,"pageFilesList","string[]")),assert(hasProp(pageFilesExports2,"pageConfigsSerialized")),assert(hasProp(pageFilesExports2,"pageConfigGlobalSerialized"));const{pageConfigsSerialized:pageConfigsSerialized2,pageConfigGlobalSerialized:pageConfigGlobalSerialized2}=pageFilesExports2;assertPageConfigsSerialized(pageConfigsSerialized2),assertPageConfigGlobalSerialized(pageConfigGlobalSerialized2);const{pageConfigs,pageConfigGlobal}=parsePageConfigs(pageConfigsSerialized2,pageConfigGlobalSerialized2),pageFilesMap={};parseGlobResult(pageFilesExports2.pageFilesLazy).forEach(({filePath,pageFile,globValue})=>{pageFile=pageFilesMap[filePath]=pageFilesMap[filePath]??pageFile;const loadModule=globValue;assertLoadModule(loadModule),pageFile.loadFile=async()=>{"fileExports"in pageFile||(pageFile.fileExports=await loadModule(),assertExportValues(pageFile))}}),parseGlobResult(pageFilesExports2.pageFilesExportNamesLazy).forEach(({filePath,pageFile,globValue})=>{pageFile=pageFilesMap[filePath]=pageFilesMap[filePath]??pageFile;const loadModule=globValue;assertLoadModule(loadModule),pageFile.loadExportNames=async()=>{if(!("exportNames"in pageFile)){const moduleExports=await loadModule();assert(hasProp(moduleExports,"exportNames","string[]"),pageFile.filePath),pageFile.exportNames=moduleExports.exportNames}}}),parseGlobResult(pageFilesExports2.pageFilesEager).forEach(({filePath,pageFile,globValue})=>{pageFile=pageFilesMap[filePath]=pageFilesMap[filePath]??pageFile;const moduleExports=globValue;assert(isObject(moduleExports)),pageFile.fileExports=moduleExports}),parseGlobResult(pageFilesExports2.pageFilesExportNamesEager).forEach(({filePath,pageFile,globValue})=>{pageFile=pageFilesMap[filePath]=pageFilesMap[filePath]??pageFile;const moduleExports=globValue;assert(isObject(moduleExports)),assert(hasProp(moduleExports,"exportNames","string[]"),pageFile.filePath),pageFile.exportNames=moduleExports.exportNames}),pageFilesExports2.pageFilesList.forEach(filePath=>{pageFilesMap[filePath]=pageFilesMap[filePath]??getPageFileObject(filePath)});const pageFiles=Object.values(pageFilesMap);return pageFiles.forEach(({filePath})=>{assert(!filePath.includes("\\"))}),{pageFiles,pageConfigs,pageConfigGlobal}}function parseGlobResult(globObject){const ret=[];return Object.entries(globObject).forEach(([fileType,globFiles])=>{assert(fileTypes.includes(fileType)),assert(isObject(globFiles)),Object.entries(globFiles).forEach(([filePath,globValue])=>{const pageFile=getPageFileObject(filePath);assert(pageFile.fileType===fileType),ret.push({filePath,pageFile,globValue})})}),ret}function assertLoadModule(globValue){assert(isCallable(globValue))}function assertPageConfigsSerialized(pageConfigsSerialized2){assert(isArray(pageConfigsSerialized2)),pageConfigsSerialized2.forEach(pageConfigSerialized=>{assert(isObject(pageConfigSerialized)),assert(hasProp(pageConfigSerialized,"pageId","string")),assert(hasProp(pageConfigSerialized,"routeFilesystem")),assert(hasProp(pageConfigSerialized,"configValuesSerialized"))})}function assertPageConfigGlobalSerialized(pageConfigGlobalSerialized2){assert(hasProp(pageConfigGlobalSerialized2,"configValuesSerialized"))}const globalObject$3=getGlobalObject("setPageFiles.ts",{});function setPageFiles(pageFilesExports2){const{pageFiles,pageConfigs,pageConfigGlobal}=parseGlobResults(pageFilesExports2);globalObject$3.pageFilesAll=pageFiles,globalObject$3.pageConfigs=pageConfigs,globalObject$3.pageConfigGlobal=pageConfigGlobal}async function getPageFilesAll(isClientSide,isProduction){assert(!globalObject$3.pageFilesGetter),assert(isProduction===void 0);const{pageFilesAll,pageConfigs,pageConfigGlobal}=globalObject$3;assert(pageFilesAll&&pageConfigs&&pageConfigGlobal);const allPageIds=getAllPageIds(pageFilesAll,pageConfigs);return{pageFilesAll,allPageIds,pageConfigs,pageConfigGlobal}}function getAllPageIds(allPageFiles,pageConfigs){const fileIds=allPageFiles.filter(({isDefaultPageFile})=>!isDefaultPageFile).map(({pageId})=>pageId),allPageIds=unique(fileIds),allPageIds2=pageConfigs.map(p=>p.pageId);return[...allPageIds,...allPageIds2]}function getPageFilesClientSide(pageFilesAll,pageId){return determine(pageFilesAll,pageId,!0)}function determine(pageFilesAll,pageId,envIsClient){const env="CLIENT_ONLY",pageFilesRelevant=pageFilesAll.filter(p=>p.isRelevant(pageId)&&p.fileType!==".page.route").sort(getPageFilesSorter(envIsClient,pageId)),getPageIdFile=iso=>{const files=pageFilesRelevant.filter(p=>p.pageId===pageId&&p.isEnv(iso?"CLIENT_AND_SERVER":env));assertUsage(files.length<=1,`Merge the following files into a single file: ${files.map(p=>p.filePath).join(" ")}`);const pageIdFile=files[0];return assert(pageIdFile===void 0||!pageIdFile.isDefaultPageFile),pageIdFile},pageIdFileEnv=getPageIdFile(!1),pageIdFileIso=getPageIdFile(!0),getRendererFile=iso=>pageFilesRelevant.filter(p=>p.isRendererPageFile&&p.isEnv(iso?"CLIENT_AND_SERVER":env))[0],rendererFileEnv=getRendererFile(!1),rendererFileIso=getRendererFile(!0),defaultFilesNonRenderer=pageFilesRelevant.filter(p=>p.isDefaultPageFile&&!p.isRendererPageFile&&(p.isEnv(env)||p.isEnv("CLIENT_AND_SERVER")));return[pageIdFileEnv,pageIdFileIso,...defaultFilesNonRenderer,rendererFileEnv,rendererFileIso].filter(isNotNullish)}function getPageFilesSorter(envIsClient,pageId){const env="CLIENT_ONLY";return(e1,e2)=>{if(!e1.isDefaultPageFile&&e2.isDefaultPageFile)return-1;if(!e2.isDefaultPageFile&&e1.isDefaultPageFile)return 1;{const e1_isRenderer=e1.isRendererPageFile,e2_isRenderer=e2.isRendererPageFile;if(!e1_isRenderer&&e2_isRenderer)return-1;if(!e2_isRenderer&&e1_isRenderer)return 1;assert(e1_isRenderer===e2_isRenderer)}{const e1_distance=getPathDistance(pageId,e1.filePath),e2_distance=getPathDistance(pageId,e2.filePath);if(e1_distance<e2_distance)return-1;if(e2_distance<e1_distance)return 1;assert(e1_distance===e2_distance)}{if(e1.isEnv(env)&&e2.isEnv("CLIENT_AND_SERVER"))return-1;if(e2.isEnv(env)&&e1.isEnv("CLIENT_AND_SERVER"))return 1}return 0}}function getPathDistance(pathA,pathB){assertPageFilePath(pathA),assertPageFilePath(pathB);let idx=0;for(;idx<pathA.length&&idx<pathB.length&&pathA[idx]===pathB[idx];idx++);const pathAWithoutCommon=pathA.slice(idx),pathBWithoutCommon=pathB.slice(idx),distanceA=pathAWithoutCommon.split("/").length,distanceB=pathBWithoutCommon.split("/").length;return distanceA+distanceB}function getConfigValueFilePathToShowToUser(definedAtData){if(!definedAtData||isArray(definedAtData))return null;const{filePathToShowToUser}=definedAtData;return assert(filePathToShowToUser),filePathToShowToUser}function getPageContextExports(pageFiles,pageConfig){const configEntries={},config={},exportsAll={};pageFiles.forEach(pageFile=>{getExportValues(pageFile).forEach(({exportName,exportValue,isFromDefaultExport})=>{assert(exportName!=="default"),exportsAll[exportName]=exportsAll[exportName]??[],exportsAll[exportName].push({exportValue,exportSource:`${pageFile.filePath} > ${isFromDefaultExport?`\`export default { ${exportName} }\``:`\`export { ${exportName} }\``}`,filePath:pageFile.filePath,_filePath:pageFile.filePath,_fileType:pageFile.fileType,_isFromDefaultExport:isFromDefaultExport})})});const source={},sources={},addSrc=(src,configName)=>{source[configName]=src,sources[configName]??(sources[configName]=[]),sources[configName].push(src)},from={configsStandard:{},configsCumulative:{},configsComputed:{}};pageConfig&&Object.entries(pageConfig.configValues).forEach(([configName,configValue])=>{const{value}=configValue,configValueFilePathToShowToUser=getConfigValueFilePathToShowToUser(configValue.definedAtData),configDefinedAt=getConfigDefinedAtOptional("Config",configName,configValue.definedAtData);if(config[configName]=config[configName]??value,configEntries[configName]=configEntries[configName]??[],assert(configEntries[configName].length===0),configEntries[configName].push({configValue:value,configDefinedAt,configDefinedByFile:configValueFilePathToShowToUser}),configValue.type==="standard"){const src={type:"configsStandard",value:configValue.value,definedAt:getDefinedAtString(configValue.definedAtData,configName)};addSrc(src,configName),from.configsStandard[configName]=src}if(configValue.type==="cumulative"){const src={type:"configsCumulative",values:configValue.value.map((value2,i)=>{const definedAtFile=configValue.definedAtData[i];assert(definedAtFile);const definedAt=getDefinedAtString(definedAtFile,configName);return{value:value2,definedAt}})};addSrc(src,configName),from.configsCumulative[configName]=src}if(configValue.type==="computed"){const src={type:"configsComputed",value:configValue.value};addSrc(src,configName),from.configsComputed[configName]=src}const exportName=configName;exportsAll[exportName]=exportsAll[exportName]??[],exportsAll[exportName].push({exportValue:value,exportSource:configDefinedAt,filePath:configValueFilePathToShowToUser,_filePath:configValueFilePathToShowToUser,_fileType:null,_isFromDefaultExport:null})});const pageExports=createObjectWithDeprecationWarning(),exports={};return Object.entries(exportsAll).forEach(([exportName,values])=>{values.forEach(({exportValue,_fileType,_isFromDefaultExport})=>{exports[exportName]=exports[exportName]??exportValue,_fileType===".page"&&!_isFromDefaultExport&&(exportName in pageExports||(pageExports[exportName]=exportValue))})}),assert(!("default"in exports)),assert(!("default"in exportsAll)),{from,source,sources,config,configEntries,exports,exportsAll,pageExports}}function getExportValues(pageFile){const{filePath,fileExports}=pageFile;assert(fileExports),assert(isScriptFile(filePath));const exportValues=[];return Object.entries(fileExports).sort(makeLast(([exportName])=>exportName==="default")).forEach(([exportName,exportValue])=>{let isFromDefaultExport=exportName==="default";if(isFromDefaultExport)if(isTemplateFile(filePath))exportName="Page";else{assertUsage(isObject(exportValue),`The ${pc.cyan("export default")} of ${filePath} should be an object.`),Object.entries(exportValue).forEach(([defaultExportName,defaultExportValue])=>{assertDefaultExports(defaultExportName,filePath),exportValues.push({exportName:defaultExportName,exportValue:defaultExportValue,isFromDefaultExport})});return}exportValues.push({exportName,exportValue,isFromDefaultExport})}),exportValues.forEach(({exportName,isFromDefaultExport})=>{assert(!(isFromDefaultExport&&forbiddenDefaultExports.includes(exportName)))}),exportValues}function createObjectWithDeprecationWarning(){return new Proxy({},{get(...args){return isBrowser()||assertWarning(!1,"`pageContext.pageExports` is outdated. Use `pageContext.exports` instead, see https://vike.dev/exports",{onlyOnce:!0,showStackTrace:!0}),Reflect.get(...args)}})}const pageFilesLazy={},pageFilesEager={},pageFilesExportNamesLazy={},pageFilesExportNamesEager={},pageFilesList=[],neverLoaded={},pageConfigsSerialized=[{pageId:"/pages/catch-all",isErrorPage:void 0,routeFilesystem:{routeString:"/catch-all",definedBy:"/pages/catch-all/"},loadConfigValuesAll:()=>__vitePreload(()=>import("./pages_catch-all.Gg1t_S6m.js").then(n=>n.l),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),configValuesSerialized:{clientEntryLoaded:{type:"computed",definedAtData:null,valueSerialized:{type:"js-serialized",value:!0}},onBeforeRenderEnv:{type:"computed",definedAtData:null,valueSerialized:{type:"js-serialized",value:null}},dataEnv:{type:"computed",definedAtData:null,valueSerialized:{type:"js-serialized",value:null}}}}],pageConfigGlobalSerialized={configValuesSerialized:{}},pageFilesLazyIsomorph1=Object.assign({}),pageFilesLazyIsomorph={...pageFilesLazyIsomorph1};pageFilesLazy[".page"]=pageFilesLazyIsomorph;const pageFilesLazyClient1=Object.assign({}),pageFilesLazyClient={...pageFilesLazyClient1};pageFilesLazy[".page.client"]=pageFilesLazyClient;const neverLoadedServer1=Object.assign({}),neverLoadedServer={...neverLoadedServer1};neverLoaded[".page.server"]=neverLoadedServer;const pageFilesExports=Object.freeze(Object.defineProperty({__proto__:null,neverLoaded,pageConfigGlobalSerialized,pageConfigsSerialized,pageFilesEager,pageFilesExportNamesEager,pageFilesExportNamesLazy,pageFilesLazy,pageFilesList},Symbol.toStringTag,{value:"Module"}));setPageFiles(pageFilesExports);function assertIsBrowser(){assert(isBrowser())}function onLoad(){assertIsBrowser()}function humanizeTime(milliseconds){const seconds=milliseconds/1e3;if(seconds<120){const n=round(seconds);return`${n} second${plural(n)}`}{const minutes=seconds/60,n=round(minutes);return`${n} minute${plural(n)}`}}function round(n){let rounded=n.toFixed(1);return rounded.endsWith(".0")&&(rounded=rounded.slice(0,-2)),rounded}function plural(n){return n==="1"?"":"s"}const globalObject$2=getGlobalObject("utils/executeHook.ts",{userHookErrors:new WeakMap,pageContext:null});function executeHook(hookFnCaller,hook,pageContext){const{hookName,hookFilePath,hookTimeout:{error:timeoutErr,warning:timeoutWarn}}=hook;let resolve,reject;const promise=new Promise((resolve_,reject_)=>{resolve=ret=>{clearTimeouts(),resolve_(ret)},reject=err=>{clearTimeouts(),reject_(err)}}),clearTimeouts=()=>{currentTimeoutWarn&&clearTimeout(currentTimeoutWarn),currentTimeoutErr&&clearTimeout(currentTimeoutErr)},currentTimeoutWarn=isNotDisabled(timeoutWarn)&&setTimeout(()=>{assertWarning(!1,`The ${hookName}() hook defined by ${hookFilePath} is slow: it's taking more than ${humanizeTime(timeoutWarn)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},timeoutWarn),currentTimeoutErr=isNotDisabled(timeoutErr)&&setTimeout(()=>{const err=getProjectError(`The ${hookName}() hook defined by ${hookFilePath} timed out: it didn't finish after ${humanizeTime(timeoutErr)} (https://vike.dev/hooksTimeout)`);reject(err)},timeoutErr);return(async()=>{try{providePageContext(pageContext);const ret=await hookFnCaller();resolve(ret)}catch(err){isObject(err)&&globalObject$2.userHookErrors.set(err,{hookName,hookFilePath}),reject(err)}})(),promise}function isNotDisabled(timeout){return!!timeout&&timeout!==1/0}function providePageContext(pageContext){globalObject$2.pageContext=pageContext,Promise.resolve().then(()=>{globalObject$2.pageContext=null})}function getCurrentUrl(options){const url=window.location.href,{searchOriginal,hashOriginal,pathname}=parseUrl(url,"/");let urlCurrent;return options!=null&&options.withoutHash?urlCurrent=`${pathname}${searchOriginal||""}`:urlCurrent=`${pathname}${searchOriginal||""}${hashOriginal||""}`,assert(urlCurrent.startsWith("/")),urlCurrent}function getPropAccessNotation(key){return typeof key=="string"&&isKeyDotNotationCompatible(key)?`.${key}`:`[${JSON.stringify(key)}]`}function isKeyDotNotationCompatible(key){return/^[a-z0-9\$_]+$/i.test(key)}onLoad();function getPageContextSerializedInHtml(){const id="vike_pageContext",elem=document.getElementById(id);assertUsage(elem,`Couldn't find #${id} (which Vike automatically injects in the HTML): make sure it exists (i.e. don't remove it and make sure your HTML isn't malformed)`);const pageContextJson=elem.textContent;assert(pageContextJson);const pageContextSerializedInHtml=parse(pageContextJson);return assert(hasProp(pageContextSerializedInHtml,"_pageId","string")),assert(hasProp(pageContextSerializedInHtml,"routeParams","string{}")),pageContextSerializedInHtml}function findPageConfig(pageConfigs,pageId){const result=pageConfigs.filter(p=>p.pageId===pageId);return assert(result.length<=1),result[0]??null}async function loadConfigValues(pageConfig,isDev){if("isAllLoaded"in pageConfig&&!isDev)return pageConfig;const configValuesLoaded=await pageConfig.loadConfigValuesAll(),configValues=parseConfigValuesSerialized(configValuesLoaded.configValuesSerialized);return Object.assign(pageConfig.configValues,configValues),objectAssign(pageConfig,{isAllLoaded:!0}),pageConfig}const stamp="__whileFetchingAssets";async function loadUserFilesClientSide(pageId,pageFilesAll,pageConfigs){const pageFilesClientSide=getPageFilesClientSide(pageFilesAll,pageId),pageConfig=findPageConfig(pageConfigs,pageId);let pageConfigLoaded;const isDev=!1;try{pageConfigLoaded=(await Promise.all([pageConfig&&loadConfigValues(pageConfig,isDev),...pageFilesClientSide.map(p=>{var _a;return(_a=p.loadFile)==null?void 0:_a.call(p)})]))[0]}catch(err){throw isFetchError(err)&&Object.assign(err,{[stamp]:!0}),err}const pageContextExports=getPageContextExports(pageFilesClientSide,pageConfigLoaded),pageContextAddendum={};return objectAssign(pageContextAddendum,pageContextExports),objectAssign(pageContextAddendum,{_pageFilesLoaded:pageFilesClientSide}),pageContextAddendum}function isFetchError(err){return err instanceof Error?["Failed to fetch dynamically imported module","error loading dynamically imported module","Importing a module script failed","error resolving module specifier","failed to resolve module"].some(s=>err.message.toLowerCase().includes(s.toLowerCase())):!1}const urlFirst=getCurrentUrl({withoutHash:!0});async function getPageContext(){const pageContext=getPageContextSerializedInHtml();return objectAssign(pageContext,{isHydration:!0,isBackwardNavigation:null,_hasPageContextFromServer:!0,_hasPageContextFromClient:!1}),objectAssign(pageContext,await loadPageUserFiles(pageContext._pageId)),assertPristineUrl(),pageContext}function assertPristineUrl(){const urlCurrent=getCurrentUrl({withoutHash:!0});assertUsage(urlFirst===urlCurrent,`The URL was manipulated before the hydration finished ('${urlFirst}' to '${urlCurrent}'). Ensure the hydration has finished before manipulating the URL. Consider using the onHydrationEnd() hook.`)}async function loadPageUserFiles(pageId){const pageContextAddendum={},{pageFilesAll,pageConfigs}=await getPageFilesAll();return objectAssign(pageContextAddendum,{_pageFilesAll:pageFilesAll,_pageConfigs:pageConfigs}),objectAssign(pageContextAddendum,await loadUserFilesClientSide(pageId,pageContextAddendum._pageFilesAll,pageContextAddendum._pageConfigs)),pageFilesAll.filter(p=>p.fileType!==".page.server").forEach(p=>{var _a;assertWarning(!((_a=p.fileExports)!=null&&_a.onBeforeRender),`export { onBeforeRender } of ${p.filePath} is loaded in the browser but never executed (because you are using Server-side Routing). In order to reduce the size of you browser-side JavaScript, define onBeforeRender() in a .page.server.js file instead, see https://vike.dev/onBeforeRender-isomorphic#server-routing`,{onlyOnce:!0})}),pageContextAddendum}const globalObject$1=getGlobalObject("getHook.ts",{});function getHook(pageContext,hookName){if(!(hookName in pageContext.exports))return null;const{hooksTimeout}=pageContext.config,hookTimeout=getHookTimeout(hooksTimeout,hookName),hookFn=pageContext.exports[hookName],file=pageContext.exportsAll[hookName][0];if(assert(file.exportValue===hookFn),hookFn===null)return null;const hookFilePath=file.filePath;return assert(hookFilePath),assert(!hookFilePath.endsWith(" ")),assertHookFn(hookFn,{hookName,hookFilePath}),{hookFn,hookName,hookFilePath,hookTimeout}}function assertHook(pageContext,hookName){getHook(pageContext,hookName)}function assertHookFn(hookFn,{hookName,hookFilePath}){assert(hookName&&hookFilePath),assert(!hookName.endsWith(")")),assertUsage(isCallable(hookFn),`Hook ${hookName}() defined by ${hookFilePath} should be a function`)}function getHookTimeout(hooksTimeoutProvidedByUser,hookName){const hooksTimeoutProvidedbyUserNormalized=getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser);if(hooksTimeoutProvidedbyUserNormalized===!1)return{error:!1,warning:!1};const providedbyUser=hooksTimeoutProvidedbyUserNormalized[hookName],hookTimeout=getHookTimeoutDefault(hookName);return(providedbyUser==null?void 0:providedbyUser.error)!==void 0&&(hookTimeout.error=providedbyUser.error),(providedbyUser==null?void 0:providedbyUser.warning)!==void 0&&(hookTimeout.warning=providedbyUser.warning),hookTimeout}function getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser){if(hooksTimeoutProvidedByUser===void 0)return{};if(hooksTimeoutProvidedByUser===!1)return!1;assertUsage(isObject(hooksTimeoutProvidedByUser),`Setting ${pc.cyan("hooksTimeout")} should be ${pc.cyan("false")} or an object`);const hooksTimeoutProvidedByUserNormalized={};return Object.entries(hooksTimeoutProvidedByUser).forEach(([hookName,hookTimeoutProvidedbyUser])=>{if(hookTimeoutProvidedbyUser===!1){hooksTimeoutProvidedByUserNormalized[hookName]={error:!1,warning:!1};return}assertUsage(isObject(hookTimeoutProvidedbyUser),`Setting ${pc.cyan(`hooksTimeout.${hookName}`)} should be ${pc.cyan("false")} or an object`);const[error,warning]=["error","warning"].map(timeoutName=>{const timeoutVal=hookTimeoutProvidedbyUser[timeoutName];if(timeoutVal===void 0||timeoutVal===!1)return timeoutVal;const errPrefix=`Setting ${pc.cyan(`hooksTimeout.${hookName}.${timeoutName}`)} should be`;return assertUsage(typeof timeoutVal=="number",`${errPrefix} ${pc.cyan("false")} or a number`),assertUsage(timeoutVal>0,`${errPrefix} a positive number`),timeoutVal});hooksTimeoutProvidedByUserNormalized[hookName]={error,warning}}),hooksTimeoutProvidedByUserNormalized}function getHookTimeoutDefault(hookName){return hookName==="onBeforeRoute"?{error:5*1e3,warning:1*1e3}:globalObject$1.isPrerendering?{error:2*60*1e3,warning:30*1e3}:(assert(!hookName.toLowerCase().includes("prerender")),{error:30*1e3,warning:4*1e3})}function sortPageContext(pageContext){let descriptors=Object.getOwnPropertyDescriptors(pageContext);for(const key of Object.keys(pageContext))delete pageContext[key];descriptors=Object.fromEntries(Object.entries(descriptors).sort(([key1],[key2])=>compareString(key1,key2))),Object.defineProperties(pageContext,descriptors)}function addIs404ToPageProps(pageContext){assertIs404(pageContext),addIs404(pageContext)}function assertIs404(pageContext){isErrorPage(pageContext._pageId,pageContext._pageConfigs)&&assert(hasProp(pageContext,"is404","boolean"))}function addIs404(pageContext){if(pageContext.is404===void 0||pageContext.is404===null)return;const pageProps=pageContext.pageProps||{};if(!isObject(pageProps)){assertWarning(!1,"pageContext.pageProps should be an object",{showStackTrace:!0,onlyOnce:!0});return}pageProps.is404=pageProps.is404||pageContext.is404,pageContext.pageProps=pageProps}const notSerializable="not-serializable",globalObject=getGlobalObject("getPageContextProxyForUser.ts",{});function getPageContextProxyForUser(pageContext){return assert([!0,!1].includes(pageContext._hasPageContextFromServer)),assert([!0,!1].includes(pageContext._hasPageContextFromClient)),new Proxy(pageContext,{get(_,prop){const val=pageContext[prop],propName=getPropAccessNotation(prop);return assertUsage(val!==notSerializable,`Can't access pageContext${propName} on the client side. Because it can't be serialized, see server logs.`),passToClientHint(pageContext,prop,propName),val}})}function passToClientHint(pageContext,prop,propName){if(handleVueReactivity(prop)||prop in pageContext||isWhitelisted(prop)||!pageContext._hasPageContextFromServer)return;const errMsg=`pageContext${propName} isn't defined on the client-side, see https://vike.dev/passToClient#error`;pageContext._hasPageContextFromClient?assertWarning(!1,errMsg,{onlyOnce:!1,showStackTrace:!0}):assertUsage(!1,errMsg)}const WHITELIST=["then","toJSON"];function isWhitelisted(prop){return!!(WHITELIST.includes(prop)||typeof prop=="symbol"||typeof prop!="string"||prop.startsWith("__v_"))}function handleVueReactivity(prop){return globalObject.prev===prop||globalObject.prev==="__v_raw"?!0:(globalObject.prev=prop,window.setTimeout(()=>{globalObject.prev=void 0},0),!1)}function preparePageContextForUserConsumptionClientSide(pageContext,isClientRouting){{const pageContextTyped=pageContext;assert(pageContextTyped.isHydration===!0),assert(pageContextTyped.isBackwardNavigation===null)}assert("config"in pageContext),assert("configEntries"in pageContext),assert("exports"in pageContext),assert("exportsAll"in pageContext),assert("pageExports"in pageContext),assert(isObject(pageContext.pageExports));const Page=pageContext.exports.Page;objectAssign(pageContext,{Page}),resolveGetters(pageContext),sortPageContext(pageContext);const pageContextForUserConsumption=getPageContextProxyForUser(pageContext);return addIs404ToPageProps(pageContext),pageContextForUserConsumption}function resolveGetters(pageContext){Object.entries(pageContext).forEach(([key,val])=>{delete pageContext[key],pageContext[key]=val})}async function executeOnRenderClientHook(pageContext,isClientRouting){const pageContextForUserConsumption=preparePageContextForUserConsumptionClientSide(pageContext);let hook=null,hookName;hook=getHook(pageContext,"render"),hookName="render";{const renderHook2=getHook(pageContext,"onRenderClient");renderHook2&&(hook=renderHook2,hookName="onRenderClient")}if(!hook){const urlToShowToUser=getUrlToShowToUser(pageContext);if(assert(urlToShowToUser),pageContext._pageConfigs.length>0)assertUsage(!1,`No onRenderClient() hook defined for URL '${urlToShowToUser}', but it's needed, see https://vike.dev/onRenderClient`);else{const pageClientsFilesLoaded=pageContext._pageFilesLoaded.filter(p=>p.fileType===".page.client");let errMsg;pageClientsFilesLoaded.length===0?errMsg="No file `*.page.client.*` found for URL "+urlToShowToUser:errMsg="One of the following files should export a render() hook: "+pageClientsFilesLoaded.map(p=>p.filePath).join(" "),assertUsage(!1,errMsg)}}assert(hook);const renderHook=hook.hookFn;assert(hookName);const hookResult=await executeHook(()=>renderHook(pageContextForUserConsumption),hook,pageContext);assertUsage(hookResult===void 0,`The ${hookName}() hook defined by ${hook.hookFilePath} isn't allowed to return a value`)}function getUrlToShowToUser(pageContext){let url;try{url=pageContext.urlPathname??pageContext.urlOriginal}catch{}return url=url??window.location.href,url}assertServerRouting();assertSingleInstance_onClientEntryServerRouting();hydrate();async function hydrate(){var _a,_b;const pageContext=await getPageContext();await executeOnRenderClientHook(pageContext),assertHook(pageContext,"onHydrationEnd"),await((_b=(_a=pageContext.exports).onHydrationEnd)==null?void 0:_b.call(_a,pageContext))}

</script>

</body>
</html>
